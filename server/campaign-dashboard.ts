import { EventEmitter } from 'events';\n\nexport type CampaignStatus = 'draft' | 'scheduled' | 'running' | 'paused' | 'completed' | 'failed';\n\nexport interface CampaignMetrics {\n  campaignId: string;\n  campaignName: string;\n  status: CampaignStatus;\n  totalRecipients: number;\n  sent: number;\n  delivered: number;\n  opened: number;\n  clicked: number;\n  converted: number;\n  failed: number;\n  bounced: number;\n  unsubscribed: number;\n  deliveryRate: number;\n  openRate: number;\n  clickRate: number;\n  conversionRate: number;\n  unsubscribeRate: number;\n  estimatedCompletion: number;\n  progress: number;\n}\n\nexport interface RecipientStatus {\n  recipientId: string;\n  email: string;\n  phoneNumber?: string;\n  status: 'pending' | 'sent' | 'delivered' | 'opened' | 'clicked' | 'converted' | 'failed' | 'bounced' | 'unsubscribed';\n  sentAt?: number;\n  deliveredAt?: number;\n  openedAt?: number;\n  clickedAt?: number;\n  convertedAt?: number;\n  failureReason?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface CampaignTimeSeries {\n  timestamp: number;\n  sent: number;\n  delivered: number;\n  opened: number;\n  clicked: number;\n  converted: number;\n  failed: number;\n}\n\nexport interface CampaignComparison {\n  campaignId: string;\n  campaignName: string;\n  deliveryRate: number;\n  openRate: number;\n  clickRate: number;\n  conversionRate: number;\n  roi: number;\n}\n\nexport interface DashboardSnapshot {\n  timestamp: number;\n  activeCampaigns: number;\n  totalRecipients: number;\n  totalSent: number;\n  totalDelivered: number;\n  totalOpened: number;\n  totalClicked: number;\n  totalConverted: number;\n  averageDeliveryRate: number;\n  averageOpenRate: number;\n  averageClickRate: number;\n  averageConversionRate: number;\n}\n\nclass CampaignPerformanceDashboard extends EventEmitter {\n  private campaigns: Map<string, CampaignMetrics> = new Map();\n  private recipientStatuses: Map<string, Map<string, RecipientStatus>> = new Map();\n  private timeSeries: Map<string, CampaignTimeSeries[]> = new Map();\n  private snapshots: DashboardSnapshot[] = [];\n  private snapshotInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    super();\n    this.startSnapshotCapture();\n  }\n\n  /**\n   * Create campaign\n   */\n  createCampaign(\n    campaignId: string,\n    campaignName: string,\n    totalRecipients: number\n  ): CampaignMetrics {\n    const campaign: CampaignMetrics = {\n      campaignId,\n      campaignName,\n      status: 'draft',\n      totalRecipients,\n      sent: 0,\n      delivered: 0,\n      opened: 0,\n      clicked: 0,\n      converted: 0,\n      failed: 0,\n      bounced: 0,\n      unsubscribed: 0,\n      deliveryRate: 0,\n      openRate: 0,\n      clickRate: 0,\n      conversionRate: 0,\n      unsubscribeRate: 0,\n      estimatedCompletion: 0,\n      progress: 0,\n    };\n\n    this.campaigns.set(campaignId, campaign);\n    this.recipientStatuses.set(campaignId, new Map());\n    this.timeSeries.set(campaignId, []);\n    this.emit('campaign:created', campaign);\n    return campaign;\n  }\n\n  /**\n   * Get campaign metrics\n   */\n  getCampaignMetrics(campaignId: string): CampaignMetrics | undefined {\n    return this.campaigns.get(campaignId);\n  }\n\n  /**\n   * Update campaign status\n   */\n  updateCampaignStatus(campaignId: string, status: CampaignStatus): boolean {\n    const campaign = this.campaigns.get(campaignId);\n    if (!campaign) return false;\n\n    campaign.status = status;\n    this.emit('campaign:status_updated', { campaignId, status });\n    return true;\n  }\n\n  /**\n   * Record recipient event\n   */\n  recordRecipientEvent(\n    campaignId: string,\n    recipientId: string,\n    email: string,\n    eventType: 'sent' | 'delivered' | 'opened' | 'clicked' | 'converted' | 'failed' | 'bounced' | 'unsubscribed',\n    metadata?: Record<string, any>\n  ): boolean {\n    const campaign = this.campaigns.get(campaignId);\n    if (!campaign) return false;\n\n    const recipients = this.recipientStatuses.get(campaignId);\n    if (!recipients) return false;\n\n    let recipient = recipients.get(recipientId);\n    if (!recipient) {\n      recipient = {\n        recipientId,\n        email,\n        status: 'pending',\n        metadata,\n      };\n      recipients.set(recipientId, recipient);\n    }\n\n    const now = Date.now();\n    recipient.status = eventType;\n    recipient.metadata = metadata;\n\n    switch (eventType) {\n      case 'sent':\n        campaign.sent++;\n        recipient.sentAt = now;\n        break;\n      case 'delivered':\n        campaign.delivered++;\n        recipient.deliveredAt = now;\n        break;\n      case 'opened':\n        campaign.opened++;\n        recipient.openedAt = now;\n        break;\n      case 'clicked':\n        campaign.clicked++;\n        recipient.clickedAt = now;\n        break;\n      case 'converted':\n        campaign.converted++;\n        recipient.convertedAt = now;\n        break;\n      case 'failed':\n        campaign.failed++;\n        recipient.failureReason = metadata?.reason || 'Unknown error';\n        break;\n      case 'bounced':\n        campaign.bounced++;\n        break;\n      case 'unsubscribed':\n        campaign.unsubscribed++;\n        break;\n    }\n\n    this.updateMetrics(campaignId);\n    this.recordTimeSeries(campaignId, eventType);\n    this.emit('recipient:event', { campaignId, recipientId, eventType });\n    return true;\n  }\n\n  /**\n   * Update metrics\n   */\n  private updateMetrics(campaignId: string): void {\n    const campaign = this.campaigns.get(campaignId);\n    if (!campaign) return;\n\n    campaign.deliveryRate = (campaign.delivered / Math.max(campaign.sent, 1)) * 100;\n    campaign.openRate = (campaign.opened / Math.max(campaign.delivered, 1)) * 100;\n    campaign.clickRate = (campaign.clicked / Math.max(campaign.opened, 1)) * 100;\n    campaign.conversionRate = (campaign.converted / Math.max(campaign.clicked, 1)) * 100;\n    campaign.unsubscribeRate = (campaign.unsubscribed / Math.max(campaign.totalRecipients, 1)) * 100;\n\n    const processed = campaign.sent + campaign.failed + campaign.bounced;\n    campaign.progress = (processed / campaign.totalRecipients) * 100;\n\n    // Estimate completion time\n    if (campaign.progress > 0 && campaign.progress < 100) {\n      const timeElapsed = Date.now() - (campaign.estimatedCompletion || Date.now());\n      const estimatedTotal = (timeElapsed / campaign.progress) * 100;\n      campaign.estimatedCompletion = Date.now() + (estimatedTotal - timeElapsed);\n    }\n  }\n\n  /**\n   * Record time series\n   */\n  private recordTimeSeries(campaignId: string, eventType: string): void {\n    const series = this.timeSeries.get(campaignId);\n    if (!series) return;\n\n    const now = Date.now();\n    const hour = Math.floor(now / (60 * 60 * 1000)) * (60 * 60 * 1000);\n\n    let entry = series.find((s) => s.timestamp === hour);\n    if (!entry) {\n      entry = {\n        timestamp: hour,\n        sent: 0,\n        delivered: 0,\n        opened: 0,\n        clicked: 0,\n        converted: 0,\n        failed: 0,\n      };\n      series.push(entry);\n    }\n\n    switch (eventType) {\n      case 'sent':\n        entry.sent++;\n        break;\n      case 'delivered':\n        entry.delivered++;\n        break;\n      case 'opened':\n        entry.opened++;\n        break;\n      case 'clicked':\n        entry.clicked++;\n        break;\n      case 'converted':\n        entry.converted++;\n        break;\n      case 'failed':\n      case 'bounced':\n        entry.failed++;\n        break;\n    }\n\n    // Keep last 30 days\n    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    const filtered = series.filter((s) => s.timestamp > thirtyDaysAgo);\n    this.timeSeries.set(campaignId, filtered);\n  }\n\n  /**\n   * Get recipient status\n   */\n  getRecipientStatus(campaignId: string, recipientId: string): RecipientStatus | undefined {\n    const recipients = this.recipientStatuses.get(campaignId);\n    return recipients?.get(recipientId);\n  }\n\n  /**\n   * Get all recipient statuses for campaign\n   */\n  getRecipientStatuses(campaignId: string, filter?: { status?: string }): RecipientStatus[] {\n    const recipients = this.recipientStatuses.get(campaignId);\n    if (!recipients) return [];\n\n    let statuses = Array.from(recipients.values());\n    if (filter?.status) {\n      statuses = statuses.filter((s) => s.status === filter.status);\n    }\n    return statuses;\n  }\n\n  /**\n   * Get time series data\n   */\n  getTimeSeries(campaignId: string): CampaignTimeSeries[] {\n    return this.timeSeries.get(campaignId) || [];\n  }\n\n  /**\n   * Get active campaigns\n   */\n  getActiveCampaigns(): CampaignMetrics[] {\n    return Array.from(this.campaigns.values()).filter(\n      (c) => c.status === 'running' || c.status === 'scheduled'\n    );\n  }\n\n  /**\n   * Get all campaigns\n   */\n  getAllCampaigns(): CampaignMetrics[] {\n    return Array.from(this.campaigns.values());\n  }\n\n  /**\n   * Compare campaigns\n   */\n  compareCampaigns(campaignIds: string[]): CampaignComparison[] {\n    return campaignIds\n      .map((id) => this.campaigns.get(id))\n      .filter((c) => c !== undefined)\n      .map((c) => ({\n        campaignId: c!.campaignId,\n        campaignName: c!.campaignName,\n        deliveryRate: c!.deliveryRate,\n        openRate: c!.openRate,\n        clickRate: c!.clickRate,\n        conversionRate: c!.conversionRate,\n        roi: (c!.converted / Math.max(c!.sent, 1)) * 100,\n      }));\n  }\n\n  /**\n   * Start snapshot capture\n   */\n  private startSnapshotCapture(): void {\n    this.snapshotInterval = setInterval(() => {\n      this.captureSnapshot();\n    }, 60 * 60 * 1000); // Every hour\n  }\n\n  /**\n   * Capture dashboard snapshot\n   */\n  private captureSnapshot(): void {\n    const activeCampaigns = this.getActiveCampaigns();\n    const allCampaigns = this.getAllCampaigns();\n\n    let totalRecipients = 0;\n    let totalSent = 0;\n    let totalDelivered = 0;\n    let totalOpened = 0;\n    let totalClicked = 0;\n    let totalConverted = 0;\n\n    for (const campaign of allCampaigns) {\n      totalRecipients += campaign.totalRecipients;\n      totalSent += campaign.sent;\n      totalDelivered += campaign.delivered;\n      totalOpened += campaign.opened;\n      totalClicked += campaign.clicked;\n      totalConverted += campaign.converted;\n    }\n\n    const snapshot: DashboardSnapshot = {\n      timestamp: Date.now(),\n      activeCampaigns: activeCampaigns.length,\n      totalRecipients,\n      totalSent,\n      totalDelivered,\n      totalOpened,\n      totalClicked,\n      totalConverted,\n      averageDeliveryRate: (totalDelivered / Math.max(totalSent, 1)) * 100,\n      averageOpenRate: (totalOpened / Math.max(totalDelivered, 1)) * 100,\n      averageClickRate: (totalClicked / Math.max(totalOpened, 1)) * 100,\n      averageConversionRate: (totalConverted / Math.max(totalClicked, 1)) * 100,\n    };\n\n    this.snapshots.push(snapshot);\n\n    // Keep last 30 days\n    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    this.snapshots = this.snapshots.filter((s) => s.timestamp > thirtyDaysAgo);\n\n    this.emit('snapshot:captured', snapshot);\n  }\n\n  /**\n   * Get latest snapshot\n   */\n  getLatestSnapshot(): DashboardSnapshot | undefined {\n    return this.snapshots[this.snapshots.length - 1];\n  }\n\n  /**\n   * Get snapshots\n   */\n  getSnapshots(timeRange?: { start: number; end: number }): DashboardSnapshot[] {\n    let filtered = [...this.snapshots];\n    if (timeRange) {\n      filtered = filtered.filter(\n        (s) => s.timestamp >= timeRange.start && s.timestamp <= timeRange.end\n      );\n    }\n    return filtered;\n  }\n\n  /**\n   * Get campaign summary\n   */\n  getCampaignSummary(campaignId: string): Record<string, any> | null {\n    const campaign = this.campaigns.get(campaignId);\n    if (!campaign) return null;\n\n    const recipients = this.recipientStatuses.get(campaignId) || new Map();\n    const timeSeries = this.timeSeries.get(campaignId) || [];\n\n    return {\n      campaign,\n      recipientCount: recipients.size,\n      recipientsByStatus: this.getRecipientStatusCounts(campaignId),\n      timeSeries,\n      topPerformingHours: this.getTopPerformingHours(campaignId),\n    };\n  }\n\n  /**\n   * Get recipient status counts\n   */\n  private getRecipientStatusCounts(campaignId: string): Record<string, number> {\n    const recipients = this.recipientStatuses.get(campaignId) || new Map();\n    const counts: Record<string, number> = {};\n\n    for (const recipient of recipients.values()) {\n      counts[recipient.status] = (counts[recipient.status] || 0) + 1;\n    }\n\n    return counts;\n  }\n\n  /**\n   * Get top performing hours\n   */\n  private getTopPerformingHours(campaignId: string): Array<{ hour: number; opens: number }> {\n    const timeSeries = this.timeSeries.get(campaignId) || [];\n    return timeSeries\n      .map((s) => ({\n        hour: new Date(s.timestamp).getHours(),\n        opens: s.opened,\n      }))\n      .sort((a, b) => b.opens - a.opens)\n      .slice(0, 5);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.snapshotInterval) {\n      clearInterval(this.snapshotInterval);\n    }\n  }\n}\n\nexport default CampaignPerformanceDashboard;\n
