import { EventEmitter } from 'events';\n\nexport type ProcedureType = 'query' | 'mutation' | 'subscription';\nexport type ParameterType = 'string' | 'number' | 'boolean' | 'object' | 'array' | 'date';\n\nexport interface Parameter {\n  /**\n   * Parameter name\n   */\n  name: string;\n  /**\n   * Parameter type\n   */\n  type: ParameterType;\n  /**\n   * Is required\n   */\n  required: boolean;\n  /**\n   * Description\n   */\n  description?: string;\n  /**\n   * Example value\n   */\n  example?: any;\n  /**\n   * Default value\n   */\n  default?: any;\n}\n\nexport interface ResponseSchema {\n  /**\n   * Response type\n   */\n  type: ParameterType;\n  /**\n   * Description\n   */\n  description?: string;\n  /**\n   * Example response\n   */\n  example?: any;\n  /**\n   * Properties (for object type)\n   */\n  properties?: Record<string, ResponseSchema>;\n}\n\nexport interface ErrorResponse {\n  /**\n   * Error code\n   */\n  code: string;\n  /**\n   * HTTP status code\n   */\n  status: number;\n  /**\n   * Description\n   */\n  description: string;\n}\n\nexport interface ProcedureDoc {\n  /**\n   * Procedure name\n   */\n  name: string;\n  /**\n   * Procedure type\n   */\n  type: ProcedureType;\n  /**\n   * Description\n   */\n  description: string;\n  /**\n   * Parameters\n   */\n  parameters: Parameter[];\n  /**\n   * Response schema\n   */\n  response: ResponseSchema;\n  /**\n   * Possible errors\n   */\n  errors: ErrorResponse[];\n  /**\n   * Authentication required\n   */\n  requiresAuth: boolean;\n  /**\n   * Rate limit\n   */\n  rateLimit?: {\n    requests: number;\n    window: number; // milliseconds\n  };\n  /**\n   * Examples\n   */\n  examples?: Array<{\n    title: string;\n    request: any;\n    response: any;\n  }>;\n  /**\n   * Tags\n   */\n  tags?: string[];\n  /**\n   * Deprecated\n   */\n  deprecated?: boolean;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n}\n\nexport interface APIDocumentation {\n  /**\n   * API version\n   */\n  version: string;\n  /**\n   * API title\n   */\n  title: string;\n  /**\n   * API description\n   */\n  description: string;\n  /**\n   * Base URL\n   */\n  baseUrl: string;\n  /**\n   * Procedures\n   */\n  procedures: ProcedureDoc[];\n  /**\n   * Generated at\n   */\n  generatedAt: number;\n}\n\n/**\n * API Documentation Generator\n */\nexport class APIDocumentationGenerator extends EventEmitter {\n  private procedures: Map<string, ProcedureDoc> = new Map();\n  private version: string = '1.0.0';\n  private title: string = 'FarmKonnect API';\n  private description: string = 'Farm management and operations API';\n  private baseUrl: string = 'http://localhost:3000/api/trpc';\n\n  constructor(config?: { version?: string; title?: string; description?: string; baseUrl?: string }) {\n    super();\n    if (config?.version) this.version = config.version;\n    if (config?.title) this.title = config.title;\n    if (config?.description) this.description = config.description;\n    if (config?.baseUrl) this.baseUrl = config.baseUrl;\n  }\n\n  /**\n   * Register procedure\n   */\n  registerProcedure(doc: ProcedureDoc): void {\n    this.procedures.set(doc.name, doc);\n    this.emit('doc:procedure-registered', { name: doc.name, type: doc.type });\n  }\n\n  /**\n   * Get procedure documentation\n   */\n  getProcedure(name: string): ProcedureDoc | null {\n    return this.procedures.get(name) || null;\n  }\n\n  /**\n   * Get all procedures\n   */\n  getAllProcedures(): ProcedureDoc[] {\n    return Array.from(this.procedures.values());\n  }\n\n  /**\n   * Get procedures by type\n   */\n  getProceduresByType(type: ProcedureType): ProcedureDoc[] {\n    return Array.from(this.procedures.values()).filter((p) => p.type === type);\n  }\n\n  /**\n   * Get procedures by tag\n   */\n  getProceduresByTag(tag: string): ProcedureDoc[] {\n    return Array.from(this.procedures.values()).filter((p) => p.tags?.includes(tag));\n  }\n\n  /**\n   * Generate OpenAPI spec\n   */\n  generateOpenAPISpec(): Record<string, any> {\n    const paths: Record<string, any> = {};\n\n    for (const proc of this.procedures.values()) {\n      const path = `/trpc/${proc.name}`;\n      const method = proc.type === 'query' ? 'get' : 'post';\n\n      paths[path] = {\n        [method]: {\n          summary: proc.description,\n          tags: proc.tags || [],\n          parameters: proc.parameters.map((p) => ({\n            name: p.name,\n            in: method === 'get' ? 'query' : 'body',\n            required: p.required,\n            description: p.description,\n            schema: { type: p.type, example: p.example },\n          })),\n          responses: {\n            200: {\n              description: 'Success',\n              schema: this.responseSchemaToOpenAPI(proc.response),\n            },\n            ...Object.fromEntries(\n              proc.errors.map((e) => [\n                e.status,\n                {\n                  description: e.description,\n                  schema: { type: 'object', properties: { code: { type: 'string' }, message: { type: 'string' } } },\n                },\n              ])\n            ),\n          },\n          security: proc.requiresAuth ? [{ bearerAuth: [] }] : [],\n        },\n      };\n    }\n\n    return {\n      openapi: '3.0.0',\n      info: {\n        title: this.title,\n        description: this.description,\n        version: this.version,\n      },\n      servers: [{ url: this.baseUrl }],\n      paths,\n      components: {\n        securitySchemes: {\n          bearerAuth: {\n            type: 'http',\n            scheme: 'bearer',\n            bearerFormat: 'JWT',\n          },\n        },\n      },\n    };\n  }\n\n  /**\n   * Generate HTML documentation\n   */\n  generateHTMLDocumentation(): string {\n    let html = `\n<!DOCTYPE html>\n<html>\n<head>\n  <title>${this.title} - API Documentation</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }\n    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }\n    h1 { color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }\n    h2 { color: #555; margin-top: 30px; }\n    .procedure { margin: 20px 0; padding: 15px; background: #f9f9f9; border-left: 4px solid #007bff; }\n    .procedure-type { display: inline-block; padding: 4px 8px; border-radius: 4px; font-weight: bold; color: white; }\n    .query { background: #28a745; }\n    .mutation { background: #ffc107; color: black; }\n    .subscription { background: #17a2b8; }\n    .parameter { margin: 10px 0; padding: 10px; background: white; border-radius: 4px; }\n    .required { color: red; font-weight: bold; }\n    code { background: #f0f0f0; padding: 2px 6px; border-radius: 3px; font-family: monospace; }\n    .example { background: #f0f0f0; padding: 10px; border-radius: 4px; margin: 10px 0; overflow-x: auto; }\n    pre { margin: 0; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>${this.title}</h1>\n    <p>${this.description}</p>\n    <p><strong>Base URL:</strong> <code>${this.baseUrl}</code></p>\n    <p><strong>Version:</strong> ${this.version}</p>\n`;\n\n    // Group by type\n    const byType: Record<ProcedureType, ProcedureDoc[]> = { query: [], mutation: [], subscription: [] };\n    for (const proc of this.procedures.values()) {\n      byType[proc.type].push(proc);\n    }\n\n    for (const [type, procs] of Object.entries(byType)) {\n      if (procs.length === 0) continue;\n      html += `<h2>${type.charAt(0).toUpperCase() + type.slice(1)}s</h2>`;\n\n      for (const proc of procs) {\n        html += `\n  <div class=\"procedure\">\n    <h3>\n      <span class=\"procedure-type ${type}\">${type.toUpperCase()}</span>\n      ${proc.name}\n      ${proc.deprecated ? '<span style=\"color: red; margin-left: 10px;\">[DEPRECATED]</span>' : ''}\n    </h3>\n    <p>${proc.description}</p>\n    \n    ${proc.parameters.length > 0 ? `<h4>Parameters</h4>` : ''}\n    ${proc.parameters.map((p) => `\n      <div class=\"parameter\">\n        <strong>${p.name}</strong> <span class=\"${p.required ? 'required' : ''}\">(<code>${p.type}</code>${p.required ? ', required' : ''})</span>\n        ${p.description ? `<p>${p.description}</p>` : ''}\n        ${p.example ? `<p><strong>Example:</strong> <code>${JSON.stringify(p.example)}</code></p>` : ''}\n      </div>\n    `).join('')}\n    \n    <h4>Response</h4>\n    <div class=\"example\">\n      <pre>${JSON.stringify(proc.response.example || {}, null, 2)}</pre>\n    </div>\n    \n    ${proc.errors.length > 0 ? `<h4>Possible Errors</h4>` : ''}\n    ${proc.errors.map((e) => `\n      <div class=\"parameter\">\n        <strong>${e.code}</strong> (${e.status}): ${e.description}\n      </div>\n    `).join('')}\n    \n    ${proc.requiresAuth ? '<p><strong>Authentication:</strong> Required (Bearer Token)</p>' : ''}\n    ${proc.rateLimit ? `<p><strong>Rate Limit:</strong> ${proc.rateLimit.requests} requests per ${proc.rateLimit.window}ms</p>` : ''}\n  </div>\n        `;\n      }\n    }\n\n    html += `\n  </div>\n</body>\n</html>\n    `;\n\n    return html;\n  }\n\n  /**\n   * Generate Markdown documentation\n   */\n  generateMarkdownDocumentation(): string {\n    let md = `# ${this.title}\\n\\n${this.description}\\n\\n**Base URL:** \`${this.baseUrl}\`\\n**Version:** ${this.version}\\n\\n`;\n\n    const byType: Record<ProcedureType, ProcedureDoc[]> = { query: [], mutation: [], subscription: [] };\n    for (const proc of this.procedures.values()) {\n      byType[proc.type].push(proc);\n    }\n\n    for (const [type, procs] of Object.entries(byType)) {\n      if (procs.length === 0) continue;\n      md += `## ${type.charAt(0).toUpperCase() + type.slice(1)}s\\n\\n`;\n\n      for (const proc of procs) {\n        md += `### ${proc.name}\\n\\n${proc.description}\\n\\n`;\n        md += `**Type:** \`${proc.type}\`\\n`;\n        md += `${proc.deprecated ? '**Status:** DEPRECATED\\n' : ''}`;\n        md += `${proc.requiresAuth ? '**Authentication:** Required (Bearer Token)\\n' : ''}`;\n        md += `${proc.rateLimit ? `**Rate Limit:** ${proc.rateLimit.requests} requests per ${proc.rateLimit.window}ms\\n` : ''}\\n`;\n\n        if (proc.parameters.length > 0) {\n          md += `#### Parameters\\n\\n`;\n          md += `| Name | Type | Required | Description |\\n`;\n          md += `|------|------|----------|-------------|\\n`;\n          for (const p of proc.parameters) {\n            md += `| ${p.name} | ${p.type} | ${p.required ? 'Yes' : 'No'} | ${p.description || ''} |\\n`;\n          }\n          md += `\\n`;\n        }\n\n        md += `#### Response\\n\\n\`\`\`json\\n${JSON.stringify(proc.response.example || {}, null, 2)}\\n\`\`\`\\n\\n`;\n\n        if (proc.errors.length > 0) {\n          md += `#### Possible Errors\\n\\n`;\n          for (const e of proc.errors) {\n            md += `- **${e.code}** (${e.status}): ${e.description}\\n`;\n          }\n          md += `\\n`;\n        }\n      }\n    }\n\n    return md;\n  }\n\n  /**\n   * Generate API documentation\n   */\n  generateDocumentation(): APIDocumentation {\n    return {\n      version: this.version,\n      title: this.title,\n      description: this.description,\n      baseUrl: this.baseUrl,\n      procedures: Array.from(this.procedures.values()),\n      generatedAt: Date.now(),\n    };\n  }\n\n  /**\n   * Convert response schema to OpenAPI\n   */\n  private responseSchemaToOpenAPI(schema: ResponseSchema): Record<string, any> {\n    const result: Record<string, any> = { type: schema.type };\n    if (schema.description) result.description = schema.description;\n    if (schema.example) result.example = schema.example;\n    if (schema.properties) {\n      result.properties = Object.fromEntries(\n        Object.entries(schema.properties).map(([key, value]) => [key, this.responseSchemaToOpenAPI(value)])\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Export documentation\n   */\n  export(format: 'json' | 'html' | 'markdown' | 'openapi'): string {\n    switch (format) {\n      case 'json':\n        return JSON.stringify(this.generateDocumentation(), null, 2);\n      case 'html':\n        return this.generateHTMLDocumentation();\n      case 'markdown':\n        return this.generateMarkdownDocumentation();\n      case 'openapi':\n        return JSON.stringify(this.generateOpenAPISpec(), null, 2);\n      default:\n        return JSON.stringify(this.generateDocumentation(), null, 2);\n    }\n  }\n}\n
