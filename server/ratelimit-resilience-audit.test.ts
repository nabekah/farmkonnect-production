import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { RateLimiter, QuotaManager, ThrottleManager } from './ratelimit';\nimport { CircuitBreaker, RetryHandler, FallbackHandler, Bulkhead, TimeoutHandler } from './resilience';\nimport { AuditLogger, ComplianceManager, DataRetentionManager } from './audit';\n\n/**\n * Rate Limiter Tests\n */\ndescribe('Rate Limiter', () => {\n  let limiter: RateLimiter;\n\n  beforeEach(() => {\n    limiter = new RateLimiter({\n      strategy: 'fixed-window',\n      requestsPerWindow: 5,\n      windowMs: 1000,\n    });\n  });\n\n  it('should allow requests within limit', () => {\n    for (let i = 0; i < 5; i++) {\n      const status = limiter.check('user:1');\n      expect(status.allowed).toBe(true);\n    }\n  });\n\n  it('should block requests exceeding limit', () => {\n    for (let i = 0; i < 5; i++) {\n      limiter.check('user:1');\n    }\n\n    const status = limiter.check('user:1');\n    expect(status.allowed).toBe(false);\n    expect(status.retryAfter).toBeDefined();\n  });\n\n  it('should track remaining requests', () => {\n    const status1 = limiter.check('user:1');\n    expect(status1.remaining).toBe(4);\n\n    const status2 = limiter.check('user:1');\n    expect(status2.remaining).toBe(3);\n  });\n\n  it('should reset after window expires', async () => {\n    limiter.check('user:1');\n    limiter.check('user:1');\n\n    await new Promise((resolve) => setTimeout(resolve, 1100));\n\n    const status = limiter.check('user:1');\n    expect(status.allowed).toBe(true);\n  });\n\n  it('should support sliding window strategy', () => {\n    const slidingLimiter = new RateLimiter({\n      strategy: 'sliding-window',\n      requestsPerWindow: 3,\n      windowMs: 1000,\n    });\n\n    for (let i = 0; i < 3; i++) {\n      expect(slidingLimiter.check('user:1').allowed).toBe(true);\n    }\n\n    expect(slidingLimiter.check('user:1').allowed).toBe(false);\n  });\n\n  it('should support token bucket strategy', () => {\n    const tokenLimiter = new RateLimiter({\n      strategy: 'token-bucket',\n      requestsPerWindow: 10,\n      windowMs: 1000,\n    });\n\n    expect(tokenLimiter.check('user:1').allowed).toBe(true);\n    expect(tokenLimiter.check('user:1').allowed).toBe(true);\n  });\n});\n\n/**\n * Quota Manager Tests\n */\ndescribe('Quota Manager', () => {\n  let quota: QuotaManager;\n\n  beforeEach(() => {\n    quota = new QuotaManager({\n      dailyQuota: 100,\n      monthlyQuota: 1000,\n    });\n  });\n\n  it('should track daily quota', () => {\n    const result = quota.checkQuota('user:1', 50);\n    expect(result.allowed).toBe(true);\n    expect(result.remaining.daily).toBe(50);\n  });\n\n  it('should block when quota exceeded', () => {\n    quota.checkQuota('user:1', 100);\n    const result = quota.checkQuota('user:1', 10);\n    expect(result.allowed).toBe(false);\n  });\n\n  it('should get quota status', () => {\n    quota.checkQuota('user:1', 30);\n    const status = quota.getStatus('user:1');\n    expect(status.daily).toBe(70);\n  });\n\n  it('should reset quota', () => {\n    quota.checkQuota('user:1', 100);\n    quota.resetQuota('user:1');\n    const status = quota.getStatus('user:1');\n    expect(status.daily).toBe(100);\n  });\n});\n\n/**\n * Throttle Manager Tests\n */\ndescribe('Throttle Manager', () => {\n  let throttle: ThrottleManager;\n\n  beforeEach(() => {\n    throttle = new ThrottleManager();\n  });\n\n  it('should apply throttle', () => {\n    throttle.throttle('user:1', 1000);\n    const result = throttle.isThrottled('user:1');\n    expect(result.throttled).toBe(true);\n  });\n\n  it('should remove throttle after duration', async () => {\n    throttle.throttle('user:1', 100);\n    await new Promise((resolve) => setTimeout(resolve, 150));\n    const result = throttle.isThrottled('user:1');\n    expect(result.throttled).toBe(false);\n  });\n\n  it('should manually remove throttle', () => {\n    throttle.throttle('user:1', 10000);\n    throttle.removeThrottle('user:1');\n    const result = throttle.isThrottled('user:1');\n    expect(result.throttled).toBe(false);\n  });\n});\n\n/**\n * Circuit Breaker Tests\n */\ndescribe('Circuit Breaker', () => {\n  let breaker: CircuitBreaker;\n\n  beforeEach(() => {\n    breaker = new CircuitBreaker('test', {\n      failureThreshold: 50,\n      successThreshold: 2,\n      timeout: 1000,\n      volumeThreshold: 5,\n    });\n  });\n\n  it('should execute successful function', async () => {\n    const fn = vi.fn(async () => 'success');\n    const result = await breaker.execute(fn);\n    expect(result).toBe('success');\n    expect(fn).toHaveBeenCalled();\n  });\n\n  it('should open circuit on failures', async () => {\n    const fn = vi.fn(async () => {\n      throw new Error('Failed');\n    });\n\n    for (let i = 0; i < 5; i++) {\n      try {\n        await breaker.execute(fn);\n      } catch (e) {\n        // Expected\n      }\n    }\n\n    expect(breaker.getState()).toBe('open');\n  });\n\n  it('should transition to half-open after timeout', async () => {\n    const fn = vi.fn(async () => {\n      throw new Error('Failed');\n    });\n\n    for (let i = 0; i < 5; i++) {\n      try {\n        await breaker.execute(fn);\n      } catch (e) {\n        // Expected\n      }\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 1100));\n\n    const successFn = vi.fn(async () => 'success');\n    await breaker.execute(successFn);\n\n    expect(breaker.getState()).toBe('half-open');\n  });\n\n  it('should get circuit stats', () => {\n    const stats = breaker.getStats();\n    expect(stats.state).toBe('closed');\n    expect(stats.failureCount).toBe(0);\n  });\n});\n\n/**\n * Retry Handler Tests\n */\ndescribe('Retry Handler', () => {\n  let retry: RetryHandler;\n\n  beforeEach(() => {\n    retry = new RetryHandler({\n      maxRetries: 3,\n      strategy: 'exponential',\n      initialDelay: 10,\n      maxDelay: 100,\n    });\n  });\n\n  it('should succeed on first attempt', async () => {\n    const fn = vi.fn(async () => 'success');\n    const result = await retry.execute(fn);\n    expect(result).toBe('success');\n    expect(fn).toHaveBeenCalledTimes(1);\n  });\n\n  it('should retry on failure', async () => {\n    let attempts = 0;\n    const fn = vi.fn(async () => {\n      attempts++;\n      if (attempts < 2) throw new Error('Failed');\n      return 'success';\n    });\n\n    const result = await retry.execute(fn);\n    expect(result).toBe('success');\n    expect(fn).toHaveBeenCalledTimes(2);\n  });\n\n  it('should fail after max retries', async () => {\n    const fn = vi.fn(async () => {\n      throw new Error('Always fails');\n    });\n\n    await expect(retry.execute(fn)).rejects.toThrow();\n    expect(fn).toHaveBeenCalledTimes(4); // 1 initial + 3 retries\n  });\n\n  it('should support linear strategy', async () => {\n    const linearRetry = new RetryHandler({\n      maxRetries: 2,\n      strategy: 'linear',\n      initialDelay: 10,\n      maxDelay: 100,\n    });\n\n    let attempts = 0;\n    const fn = vi.fn(async () => {\n      attempts++;\n      if (attempts < 3) throw new Error('Failed');\n      return 'success';\n    });\n\n    const result = await linearRetry.execute(fn);\n    expect(result).toBe('success');\n  });\n});\n\n/**\n * Fallback Handler Tests\n */\ndescribe('Fallback Handler', () => {\n  let fallback: FallbackHandler;\n\n  beforeEach(() => {\n    fallback = new FallbackHandler({\n      fallback: async () => 'default',\n      timeout: 1000,\n    });\n  });\n\n  it('should execute primary function', async () => {\n    const fn = vi.fn(async () => 'primary');\n    const result = await fallback.execute(fn);\n    expect(result).toBe('primary');\n  });\n\n  it('should use fallback on error', async () => {\n    const fn = vi.fn(async () => {\n      throw new Error('Failed');\n    });\n\n    const result = await fallback.execute(fn);\n    expect(result).toBe('default');\n  });\n\n  it('should use named fallback', async () => {\n    fallback.registerFallback('custom', async () => 'custom-fallback');\n\n    const fn = vi.fn(async () => {\n      throw new Error('Failed');\n    });\n\n    const result = await fallback.execute(fn, 'custom');\n    expect(result).toBe('custom-fallback');\n  });\n});\n\n/**\n * Bulkhead Tests\n */\ndescribe('Bulkhead', () => {\n  let bulkhead: Bulkhead;\n\n  beforeEach(() => {\n    bulkhead = new Bulkhead(2);\n  });\n\n  it('should execute concurrent requests', async () => {\n    const fn = vi.fn(async () => 'success');\n\n    const results = await Promise.all([\n      bulkhead.execute('api', fn),\n      bulkhead.execute('api', fn),\n    ]);\n\n    expect(results).toEqual(['success', 'success']);\n  });\n\n  it('should queue excess requests', async () => {\n    const fn = vi.fn(async () => {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      return 'success';\n    });\n\n    const results = await Promise.all([\n      bulkhead.execute('api', fn),\n      bulkhead.execute('api', fn),\n      bulkhead.execute('api', fn),\n    ]);\n\n    expect(results).toEqual(['success', 'success', 'success']);\n  });\n\n  it('should get stats', async () => {\n    const fn = vi.fn(async () => 'success');\n    await bulkhead.execute('api', fn);\n\n    const stats = bulkhead.getStats();\n    expect(stats.api).toBeDefined();\n  });\n});\n\n/**\n * Audit Logger Tests\n */\ndescribe('Audit Logger', () => {\n  let logger: AuditLogger;\n\n  beforeEach(() => {\n    logger = new AuditLogger();\n  });\n\n  afterEach(() => {\n    logger.stop();\n  });\n\n  it('should log audit event', () => {\n    const log = logger.log({\n      userId: 1,\n      action: 'CREATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    expect(log.id).toBeDefined();\n    expect(log.timestamp).toBeDefined();\n    expect(log.action).toBe('CREATE');\n  });\n\n  it('should get logs by filter', () => {\n    logger.log({\n      userId: 1,\n      action: 'CREATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    const logs = logger.getLogs({ userId: 1 });\n    expect(logs.length).toBe(1);\n  });\n\n  it('should get user activity', () => {\n    logger.log({\n      userId: 1,\n      action: 'CREATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    logger.log({\n      userId: 1,\n      action: 'UPDATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    const activity = logger.getUserActivity(1);\n    expect(activity.totalActions).toBe(2);\n  });\n\n  it('should export logs as JSON', () => {\n    logger.log({\n      userId: 1,\n      action: 'CREATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    const json = logger.exportLogs('json');\n    expect(json).toContain('CREATE');\n  });\n\n  it('should export logs as CSV', () => {\n    logger.log({\n      userId: 1,\n      action: 'CREATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    const csv = logger.exportLogs('csv');\n    expect(csv).toContain('CREATE');\n    expect(csv).toContain(',');\n  });\n});\n\n/**\n * Compliance Manager Tests\n */\ndescribe('Compliance Manager', () => {\n  let logger: AuditLogger;\n  let compliance: ComplianceManager;\n\n  beforeEach(() => {\n    logger = new AuditLogger();\n    compliance = new ComplianceManager(logger);\n  });\n\n  afterEach(() => {\n    logger.stop();\n  });\n\n  it('should generate compliance report', () => {\n    logger.log({\n      userId: 1,\n      action: 'CREATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    const report = compliance.generateReport('access');\n    expect(report.id).toBeDefined();\n    expect(report.totalEvents).toBeGreaterThan(0);\n  });\n\n  it('should register custom policy', () => {\n    compliance.registerPolicy('test-policy', (logs) => logs.length < 100, 'high');\n\n    const report = compliance.generateReport('access');\n    expect(report.findings).toBeDefined();\n  });\n});\n\n/**\n * Data Retention Manager Tests\n */\ndescribe('Data Retention Manager', () => {\n  let logger: AuditLogger;\n  let retention: DataRetentionManager;\n\n  beforeEach(() => {\n    logger = new AuditLogger();\n    retention = new DataRetentionManager(logger);\n  });\n\n  afterEach(() => {\n    logger.stop();\n  });\n\n  it('should set retention policy', () => {\n    retention.setPolicy('farm', 90, 30);\n    const status = retention.getRetentionStatus('farm', Date.now());\n    expect(status.status).toBe('active');\n  });\n\n  it('should check if data should be archived', () => {\n    retention.setPolicy('farm', 90, 30);\n    const createdAt = Date.now() - 31 * 24 * 60 * 60 * 1000; // 31 days ago\n    expect(retention.shouldArchive('farm', createdAt)).toBe(true);\n  });\n\n  it('should check if data should be deleted', () => {\n    retention.setPolicy('farm', 90, 30);\n    const createdAt = Date.now() - 91 * 24 * 60 * 60 * 1000; // 91 days ago\n    expect(retention.shouldDelete('farm', createdAt)).toBe(true);\n  });\n});\n\n/**\n * Integration Tests\n */\ndescribe('Integration Tests', () => {\n  it('should work with rate limiting and throttling', () => {\n    const limiter = new RateLimiter({\n      strategy: 'fixed-window',\n      requestsPerWindow: 5,\n      windowMs: 1000,\n    });\n\n    const throttle = new ThrottleManager();\n\n    for (let i = 0; i < 5; i++) {\n      limiter.check('user:1');\n    }\n\n    const status = limiter.check('user:1');\n    if (!status.allowed) {\n      throttle.throttle('user:1', 1000);\n    }\n\n    expect(throttle.isThrottled('user:1').throttled).toBe(true);\n  });\n\n  it('should work with circuit breaker and retry', async () => {\n    const breaker = new CircuitBreaker('api', {\n      failureThreshold: 50,\n      successThreshold: 2,\n      timeout: 1000,\n      volumeThreshold: 2,\n    });\n\n    const retry = new RetryHandler({\n      maxRetries: 2,\n      strategy: 'exponential',\n      initialDelay: 10,\n      maxDelay: 100,\n    });\n\n    let attempts = 0;\n    const fn = async () => {\n      attempts++;\n      if (attempts < 2) throw new Error('Failed');\n      return 'success';\n    };\n\n    const result = await retry.execute(() => breaker.execute(fn));\n    expect(result).toBe('success');\n  });\n\n  it('should work with audit and compliance', () => {\n    const logger = new AuditLogger();\n    const compliance = new ComplianceManager(logger);\n\n    logger.log({\n      userId: 1,\n      action: 'CREATE',\n      resource: 'farm',\n      resourceId: 'farm:1',\n      status: 'success',\n    });\n\n    const report = compliance.generateReport('access');\n    expect(report.totalEvents).toBeGreaterThan(0);\n\n    logger.stop();\n  });\n});\n
