import { EventEmitter } from 'events';\n\nexport type SoilType = 'sandy' | 'loamy' | 'clay' | 'peaty' | 'chalky';\nexport type NutrientLevel = 'deficient' | 'low' | 'adequate' | 'high' | 'excessive';\n\nexport interface SoilTest {\n  id: string;\n  farmId: string;\n  fieldId: string;\n  date: number;\n  depth: number; // cm\n  nitrogen: number; // ppm\n  phosphorus: number; // ppm\n  potassium: number; // ppm\n  calcium: number; // ppm\n  magnesium: number; // ppm\n  sulfur: number; // ppm\n  pH: number;\n  organicMatter: number; // percentage\n  cationExchangeCapacity: number; // meq/100g\n  soilType: SoilType;\n  texture: {\n    sand: number; // percentage\n    silt: number; // percentage\n    clay: number; // percentage\n  };\n  micronutrients: {\n    iron: number; // ppm\n    manganese: number; // ppm\n    zinc: number; // ppm\n    copper: number; // ppm\n    boron: number; // ppm\n  };\n  notes: string;\n}\n\nexport interface NutrientRecommendation {\n  id: string;\n  fieldId: string;\n  testId: string;\n  nitrogen: {\n    current: number;\n    recommended: number;\n    amendment: string;\n    amount: number; // kg/hectare\n    cost: number;\n  };\n  phosphorus: {\n    current: number;\n    recommended: number;\n    amendment: string;\n    amount: number;\n    cost: number;\n  };\n  potassium: {\n    current: number;\n    recommended: number;\n    amendment: string;\n    amount: number;\n    cost: number;\n  };\n  pH: {\n    current: number;\n    recommended: number;\n    amendment: string;\n    amount: number;\n    cost: number;\n  };\n  totalCost: number;\n  generatedAt: number;\n}\n\nexport interface SoilAmendment {\n  id: string;\n  farmId: string;\n  fieldId: string;\n  date: number;\n  type: string; // e.g., 'Compost', 'Lime', 'Nitrogen Fertilizer'\n  amount: number; // kg\n  cost: number;\n  appliedTo: string; // crop name\n  expectedBenefit: string;\n  notes: string;\n}\n\nexport interface SoilHealthScore {\n  id: string;\n  fieldId: string;\n  testId: string;\n  overallScore: number; // 0-100\n  nutrientScore: number;\n  structureScore: number;\n  biologyScore: number; // based on organic matter\n  pHScore: number;\n  recommendations: string[];\n  generatedAt: number;\n}\n\nexport interface SoilTrend {\n  fieldId: string;\n  nutrient: string;\n  values: Array<{ date: number; value: number }>;\n  trend: 'improving' | 'declining' | 'stable';\n  trendPercentage: number; // percentage change\n}\n\n/**\n * Soil Health Monitoring System\n */\nexport class SoilHealthManager extends EventEmitter {\n  private tests: Map<string, SoilTest> = new Map();\n  private recommendations: Map<string, NutrientRecommendation> = new Map();\n  private amendments: Map<string, SoilAmendment> = new Map();\n  private healthScores: Map<string, SoilHealthScore> = new Map();\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Record soil test\n   */\n  recordSoilTest(\n    farmId: string,\n    fieldId: string,\n    depth: number,\n    nitrogen: number,\n    phosphorus: number,\n    potassium: number,\n    calcium: number,\n    magnesium: number,\n    sulfur: number,\n    pH: number,\n    organicMatter: number,\n    cationExchangeCapacity: number,\n    soilType: SoilType,\n    texture: { sand: number; silt: number; clay: number },\n    micronutrients: {\n      iron: number;\n      manganese: number;\n      zinc: number;\n      copper: number;\n      boron: number;\n    },\n    notes: string = ''\n  ): SoilTest {\n    const testId = `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const test: SoilTest = {\n      id: testId,\n      farmId,\n      fieldId,\n      date: Date.now(),\n      depth,\n      nitrogen,\n      phosphorus,\n      potassium,\n      calcium,\n      magnesium,\n      sulfur,\n      pH,\n      organicMatter,\n      cationExchangeCapacity,\n      soilType,\n      texture,\n      micronutrients,\n      notes,\n    };\n\n    this.tests.set(testId, test);\n    this.emit('test:recorded', { testId, farmId, fieldId });\n    return test;\n  }\n\n  /**\n   * Get soil test\n   */\n  getSoilTest(testId: string): SoilTest | null {\n    return this.tests.get(testId) || null;\n  }\n\n  /**\n   * Get latest soil test for field\n   */\n  getLatestSoilTest(fieldId: string): SoilTest | null {\n    const fieldTests = Array.from(this.tests.values()).filter((t) => t.fieldId === fieldId);\n    if (fieldTests.length === 0) return null;\n    return fieldTests.sort((a, b) => b.date - a.date)[0];\n  }\n\n  /**\n   * Get soil test history\n   */\n  getSoilTestHistory(fieldId: string): SoilTest[] {\n    return Array.from(this.tests.values())\n      .filter((t) => t.fieldId === fieldId)\n      .sort((a, b) => b.date - a.date);\n  }\n\n  /**\n   * Generate nutrient recommendations\n   */\n  generateNutrientRecommendations(testId: string): NutrientRecommendation {\n    const test = this.getSoilTest(testId);\n    if (!test) throw new Error('Soil test not found');\n\n    const recId = `rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Target values for optimal crop production\n    const targets = {\n      nitrogen: 150,\n      phosphorus: 25,\n      potassium: 150,\n      pH: 6.5,\n    };\n\n    const recommendation: NutrientRecommendation = {\n      id: recId,\n      fieldId: test.fieldId,\n      testId,\n      nitrogen: {\n        current: test.nitrogen,\n        recommended: targets.nitrogen,\n        amendment: test.nitrogen < 100 ? 'Urea Fertilizer' : 'None',\n        amount: Math.max(0, (targets.nitrogen - test.nitrogen) * 0.5),\n        cost: Math.max(0, (targets.nitrogen - test.nitrogen) * 0.5) * 0.8,\n      },\n      phosphorus: {\n        current: test.phosphorus,\n        recommended: targets.phosphorus,\n        amendment: test.phosphorus < 15 ? 'Phosphate Rock' : 'None',\n        amount: Math.max(0, (targets.phosphorus - test.phosphorus) * 0.5),\n        cost: Math.max(0, (targets.phosphorus - test.phosphorus) * 0.5) * 1.2,\n      },\n      potassium: {\n        current: test.potassium,\n        recommended: targets.potassium,\n        amendment: test.potassium < 100 ? 'Potassium Chloride' : 'None',\n        amount: Math.max(0, (targets.potassium - test.potassium) * 0.5),\n        cost: Math.max(0, (targets.potassium - test.potassium) * 0.5) * 0.9,\n      },\n      pH: {\n        current: test.pH,\n        recommended: targets.pH,\n        amendment: test.pH < 6 ? 'Lime' : test.pH > 7 ? 'Sulfur' : 'None',\n        amount: Math.abs((targets.pH - test.pH) * 500),\n        cost: Math.abs((targets.pH - test.pH) * 500) * 0.5,\n      },\n      totalCost: 0,\n      generatedAt: Date.now(),\n    };\n\n    recommendation.totalCost =\n      recommendation.nitrogen.cost +\n      recommendation.phosphorus.cost +\n      recommendation.potassium.cost +\n      recommendation.pH.cost;\n\n    this.recommendations.set(recId, recommendation);\n    this.emit('recommendation:generated', { recId, fieldId: test.fieldId });\n    return recommendation;\n  }\n\n  /**\n   * Get recommendation\n   */\n  getRecommendation(recId: string): NutrientRecommendation | null {\n    return this.recommendations.get(recId) || null;\n  }\n\n  /**\n   * Record soil amendment\n   */\n  recordSoilAmendment(\n    farmId: string,\n    fieldId: string,\n    type: string,\n    amount: number,\n    cost: number,\n    appliedTo: string,\n    expectedBenefit: string,\n    notes: string = ''\n  ): SoilAmendment {\n    const amendmentId = `amendment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const amendment: SoilAmendment = {\n      id: amendmentId,\n      farmId,\n      fieldId,\n      date: Date.now(),\n      type,\n      amount,\n      cost,\n      appliedTo,\n      expectedBenefit,\n      notes,\n    };\n\n    this.amendments.set(amendmentId, amendment);\n    this.emit('amendment:recorded', { amendmentId, fieldId, type });\n    return amendment;\n  }\n\n  /**\n   * Get amendments by field\n   */\n  getAmendmentsByField(fieldId: string): SoilAmendment[] {\n    return Array.from(this.amendments.values())\n      .filter((a) => a.fieldId === fieldId)\n      .sort((a, b) => b.date - a.date);\n  }\n\n  /**\n   * Calculate soil health score\n   */\n  calculateHealthScore(testId: string): SoilHealthScore {\n    const test = this.getSoilTest(testId);\n    if (!test) throw new Error('Soil test not found');\n\n    const scoreId = `score_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Calculate individual scores (0-100)\n    const nutrientScore = this.calculateNutrientScore(test);\n    const structureScore = this.calculateStructureScore(test);\n    const biologyScore = Math.min(100, (test.organicMatter / 5) * 100);\n    const pHScore = this.calculatePHScore(test.pH);\n\n    const overallScore = (nutrientScore + structureScore + biologyScore + pHScore) / 4;\n\n    const recommendations: string[] = [];\n    if (nutrientScore < 60) recommendations.push('Add nitrogen-rich fertilizer');\n    if (test.pH < 6) recommendations.push('Apply lime to raise pH');\n    if (test.pH > 7.5) recommendations.push('Apply sulfur to lower pH');\n    if (biologyScore < 60) recommendations.push('Increase organic matter with compost');\n    if (structureScore < 60) recommendations.push('Improve soil structure with cover crops');\n\n    const score: SoilHealthScore = {\n      id: scoreId,\n      fieldId: test.fieldId,\n      testId,\n      overallScore: Math.round(overallScore),\n      nutrientScore,\n      structureScore,\n      biologyScore,\n      pHScore,\n      recommendations,\n      generatedAt: Date.now(),\n    };\n\n    this.healthScores.set(scoreId, score);\n    this.emit('score:calculated', { scoreId, fieldId: test.fieldId, overallScore });\n    return score;\n  }\n\n  /**\n   * Calculate nutrient score\n   */\n  private calculateNutrientScore(test: SoilTest): number {\n    const nScore = Math.min(100, (test.nitrogen / 200) * 100);\n    const pScore = Math.min(100, (test.phosphorus / 30) * 100);\n    const kScore = Math.min(100, (test.potassium / 200) * 100);\n    return (nScore + pScore + kScore) / 3;\n  }\n\n  /**\n   * Calculate structure score\n   */\n  private calculateStructureScore(test: SoilTest): number {\n    const textureBalance = 100 - Math.abs(test.texture.sand - 40) / 0.6;\n    const cecScore = Math.min(100, (test.cationExchangeCapacity / 20) * 100);\n    return (textureBalance + cecScore) / 2;\n  }\n\n  /**\n   * Calculate pH score\n   */\n  private calculatePHScore(pH: number): number {\n    const optimalPH = 6.5;\n    const deviation = Math.abs(pH - optimalPH);\n    return Math.max(0, 100 - deviation * 10);\n  }\n\n  /**\n   * Get health score\n   */\n  getHealthScore(scoreId: string): SoilHealthScore | null {\n    return this.healthScores.get(scoreId) || null;\n  }\n\n  /**\n   * Get soil trend\n   */\n  getSoilTrend(fieldId: string, nutrient: string): SoilTrend {\n    const tests = this.getSoilTestHistory(fieldId);\n    const values: Array<{ date: number; value: number }> = [];\n\n    for (const test of tests) {\n      let value = 0;\n      if (nutrient === 'nitrogen') value = test.nitrogen;\n      else if (nutrient === 'phosphorus') value = test.phosphorus;\n      else if (nutrient === 'potassium') value = test.potassium;\n      else if (nutrient === 'pH') value = test.pH;\n      else if (nutrient === 'organicMatter') value = test.organicMatter;\n\n      values.push({ date: test.date, value });\n    }\n\n    values.sort((a, b) => a.date - b.date);\n\n    let trend: 'improving' | 'declining' | 'stable' = 'stable';\n    let trendPercentage = 0;\n\n    if (values.length >= 2) {\n      const firstValue = values[0].value;\n      const lastValue = values[values.length - 1].value;\n      trendPercentage = ((lastValue - firstValue) / firstValue) * 100;\n\n      if (trendPercentage > 5) trend = 'improving';\n      else if (trendPercentage < -5) trend = 'declining';\n    }\n\n    return {\n      fieldId,\n      nutrient,\n      values,\n      trend,\n      trendPercentage,\n    };\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): {\n    totalTests: number;\n    totalAmendments: number;\n    totalRecommendations: number;\n    averageHealthScore: number;\n  } {\n    const scores = Array.from(this.healthScores.values());\n    const avgScore = scores.length > 0 ? scores.reduce((sum, s) => sum + s.overallScore, 0) / scores.length : 0;\n\n    return {\n      totalTests: this.tests.size,\n      totalAmendments: this.amendments.size,\n      totalRecommendations: this.recommendations.size,\n      averageHealthScore: Math.round(avgScore),\n    };\n  }\n}\n
