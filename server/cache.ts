import { EventEmitter } from 'events';\n\nexport interface CacheEntry<T> {\n  /**\n   * Cached value\n   */\n  value: T;\n  /**\n   * Expiry time\n   */\n  expiresAt: number;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Hit count\n   */\n  hits: number;\n}\n\nexport interface CacheStats {\n  /**\n   * Total entries\n   */\n  total: number;\n  /**\n   * Total hits\n   */\n  hits: number;\n  /**\n   * Total misses\n   */\n  misses: number;\n  /**\n   * Hit rate\n   */\n  hitRate: number;\n  /**\n   * Memory usage (approximate)\n   */\n  memoryUsage: number;\n}\n\n/**\n * In-Memory Cache Manager\n */\nexport class CacheManager extends EventEmitter {\n  private cache: Map<string, CacheEntry<any>> = new Map();\n  private hits: number = 0;\n  private misses: number = 0;\n  private maxSize: number = 1000;\n  private defaultTTL: number = 3600000; // 1 hour\n  private cleanupInterval: NodeJS.Timeout | null = null;\n\n  constructor(maxSize: number = 1000, defaultTTL: number = 3600000) {\n    super();\n    this.maxSize = maxSize;\n    this.defaultTTL = defaultTTL;\n    this.startCleanup();\n  }\n\n  /**\n   * Set cache entry\n   */\n  set<T>(key: string, value: T, ttl: number = this.defaultTTL): void {\n    // Evict oldest entry if cache is full\n    if (this.cache.size >= this.maxSize) {\n      const oldestKey = Array.from(this.cache.entries())\n        .sort((a, b) => a[1].createdAt - b[1].createdAt)[0][0];\n      this.cache.delete(oldestKey);\n    }\n\n    this.cache.set(key, {\n      value,\n      expiresAt: Date.now() + ttl,\n      createdAt: Date.now(),\n      hits: 0,\n    });\n\n    this.emit('cache:set', { key, ttl });\n  }\n\n  /**\n   * Get cache entry\n   */\n  get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.misses++;\n      this.emit('cache:miss', { key });\n      return null;\n    }\n\n    if (entry.expiresAt < Date.now()) {\n      this.cache.delete(key);\n      this.misses++;\n      this.emit('cache:expired', { key });\n      return null;\n    }\n\n    entry.hits++;\n    this.hits++;\n    this.emit('cache:hit', { key, hits: entry.hits });\n\n    return entry.value as T;\n  }\n\n  /**\n   * Get or set\n   */\n  async getOrSet<T>(\n    key: string,\n    fn: () => Promise<T>,\n    ttl: number = this.defaultTTL\n  ): Promise<T> {\n    const cached = this.get<T>(key);\n    if (cached !== null) {\n      return cached;\n    }\n\n    const value = await fn();\n    this.set(key, value, ttl);\n    return value;\n  }\n\n  /**\n   * Delete entry\n   */\n  delete(key: string): boolean {\n    const deleted = this.cache.delete(key);\n    if (deleted) {\n      this.emit('cache:deleted', { key });\n    }\n    return deleted;\n  }\n\n  /**\n   * Delete by pattern\n   */\n  deleteByPattern(pattern: RegExp): number {\n    let deleted = 0;\n    for (const key of this.cache.keys()) {\n      if (pattern.test(key)) {\n        this.cache.delete(key);\n        deleted++;\n      }\n    }\n    this.emit('cache:pattern_deleted', { pattern: pattern.source, deleted });\n    return deleted;\n  }\n\n  /**\n   * Clear all\n   */\n  clear(): void {\n    this.cache.clear();\n    this.emit('cache:cleared');\n  }\n\n  /**\n   * Has key\n   */\n  has(key: string): boolean {\n    return this.cache.has(key) && this.cache.get(key)!.expiresAt > Date.now();\n  }\n\n  /**\n   * Get stats\n   */\n  getStats(): CacheStats {\n    let memoryUsage = 0;\n    for (const entry of this.cache.values()) {\n      memoryUsage += JSON.stringify(entry.value).length;\n    }\n\n    const total = this.hits + this.misses;\n    const hitRate = total > 0 ? this.hits / total : 0;\n\n    return {\n      total: this.cache.size,\n      hits: this.hits,\n      misses: this.misses,\n      hitRate,\n      memoryUsage,\n    };\n  }\n\n  /**\n   * Start cleanup\n   */\n  private startCleanup(): void {\n    this.cleanupInterval = setInterval(() => {\n      const now = Date.now();\n      let expired = 0;\n\n      for (const [key, entry] of this.cache) {\n        if (entry.expiresAt < now) {\n          this.cache.delete(key);\n          expired++;\n        }\n      }\n\n      if (expired > 0) {\n        this.emit('cache:cleanup', { expired });\n      }\n    }, 60000); // Run every minute\n  }\n\n  /**\n   * Stop cleanup\n   */\n  stop(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n}\n\n/**\n * Distributed Cache Manager (Redis-like interface)\n */\nexport class DistributedCacheManager extends EventEmitter {\n  private localCache: CacheManager;\n  private remoteStore: Map<string, any> = new Map(); // Simulates Redis\n  private syncInterval: NodeJS.Timeout | null = null;\n  private useRemote: boolean = false;\n\n  constructor(maxSize: number = 1000, defaultTTL: number = 3600000) {\n    super();\n    this.localCache = new CacheManager(maxSize, defaultTTL);\n  }\n\n  /**\n   * Enable remote store\n   */\n  enableRemoteStore(): void {\n    this.useRemote = true;\n    this.startSync();\n  }\n\n  /**\n   * Disable remote store\n   */\n  disableRemoteStore(): void {\n    this.useRemote = false;\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n    }\n  }\n\n  /**\n   * Set cache entry\n   */\n  async set<T>(key: string, value: T, ttl: number = 3600000): Promise<void> {\n    this.localCache.set(key, value, ttl);\n\n    if (this.useRemote) {\n      this.remoteStore.set(key, { value, expiresAt: Date.now() + ttl });\n      this.emit('cache:synced', { key, remote: true });\n    }\n  }\n\n  /**\n   * Get cache entry\n   */\n  async get<T>(key: string): Promise<T | null> {\n    // Try local cache first\n    const local = this.localCache.get<T>(key);\n    if (local !== null) {\n      return local;\n    }\n\n    // Try remote store\n    if (this.useRemote) {\n      const remote = this.remoteStore.get(key);\n      if (remote && remote.expiresAt > Date.now()) {\n        this.localCache.set(key, remote.value);\n        return remote.value as T;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Delete entry\n   */\n  async delete(key: string): Promise<void> {\n    this.localCache.delete(key);\n    if (this.useRemote) {\n      this.remoteStore.delete(key);\n    }\n  }\n\n  /**\n   * Delete by pattern\n   */\n  async deleteByPattern(pattern: RegExp): Promise<number> {\n    const deleted = this.localCache.deleteByPattern(pattern);\n\n    if (this.useRemote) {\n      for (const key of this.remoteStore.keys()) {\n        if (pattern.test(key)) {\n          this.remoteStore.delete(key);\n        }\n      }\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Clear all\n   */\n  async clear(): Promise<void> {\n    this.localCache.clear();\n    if (this.useRemote) {\n      this.remoteStore.clear();\n    }\n  }\n\n  /**\n   * Start sync\n   */\n  private startSync(): void {\n    this.syncInterval = setInterval(() => {\n      const now = Date.now();\n      for (const [key, entry] of this.remoteStore) {\n        if (entry.expiresAt < now) {\n          this.remoteStore.delete(key);\n        }\n      }\n    }, 60000);\n  }\n\n  /**\n   * Get stats\n   */\n  getStats(): CacheStats & { remoteSize: number } {\n    const localStats = this.localCache.getStats();\n    return {\n      ...localStats,\n      remoteSize: this.remoteStore.size,\n    };\n  }\n\n  /**\n   * Stop\n   */\n  stop(): void {\n    this.localCache.stop();\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n    }\n  }\n}\n\n/**\n * Cache Key Builder\n */\nexport class CacheKeyBuilder {\n  private prefix: string;\n\n  constructor(prefix: string = 'cache') {\n    this.prefix = prefix;\n  }\n\n  /**\n   * Build key\n   */\n  build(...parts: (string | number)[]): string {\n    return [this.prefix, ...parts].join(':');\n  }\n\n  /**\n   * Build user key\n   */\n  user(userId: string | number, ...parts: (string | number)[]): string {\n    return this.build('user', userId, ...parts);\n  }\n\n  /**\n   * Build farm key\n   */\n  farm(farmId: string | number, ...parts: (string | number)[]): string {\n    return this.build('farm', farmId, ...parts);\n  }\n\n  /**\n   * Build query key\n   */\n  query(query: string, ...params: any[]): string {\n    const hash = require('crypto')\n      .createHash('md5')\n      .update(query + JSON.stringify(params))\n      .digest('hex');\n    return this.build('query', hash);\n  }\n\n  /**\n   * Build pattern\n   */\n  pattern(...parts: (string | '*')[]): RegExp {\n    const pattern = [this.prefix, ...parts]\n      .join(':')\n      .replace(/\\*/g, '.*');\n    return new RegExp(`^${pattern}$`);\n  }\n}\n\n/**\n * Cache Invalidation Manager\n */\nexport class CacheInvalidationManager extends EventEmitter {\n  private cache: DistributedCacheManager;\n  private keyBuilder: CacheKeyBuilder;\n  private invalidationRules: Map<string, RegExp[]> = new Map();\n\n  constructor(cache: DistributedCacheManager, keyBuilder: CacheKeyBuilder) {\n    super();\n    this.cache = cache;\n    this.keyBuilder = keyBuilder;\n  }\n\n  /**\n   * Register invalidation rule\n   */\n  registerRule(trigger: string, patterns: RegExp[]): void {\n    this.invalidationRules.set(trigger, patterns);\n  }\n\n  /**\n   * Invalidate on event\n   */\n  async invalidate(trigger: string): Promise<number> {\n    const patterns = this.invalidationRules.get(trigger);\n    if (!patterns) return 0;\n\n    let invalidated = 0;\n    for (const pattern of patterns) {\n      invalidated += await this.cache.deleteByPattern(pattern);\n    }\n\n    this.emit('cache:invalidated', { trigger, invalidated });\n    return invalidated;\n  }\n\n  /**\n   * Invalidate user cache\n   */\n  async invalidateUser(userId: string | number): Promise<number> {\n    const pattern = this.keyBuilder.pattern('user', userId, '*');\n    return await this.cache.deleteByPattern(pattern);\n  }\n\n  /**\n   * Invalidate farm cache\n   */\n  async invalidateFarm(farmId: string | number): Promise<number> {\n    const pattern = this.keyBuilder.pattern('farm', farmId, '*');\n    return await this.cache.deleteByPattern(pattern);\n  }\n}\n
