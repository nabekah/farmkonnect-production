import { EventEmitter } from 'events';\n\nexport type CircuitState = 'closed' | 'open' | 'half-open';\nexport type RetryStrategy = 'exponential' | 'linear' | 'fibonacci';\n\nexport interface CircuitBreakerConfig {\n  /**\n   * Failure threshold\n   */\n  failureThreshold: number;\n  /**\n   * Success threshold for half-open\n   */\n  successThreshold: number;\n  /**\n   * Timeout in milliseconds\n   */\n  timeout: number;\n  /**\n   * Volume threshold\n   */\n  volumeThreshold: number;\n}\n\nexport interface RetryConfig {\n  /**\n   * Maximum retries\n   */\n  maxRetries: number;\n  /**\n   * Retry strategy\n   */\n  strategy: RetryStrategy;\n  /**\n   * Initial delay in milliseconds\n   */\n  initialDelay: number;\n  /**\n   * Max delay in milliseconds\n   */\n  maxDelay: number;\n  /**\n   * Jitter factor (0-1)\n   */\n  jitter?: number;\n}\n\nexport interface FallbackConfig {\n  /**\n   * Fallback function\n   */\n  fallback: (error: Error) => Promise<any>;\n  /**\n   * Timeout in milliseconds\n   */\n  timeout: number;\n}\n\n/**\n * Circuit Breaker Pattern\n */\nexport class CircuitBreaker extends EventEmitter {\n  private state: CircuitState = 'closed';\n  private failureCount: number = 0;\n  private successCount: number = 0;\n  private lastFailureTime: number = 0;\n  private requestCount: number = 0;\n  private config: CircuitBreakerConfig;\n  private name: string;\n\n  constructor(name: string, config: CircuitBreakerConfig) {\n    super();\n    this.name = name;\n    this.config = config;\n  }\n\n  /**\n   * Execute function with circuit breaker\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === 'open') {\n      if (Date.now() - this.lastFailureTime > this.config.timeout) {\n        this.state = 'half-open';\n        this.successCount = 0;\n        this.emit('circuit:half-open', { name: this.name });\n      } else {\n        throw new Error(`Circuit breaker ${this.name} is OPEN`);\n      }\n    }\n\n    this.requestCount++;\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  /**\n   * Handle success\n   */\n  private onSuccess(): void {\n    this.failureCount = 0;\n\n    if (this.state === 'half-open') {\n      this.successCount++;\n\n      if (this.successCount >= this.config.successThreshold) {\n        this.state = 'closed';\n        this.successCount = 0;\n        this.emit('circuit:closed', { name: this.name });\n      }\n    }\n  }\n\n  /**\n   * Handle failure\n   */\n  private onFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n\n    if (this.state === 'half-open') {\n      this.state = 'open';\n      this.emit('circuit:open', { name: this.name, reason: 'failed in half-open' });\n    } else if (this.requestCount >= this.config.volumeThreshold) {\n      const failureRate = this.failureCount / this.requestCount;\n      const threshold = this.config.failureThreshold / 100;\n\n      if (failureRate >= threshold) {\n        this.state = 'open';\n        this.emit('circuit:open', { name: this.name, reason: 'failure threshold exceeded' });\n      }\n    }\n  }\n\n  /**\n   * Get state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  /**\n   * Get stats\n   */\n  getStats(): {\n    state: CircuitState;\n    failureCount: number;\n    successCount: number;\n    requestCount: number;\n    failureRate: number;\n  } {\n    return {\n      state: this.state,\n      failureCount: this.failureCount,\n      successCount: this.successCount,\n      requestCount: this.requestCount,\n      failureRate: this.requestCount > 0 ? this.failureCount / this.requestCount : 0,\n    };\n  }\n\n  /**\n   * Reset circuit breaker\n   */\n  reset(): void {\n    this.state = 'closed';\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.requestCount = 0;\n    this.lastFailureTime = 0;\n    this.emit('circuit:reset', { name: this.name });\n  }\n}\n\n/**\n * Retry Handler with exponential backoff\n */\nexport class RetryHandler extends EventEmitter {\n  private config: RetryConfig;\n\n  constructor(config: RetryConfig) {\n    super();\n    this.config = config;\n  }\n\n  /**\n   * Execute with retry\n   */\n  async execute<T>(fn: () => Promise<T>, context?: string): Promise<T> {\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        const result = await fn();\n        if (attempt > 0) {\n          this.emit('retry:success', { attempt, context });\n        }\n        return result;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < this.config.maxRetries) {\n          const delay = this.calculateDelay(attempt);\n          this.emit('retry:attempt', { attempt, delay, error: lastError.message, context });\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    this.emit('retry:failed', { attempts: this.config.maxRetries + 1, error: lastError?.message, context });\n    throw lastError || new Error('Max retries exceeded');\n  }\n\n  /**\n   * Calculate delay based on strategy\n   */\n  private calculateDelay(attempt: number): number {\n    let delay: number;\n\n    switch (this.config.strategy) {\n      case 'exponential':\n        delay = this.config.initialDelay * Math.pow(2, attempt);\n        break;\n      case 'linear':\n        delay = this.config.initialDelay * (attempt + 1);\n        break;\n      case 'fibonacci':\n        delay = this.config.initialDelay * this.fibonacci(attempt + 1);\n        break;\n      default:\n        delay = this.config.initialDelay;\n    }\n\n    // Apply jitter\n    if (this.config.jitter) {\n      const jitterAmount = delay * this.config.jitter;\n      delay += Math.random() * jitterAmount - jitterAmount / 2;\n    }\n\n    // Cap at max delay\n    return Math.min(delay, this.config.maxDelay);\n  }\n\n  /**\n   * Fibonacci number\n   */\n  private fibonacci(n: number): number {\n    if (n <= 1) return 1;\n    let a = 1,\n      b = 1;\n    for (let i = 2; i < n; i++) {\n      [a, b] = [b, a + b];\n    }\n    return b;\n  }\n\n  /**\n   * Sleep\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Fallback Handler\n */\nexport class FallbackHandler extends EventEmitter {\n  private fallbacks: Map<string, (error: Error) => Promise<any>> = new Map();\n  private config: FallbackConfig;\n\n  constructor(config: FallbackConfig) {\n    super();\n    this.config = config;\n  }\n\n  /**\n   * Register fallback\n   */\n  registerFallback(name: string, fallback: (error: Error) => Promise<any>): void {\n    this.fallbacks.set(name, fallback);\n  }\n\n  /**\n   * Execute with fallback\n   */\n  async execute<T>(fn: () => Promise<T>, fallbackName?: string): Promise<T> {\n    try {\n      return await fn();\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n\n      // Try named fallback first\n      if (fallbackName) {\n        const fallback = this.fallbacks.get(fallbackName);\n        if (fallback) {\n          try {\n            const result = await Promise.race([\n              fallback(err),\n              new Promise((_, reject) =>\n                setTimeout(() => reject(new Error('Fallback timeout')), this.config.timeout)\n              ),\n            ]);\n            this.emit('fallback:success', { fallbackName, error: err.message });\n            return result;\n          } catch (fallbackError) {\n            this.emit('fallback:failed', { fallbackName, error: err.message });\n          }\n        }\n      }\n\n      // Try default fallback\n      try {\n        const result = await Promise.race([\n          this.config.fallback(err),\n          new Promise((_, reject) =>\n            setTimeout(() => reject(new Error('Fallback timeout')), this.config.timeout)\n          ),\n        ]);\n        this.emit('fallback:success', { error: err.message });\n        return result;\n      } catch (fallbackError) {\n        this.emit('fallback:failed', { error: err.message });\n        throw err;\n      }\n    }\n  }\n}\n\n/**\n * Bulkhead Pattern (isolation)\n */\nexport class Bulkhead extends EventEmitter {\n  private semaphores: Map<string, number> = new Map();\n  private queues: Map<string, Array<() => void>> = new Map();\n  private maxConcurrent: number;\n\n  constructor(maxConcurrent: number = 10) {\n    super();\n    this.maxConcurrent = maxConcurrent;\n  }\n\n  /**\n   * Execute with bulkhead\n   */\n  async execute<T>(name: string, fn: () => Promise<T>): Promise<T> {\n    const current = this.semaphores.get(name) || 0;\n\n    if (current >= this.maxConcurrent) {\n      // Queue the request\n      return new Promise((resolve, reject) => {\n        if (!this.queues.has(name)) {\n          this.queues.set(name, []);\n        }\n\n        this.queues.get(name)!.push(async () => {\n          try {\n            const result = await fn();\n            resolve(result);\n          } catch (error) {\n            reject(error);\n          }\n        });\n\n        this.emit('bulkhead:queued', { name, queueLength: this.queues.get(name)!.length });\n      });\n    }\n\n    this.semaphores.set(name, current + 1);\n    this.emit('bulkhead:acquired', { name, current: current + 1 });\n\n    try {\n      return await fn();\n    } finally {\n      this.semaphores.set(name, current);\n\n      // Process queue\n      const queue = this.queues.get(name);\n      if (queue && queue.length > 0) {\n        const next = queue.shift();\n        if (next) {\n          next();\n        }\n      }\n\n      this.emit('bulkhead:released', { name, current });\n    }\n  }\n\n  /**\n   * Get stats\n   */\n  getStats(): Record<string, { current: number; queued: number }> {\n    const stats: Record<string, any> = {};\n\n    for (const [name, current] of this.semaphores) {\n      stats[name] = {\n        current,\n        queued: this.queues.get(name)?.length || 0,\n      };\n    }\n\n    return stats;\n  }\n}\n\n/**\n * Timeout Handler\n */\nexport class TimeoutHandler extends EventEmitter {\n  /**\n   * Execute with timeout\n   */\n  async execute<T>(fn: () => Promise<T>, timeoutMs: number, name?: string): Promise<T> {\n    return Promise.race([\n      fn(),\n      new Promise<T>((_, reject) => {\n        setTimeout(() => {\n          const error = new Error(`Operation timeout after ${timeoutMs}ms`);\n          this.emit('timeout:exceeded', { name, timeoutMs });\n          reject(error);\n        }, timeoutMs);\n      }),\n    ]);\n  }\n}\n
