import { EventEmitter } from 'events';\n\nexport type EmailClient = 'gmail' | 'outlook' | 'apple' | 'thunderbird' | 'yahoo' | 'generic';\nexport type DeviceType = 'desktop' | 'mobile' | 'tablet';\n\nexport interface RenderingContext {\n  variables: Record<string, any>;\n  deviceType: DeviceType;\n  emailClient: EmailClient;\n  darkMode: boolean;\n  fontSize: number;\n}\n\nexport interface RenderedTemplate {\n  id: string;\n  templateId: string;\n  html: string;\n  plainText: string;\n  subject: string;\n  previewText: string;\n  renderTime: number;\n  warnings: RenderWarning[];\n  compatibility: ClientCompatibility[];\n}\n\nexport interface RenderWarning {\n  level: 'info' | 'warning' | 'error';\n  message: string;\n  line?: number;\n  suggestion?: string;\n}\n\nexport interface ClientCompatibility {\n  client: EmailClient;\n  supported: boolean;\n  issues: string[];\n  supportLevel: 'full' | 'partial' | 'minimal' | 'unsupported';\n}\n\nexport interface PreviewSnapshot {\n  id: string;\n  templateId: string;\n  deviceType: DeviceType;\n  emailClient: EmailClient;\n  imageData: string; // base64 encoded\n  width: number;\n  height: number;\n  createdAt: number;\n}\n\nexport interface RenderingTest {\n  id: string;\n  templateId: string;\n  testName: string;\n  context: RenderingContext;\n  expectedOutput?: string;\n  actualOutput?: string;\n  passed: boolean;\n  error?: string;\n  createdAt: number;\n}\n\nexport interface ClientTestResult {\n  client: EmailClient;\n  testsRun: number;\n  testsPassed: number;\n  testsFailed: number;\n  passRate: number;\n  issues: string[];\n}\n\nclass TemplatePreviewEngine extends EventEmitter {\n  private renderedTemplates: Map<string, RenderedTemplate> = new Map();\n  private snapshots: Map<string, PreviewSnapshot> = new Map();\n  private tests: Map<string, RenderingTest> = new Map();\n  private clientCompatibility: Map<EmailClient, ClientCompatibility> = new Map();\n\n  constructor() {\n    super();\n    this.initializeClientCompatibility();\n  }\n\n  /**\n   * Initialize client compatibility data\n   */\n  private initializeClientCompatibility(): void {\n    const clients: EmailClient[] = ['gmail', 'outlook', 'apple', 'thunderbird', 'yahoo', 'generic'];\n\n    for (const client of clients) {\n      const compatibility: ClientCompatibility = {\n        client,\n        supported: true,\n        issues: [],\n        supportLevel: 'full',\n      };\n\n      // Add known issues for specific clients\n      switch (client) {\n        case 'outlook':\n          compatibility.issues.push('Limited CSS support', 'No CSS Grid support');\n          compatibility.supportLevel = 'partial';\n          break;\n        case 'apple':\n          compatibility.issues.push('Webkit rendering differences');\n          compatibility.supportLevel = 'full';\n          break;\n        case 'thunderbird':\n          compatibility.issues.push('Limited HTML5 support');\n          compatibility.supportLevel = 'partial';\n          break;\n      }\n\n      this.clientCompatibility.set(client, compatibility);\n    }\n  }\n\n  /**\n   * Render template\n   */\n  renderTemplate(\n    templateId: string,\n    blocks: any[],\n    variables: Record<string, any>,\n    context: Partial<RenderingContext> = {}\n  ): RenderedTemplate {\n    const startTime = Date.now();\n    const renderContext: RenderingContext = {\n      variables,\n      deviceType: context.deviceType || 'desktop',\n      emailClient: context.emailClient || 'generic',\n      darkMode: context.darkMode || false,\n      fontSize: context.fontSize || 16,\n    };\n\n    const warnings: RenderWarning[] = [];\n    let html = '';\n    let plainText = '';\n\n    // Render blocks\n    for (const block of blocks) {\n      const blockResult = this.renderBlock(block, renderContext, warnings);\n      html += blockResult.html;\n      plainText += blockResult.plainText + '\\n';\n    }\n\n    // Wrap in email template\n    html = this.wrapEmailTemplate(html, renderContext);\n\n    // Extract subject and preview\n    const subject = this.extractSubject(blocks, renderContext);\n    const previewText = this.extractPreviewText(plainText);\n\n    // Check compatibility\n    const compatibility = this.checkClientCompatibility(html, renderContext.emailClient);\n\n    const rendered: RenderedTemplate = {\n      id: `rnd-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      templateId,\n      html,\n      plainText: plainText.trim(),\n      subject,\n      previewText,\n      renderTime: Date.now() - startTime,\n      warnings,\n      compatibility: [compatibility],\n    };\n\n    this.renderedTemplates.set(rendered.id, rendered);\n    this.emit('template:rendered', rendered);\n    return rendered;\n  }\n\n  /**\n   * Render block\n   */\n  private renderBlock(\n    block: any,\n    context: RenderingContext,\n    warnings: RenderWarning[]\n  ): { html: string; plainText: string } {\n    let html = '';\n    let plainText = '';\n\n    try {\n      switch (block.type) {\n        case 'text':\n          const text = this.substituteVariables(block.content, context.variables);\n          html = `<p style=\"${this.getTextStyles(block, context)}\">${this.escapeHtml(text)}</p>`;\n          plainText = text;\n          break;\n\n        case 'image':\n          html = `<img src=\"${block.content}\" style=\"max-width: 100%; height: auto;\" alt=\"${block.alt || 'Image'}\" />`;\n          plainText = `[Image: ${block.alt || block.content}]`;\n          break;\n\n        case 'button':\n          const buttonText = this.substituteVariables(block.content, context.variables);\n          html = `<a href=\"${block.url || '#'}\" style=\"${this.getButtonStyles(block, context)}\">${this.escapeHtml(buttonText)}</a>`;\n          plainText = `[Button: ${buttonText}]`;\n          break;\n\n        case 'divider':\n          html = `<hr style=\"border: none; border-top: 1px solid #ddd; margin: 20px 0;\" />`;\n          plainText = '---';\n          break;\n\n        case 'spacer':\n          const height = block.height || 20;\n          html = `<div style=\"height: ${height}px;\"></div>`;\n          plainText = '';\n          break;\n\n        case 'section':\n          html = `<div style=\"${this.getSectionStyles(block, context)}\">`;\n          if (block.children) {\n            for (const child of block.children) {\n              const childResult = this.renderBlock(child, context, warnings);\n              html += childResult.html;\n              plainText += childResult.plainText + '\\n';\n            }\n          }\n          html += '</div>';\n          break;\n\n        default:\n          warnings.push({\n            level: 'warning',\n            message: `Unknown block type: ${block.type}`,\n          });\n      }\n    } catch (error) {\n      warnings.push({\n        level: 'error',\n        message: `Error rendering block: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      });\n    }\n\n    return { html, plainText };\n  }\n\n  /**\n   * Substitute variables\n   */\n  private substituteVariables(content: string, variables: Record<string, any>): string {\n    let result = content;\n    for (const [key, value] of Object.entries(variables)) {\n      const regex = new RegExp(`{{${key}}}`, 'g');\n      result = result.replace(regex, String(value || ''));\n    }\n    return result;\n  }\n\n  /**\n   * Get text styles\n   */\n  private getTextStyles(block: any, context: RenderingContext): string {\n    const styles: string[] = [];\n    const styling = block.styling || {};\n\n    if (styling.fontSize) styles.push(`font-size: ${styling.fontSize}px`);\n    if (styling.fontWeight) styles.push(`font-weight: ${styling.fontWeight}`);\n    if (styling.color) styles.push(`color: ${styling.color}`);\n    if (styling.alignment) styles.push(`text-align: ${styling.alignment}`);\n    if (styling.backgroundColor) styles.push(`background-color: ${styling.backgroundColor}`);\n    if (styling.padding) styles.push(`padding: ${styling.padding}px`);\n\n    return styles.join('; ');\n  }\n\n  /**\n   * Get button styles\n   */\n  private getButtonStyles(block: any, context: RenderingContext): string {\n    const styling = block.styling || {};\n    const styles: string[] = [\n      'display: inline-block',\n      'padding: 12px 24px',\n      'text-decoration: none',\n      'border-radius: 4px',\n      'font-weight: bold',\n    ];\n\n    if (styling.backgroundColor) styles.push(`background-color: ${styling.backgroundColor}`);\n    if (styling.color) styles.push(`color: ${styling.color}`);\n\n    return styles.join('; ');\n  }\n\n  /**\n   * Get section styles\n   */\n  private getSectionStyles(block: any, context: RenderingContext): string {\n    const styling = block.styling || {};\n    const styles: string[] = [];\n\n    if (styling.backgroundColor) styles.push(`background-color: ${styling.backgroundColor}`);\n    if (styling.padding) styles.push(`padding: ${styling.padding}px`);\n\n    return styles.join('; ');\n  }\n\n  /**\n   * Wrap email template\n   */\n  private wrapEmailTemplate(content: string, context: RenderingContext): string {\n    const width = context.deviceType === 'mobile' ? '320px' : context.deviceType === 'tablet' ? '600px' : '600px';\n\n    return `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n          <style>\n            body { font-family: Arial, sans-serif; font-size: ${context.fontSize}px; line-height: 1.6; }\n            ${context.darkMode ? 'body { background-color: #1a1a1a; color: #fff; }' : ''}\n            a { color: #0066cc; }\n            img { max-width: 100%; height: auto; }\n          </style>\n        </head>\n        <body>\n          <div style=\"max-width: ${width}; margin: 0 auto; padding: 20px;\">\n            ${content}\n          </div>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Extract subject\n   */\n  private extractSubject(blocks: any[], context: RenderingContext): string {\n    const subjectBlock = blocks.find((b) => b.type === 'subject');\n    if (subjectBlock) {\n      return this.substituteVariables(subjectBlock.content, context.variables);\n    }\n    return 'Email';\n  }\n\n  /**\n   * Extract preview text\n   */\n  private extractPreviewText(plainText: string): string {\n    const lines = plainText.split('\\n').filter((l) => l.trim());\n    return lines.slice(0, 2).join(' ').substring(0, 150);\n  }\n\n  /**\n   * Check client compatibility\n   */\n  private checkClientCompatibility(html: string, client: EmailClient): ClientCompatibility {\n    const compatibility = this.clientCompatibility.get(client) || {\n      client,\n      supported: true,\n      issues: [],\n      supportLevel: 'full',\n    };\n\n    // Check for unsupported features\n    const issues: string[] = [];\n\n    if (html.includes('grid') && client === 'outlook') {\n      issues.push('CSS Grid not supported');\n    }\n    if (html.includes('@media') && client === 'thunderbird') {\n      issues.push('Media queries not fully supported');\n    }\n    if (html.includes('flex') && client === 'outlook') {\n      issues.push('Flexbox has limited support');\n    }\n\n    return {\n      ...compatibility,\n      issues: [...compatibility.issues, ...issues],\n    };\n  }\n\n  /**\n   * Escape HTML\n   */\n  private escapeHtml(text: string): string {\n    const map: Record<string, string> = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#039;',\n    };\n    return text.replace(/[&<>\"']/g, (m) => map[m]);\n  }\n\n  /**\n   * Get rendered template\n   */\n  getRenderedTemplate(renderedId: string): RenderedTemplate | undefined {\n    return this.renderedTemplates.get(renderedId);\n  }\n\n  /**\n   * Create preview snapshot\n   */\n  createSnapshot(\n    templateId: string,\n    deviceType: DeviceType,\n    emailClient: EmailClient,\n    imageData: string,\n    width: number,\n    height: number\n  ): PreviewSnapshot {\n    const snapshot: PreviewSnapshot = {\n      id: `snap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      templateId,\n      deviceType,\n      emailClient,\n      imageData,\n      width,\n      height,\n      createdAt: Date.now(),\n    };\n\n    this.snapshots.set(snapshot.id, snapshot);\n    this.emit('snapshot:created', snapshot);\n    return snapshot;\n  }\n\n  /**\n   * Get snapshots for template\n   */\n  getSnapshots(templateId: string): PreviewSnapshot[] {\n    return Array.from(this.snapshots.values()).filter((s) => s.templateId === templateId);\n  }\n\n  /**\n   * Create rendering test\n   */\n  createTest(\n    templateId: string,\n    testName: string,\n    context: RenderingContext\n  ): RenderingTest {\n    const test: RenderingTest = {\n      id: `tst-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      templateId,\n      testName,\n      context,\n      passed: false,\n      createdAt: Date.now(),\n    };\n\n    this.tests.set(test.id, test);\n    this.emit('test:created', test);\n    return test;\n  }\n\n  /**\n   * Run test\n   */\n  runTest(testId: string, expectedOutput?: string): boolean {\n    const test = this.tests.get(testId);\n    if (!test) return false;\n\n    try {\n      // Simulate test execution\n      test.actualOutput = `Rendered output for ${test.testName}`;\n      test.passed = !expectedOutput || test.actualOutput.includes(expectedOutput);\n\n      if (!test.passed) {\n        test.error = 'Output does not match expected';\n      }\n\n      this.emit('test:completed', test);\n      return test.passed;\n    } catch (error) {\n      test.error = error instanceof Error ? error.message : 'Unknown error';\n      test.passed = false;\n      return false;\n    }\n  }\n\n  /**\n   * Get tests for template\n   */\n  getTests(templateId: string): RenderingTest[] {\n    return Array.from(this.tests.values()).filter((t) => t.templateId === templateId);\n  }\n\n  /**\n   * Get client test results\n   */\n  getClientTestResults(templateId: string): ClientTestResult[] {\n    const tests = this.getTests(templateId);\n    const results: Map<EmailClient, ClientTestResult> = new Map();\n\n    for (const test of tests) {\n      const client = test.context.emailClient;\n      if (!results.has(client)) {\n        results.set(client, {\n          client,\n          testsRun: 0,\n          testsPassed: 0,\n          testsFailed: 0,\n          passRate: 0,\n          issues: [],\n        });\n      }\n\n      const result = results.get(client)!;\n      result.testsRun++;\n      if (test.passed) {\n        result.testsPassed++;\n      } else {\n        result.testsFailed++;\n        if (test.error) result.issues.push(test.error);\n      }\n    }\n\n    // Calculate pass rates\n    for (const [, result] of results) {\n      result.passRate = result.testsRun > 0 ? (result.testsPassed / result.testsRun) * 100 : 0;\n    }\n\n    return Array.from(results.values());\n  }\n\n  /**\n   * Get rendering report\n   */\n  getRenderingReport(templateId: string): Record<string, any> {\n    const snapshots = this.getSnapshots(templateId);\n    const tests = this.getTests(templateId);\n    const clientResults = this.getClientTestResults(templateId);\n\n    const totalTests = tests.length;\n    const passedTests = tests.filter((t) => t.passed).length;\n    const failedTests = totalTests - passedTests;\n\n    return {\n      templateId,\n      snapshots: snapshots.length,\n      totalTests,\n      passedTests,\n      failedTests,\n      passRate: totalTests > 0 ? (passedTests / totalTests) * 100 : 0,\n      clientResults,\n      devices: Array.from(new Set(snapshots.map((s) => s.deviceType))),\n      clients: Array.from(new Set(snapshots.map((s) => s.emailClient))),\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Cleanup if needed\n  }\n}\n\nexport default TemplatePreviewEngine;\n
