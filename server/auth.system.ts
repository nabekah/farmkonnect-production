import jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\nimport { EventEmitter } from 'events';\n\nexport type UserRole = 'admin' | 'manager' | 'worker' | 'viewer';\nexport type Permission = string;\n\nexport interface User {\n  /**\n   * User ID\n   */\n  id: string | number;\n  /**\n   * Username\n   */\n  username: string;\n  /**\n   * Email\n   */\n  email: string;\n  /**\n   * Password hash\n   */\n  passwordHash: string;\n  /**\n   * User role\n   */\n  role: UserRole;\n  /**\n   * Is active\n   */\n  isActive: boolean;\n  /**\n   * Is approved\n   */\n  isApproved: boolean;\n  /**\n   * MFA enabled\n   */\n  mfaEnabled: boolean;\n  /**\n   * MFA secret\n   */\n  mfaSecret?: string;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n}\n\nexport interface TokenPayload {\n  /**\n   * User ID\n   */\n  sub: string | number;\n  /**\n   * Username\n   */\n  username: string;\n  /**\n   * User role\n   */\n  role: UserRole;\n  /**\n   * Permissions\n   */\n  permissions: Permission[];\n  /**\n   * Issued at\n   */\n  iat: number;\n  /**\n   * Expires at\n   */\n  exp: number;\n}\n\nexport interface RefreshTokenPayload {\n  /**\n   * User ID\n   */\n  sub: string | number;\n  /**\n   * Token type\n   */\n  type: 'refresh';\n  /**\n   * Issued at\n   */\n  iat: number;\n  /**\n   * Expires at\n   */\n  exp: number;\n}\n\n/**\n * Role-Based Access Control (RBAC) Manager\n */\nexport class RBACManager extends EventEmitter {\n  private roles: Map<UserRole, Set<Permission>> = new Map();\n  private customRoles: Map<string, Set<Permission>> = new Map();\n\n  constructor() {\n    super();\n    this.initializeDefaultRoles();\n  }\n\n  /**\n   * Initialize default roles\n   */\n  private initializeDefaultRoles(): void {\n    // Admin: full access\n    this.roles.set('admin', new Set([\n      'user:create',\n      'user:read',\n      'user:update',\n      'user:delete',\n      'user:approve',\n      'user:disable',\n      'farm:create',\n      'farm:read',\n      'farm:update',\n      'farm:delete',\n      'report:create',\n      'report:read',\n      'report:delete',\n      'system:manage',\n    ]));\n\n    // Manager: farm management\n    this.roles.set('manager', new Set([\n      'user:read',\n      'user:update',\n      'farm:read',\n      'farm:update',\n      'report:create',\n      'report:read',\n      'task:create',\n      'task:read',\n      'task:update',\n    ]));\n\n    // Worker: task execution\n    this.roles.set('worker', new Set([\n      'task:read',\n      'task:update',\n      'report:create',\n      'activity:create',\n      'activity:read',\n    ]));\n\n    // Viewer: read-only access\n    this.roles.set('viewer', new Set([\n      'farm:read',\n      'report:read',\n      'task:read',\n    ]));\n  }\n\n  /**\n   * Check permission\n   */\n  hasPermission(role: UserRole, permission: Permission): boolean {\n    const permissions = this.roles.get(role) || this.customRoles.get(role);\n    return permissions ? permissions.has(permission) : false;\n  }\n\n  /**\n   * Check multiple permissions (AND)\n   */\n  hasAllPermissions(role: UserRole, permissions: Permission[]): boolean {\n    return permissions.every((p) => this.hasPermission(role, p));\n  }\n\n  /**\n   * Check multiple permissions (OR)\n   */\n  hasAnyPermission(role: UserRole, permissions: Permission[]): boolean {\n    return permissions.some((p) => this.hasPermission(role, p));\n  }\n\n  /**\n   * Get role permissions\n   */\n  getPermissions(role: UserRole): Permission[] {\n    const permissions = this.roles.get(role) || this.customRoles.get(role);\n    return permissions ? Array.from(permissions) : [];\n  }\n\n  /**\n   * Create custom role\n   */\n  createRole(name: string, permissions: Permission[]): void {\n    this.customRoles.set(name, new Set(permissions));\n    this.emit('role:created', { name, permissions });\n  }\n\n  /**\n   * Update role permissions\n   */\n  updateRole(name: string, permissions: Permission[]): void {\n    this.customRoles.set(name, new Set(permissions));\n    this.emit('role:updated', { name, permissions });\n  }\n\n  /**\n   * Delete custom role\n   */\n  deleteRole(name: string): void {\n    this.customRoles.delete(name);\n    this.emit('role:deleted', { name });\n  }\n\n  /**\n   * Get all roles\n   */\n  getAllRoles(): string[] {\n    return [\n      ...Array.from(this.roles.keys()),\n      ...Array.from(this.customRoles.keys()),\n    ];\n  }\n}\n\n/**\n * JWT Authentication Manager\n */\nexport class AuthManager extends EventEmitter {\n  private secret: string;\n  private refreshSecret: string;\n  private accessTokenExpiry: number = 3600; // 1 hour\n  private refreshTokenExpiry: number = 604800; // 7 days\n  private rbac: RBACManager;\n  private refreshTokens: Map<string, number> = new Map(); // token -> expiry\n\n  constructor(secret: string, refreshSecret: string, rbac: RBACManager) {\n    super();\n    this.secret = secret;\n    this.refreshSecret = refreshSecret;\n    this.rbac = rbac;\n  }\n\n  /**\n   * Hash password\n   */\n  hashPassword(password: string): string {\n    return crypto\n      .createHash('sha256')\n      .update(password + this.secret)\n      .digest('hex');\n  }\n\n  /**\n   * Verify password\n   */\n  verifyPassword(password: string, hash: string): boolean {\n    return this.hashPassword(password) === hash;\n  }\n\n  /**\n   * Generate access token\n   */\n  generateAccessToken(user: User): string {\n    const permissions = this.rbac.getPermissions(user.role);\n    const payload: TokenPayload = {\n      sub: user.id,\n      username: user.username,\n      role: user.role,\n      permissions,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + this.accessTokenExpiry,\n    };\n\n    return jwt.sign(payload, this.secret);\n  }\n\n  /**\n   * Generate refresh token\n   */\n  generateRefreshToken(userId: string | number): string {\n    const payload: RefreshTokenPayload = {\n      sub: userId,\n      type: 'refresh',\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + this.refreshTokenExpiry,\n    };\n\n    const token = jwt.sign(payload, this.refreshSecret);\n    this.refreshTokens.set(token, payload.exp * 1000);\n\n    return token;\n  }\n\n  /**\n   * Verify access token\n   */\n  verifyAccessToken(token: string): TokenPayload | null {\n    try {\n      return jwt.verify(token, this.secret) as TokenPayload;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Verify refresh token\n   */\n  verifyRefreshToken(token: string): RefreshTokenPayload | null {\n    try {\n      const expiry = this.refreshTokens.get(token);\n      if (!expiry || expiry < Date.now()) {\n        this.refreshTokens.delete(token);\n        return null;\n      }\n\n      return jwt.verify(token, this.refreshSecret) as RefreshTokenPayload;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Revoke refresh token\n   */\n  revokeRefreshToken(token: string): void {\n    this.refreshTokens.delete(token);\n  }\n\n  /**\n   * Revoke all user tokens\n   */\n  revokeAllUserTokens(userId: string | number): void {\n    for (const [token, expiry] of this.refreshTokens) {\n      try {\n        const payload = jwt.verify(token, this.refreshSecret) as RefreshTokenPayload;\n        if (payload.sub === userId) {\n          this.refreshTokens.delete(token);\n        }\n      } catch (error) {\n        // Invalid token, skip\n      }\n    }\n  }\n\n  /**\n   * Clean expired tokens\n   */\n  cleanExpiredTokens(): number {\n    let cleaned = 0;\n    const now = Date.now();\n\n    for (const [token, expiry] of this.refreshTokens) {\n      if (expiry < now) {\n        this.refreshTokens.delete(token);\n        cleaned++;\n      }\n    }\n\n    return cleaned;\n  }\n}\n\n/**\n * MFA Manager (Multi-Factor Authentication)\n */\nexport class MFAManager {\n  /**\n   * Generate MFA secret\n   */\n  generateSecret(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  /**\n   * Generate TOTP code\n   */\n  generateTOTP(secret: string): string {\n    const time = Math.floor(Date.now() / 1000 / 30);\n    const hmac = crypto.createHmac('sha1', Buffer.from(secret, 'hex'));\n    hmac.update(Buffer.alloc(8));\n    const digest = hmac.digest();\n    const offset = digest[digest.length - 1] & 0xf;\n    const code = (digest.readUInt32BE(offset) & 0x7fffffff) % 1000000;\n    return code.toString().padStart(6, '0');\n  }\n\n  /**\n   * Verify TOTP code\n   */\n  verifyTOTP(secret: string, code: string, window: number = 1): boolean {\n    const time = Math.floor(Date.now() / 1000 / 30);\n\n    for (let i = -window; i <= window; i++) {\n      const hmac = crypto.createHmac('sha1', Buffer.from(secret, 'hex'));\n      const buffer = Buffer.alloc(8);\n      buffer.writeBigInt64BE(BigInt(time + i));\n      hmac.update(buffer);\n      const digest = hmac.digest();\n      const offset = digest[digest.length - 1] & 0xf;\n      const testCode = (digest.readUInt32BE(offset) & 0x7fffffff) % 1000000;\n\n      if (testCode.toString().padStart(6, '0') === code) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n\n/**\n * Session Manager\n */\nexport class SessionManager extends EventEmitter {\n  private sessions: Map<string, { userId: string | number; expiresAt: number; data: any }> = new Map();\n  private cleanupInterval: NodeJS.Timeout | null = null;\n\n  constructor(cleanupIntervalMs: number = 3600000) {\n    super();\n    this.startCleanup(cleanupIntervalMs);\n  }\n\n  /**\n   * Create session\n   */\n  createSession(userId: string | number, expiresIn: number = 3600000, data: any = {}): string {\n    const sessionId = crypto.randomBytes(32).toString('hex');\n    this.sessions.set(sessionId, {\n      userId,\n      expiresAt: Date.now() + expiresIn,\n      data,\n    });\n\n    this.emit('session:created', { sessionId, userId });\n    return sessionId;\n  }\n\n  /**\n   * Get session\n   */\n  getSession(sessionId: string): { userId: string | number; data: any } | null {\n    const session = this.sessions.get(sessionId);\n\n    if (!session) return null;\n\n    if (session.expiresAt < Date.now()) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    return { userId: session.userId, data: session.data };\n  }\n\n  /**\n   * Update session data\n   */\n  updateSessionData(sessionId: string, data: any): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.data = { ...session.data, ...data };\n    }\n  }\n\n  /**\n   * Destroy session\n   */\n  destroySession(sessionId: string): void {\n    this.sessions.delete(sessionId);\n    this.emit('session:destroyed', { sessionId });\n  }\n\n  /**\n   * Destroy all user sessions\n   */\n  destroyAllUserSessions(userId: string | number): void {\n    for (const [sessionId, session] of this.sessions) {\n      if (session.userId === userId) {\n        this.sessions.delete(sessionId);\n      }\n    }\n  }\n\n  /**\n   * Start cleanup\n   */\n  private startCleanup(intervalMs: number): void {\n    this.cleanupInterval = setInterval(() => {\n      const now = Date.now();\n      let cleaned = 0;\n\n      for (const [sessionId, session] of this.sessions) {\n        if (session.expiresAt < now) {\n          this.sessions.delete(sessionId);\n          cleaned++;\n        }\n      }\n\n      if (cleaned > 0) {\n        this.emit('sessions:cleaned', { count: cleaned });\n      }\n    }, intervalMs);\n  }\n\n  /**\n   * Stop cleanup\n   */\n  stop(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n\n  /**\n   * Get stats\n   */\n  getStats(): { total: number; active: number } {\n    const now = Date.now();\n    let active = 0;\n\n    for (const session of this.sessions.values()) {\n      if (session.expiresAt > now) {\n        active++;\n      }\n    }\n\n    return {\n      total: this.sessions.size,\n      active,\n    };\n  }\n}\n
