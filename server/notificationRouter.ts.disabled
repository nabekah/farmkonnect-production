import { router, protectedProcedure } from "./_core/trpc";
import { z } from "zod";
import { db } from "./db";
import { notifications } from "../drizzle/schema";
import { eq, and } from "drizzle-orm";

export const notificationRouter = router({
  // Get all notifications for current user
  getNotifications: protectedProcedure
    .input(z.object({ 
      status: z.enum(['unread', 'read', 'archived']).optional(),
      limit: z.number().default(20),
      offset: z.number().default(0)
    }).optional())
    .query(async ({ ctx, input }) => {
      const where = input?.status 
        ? and(eq(notifications.userId, ctx.user.id), eq(notifications.status, input.status))
        : eq(notifications.userId, ctx.user.id);
      
      const notifs = await db
        .select()
        .from(notifications)
        .where(where)
        .orderBy((t) => t.createdAt)
        .limit(input?.limit || 20)
        .offset(input?.offset || 0);
      
      return notifs;
    }),

  // Mark notification as read
  markAsRead: protectedProcedure
    .input(z.object({ notificationId: z.number() }))
    .mutation(async ({ ctx, input }) => {
      const result = await db
        .update(notifications)
        .set({ status: 'read', readAt: new Date().toISOString() })
        .where(and(
          eq(notifications.id, input.notificationId),
          eq(notifications.userId, ctx.user.id)
        ));
      
      return { success: true };
    }),

  // Create notification
  createNotification: protectedProcedure
    .input(z.object({
      userId: z.number(),
      farmId: z.number().optional(),
      type: z.string(),
      title: z.string(),
      message: z.string(),
      actionUrl: z.string().optional()
    }))
    .mutation(async ({ input }) => {
      const result = await db.insert(notifications).values({
        userId: input.userId,
        farmId: input.farmId,
        type: input.type,
        title: input.title,
        message: input.message,
        actionUrl: input.actionUrl,
        status: 'unread',
        createdAt: new Date().toISOString()
      });
      
      return { success: true, id: result.insertId };
    }),

  // Delete notification
  deleteNotification: protectedProcedure
    .input(z.object({ notificationId: z.number() }))
    .mutation(async ({ ctx, input }) => {
      await db
        .delete(notifications)
        .where(and(
          eq(notifications.id, input.notificationId),
          eq(notifications.userId, ctx.user.id)
        ));
      
      return { success: true };
    })
});
