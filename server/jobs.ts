import { EventEmitter } from 'events';\n\nexport type JobStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';\n\nexport interface JobConfig {\n  /**\n   * Job name\n   */\n  name: string;\n  /**\n   * Job data\n   */\n  data: any;\n  /**\n   * Max retries\n   */\n  maxRetries?: number;\n  /**\n   * Retry delay in ms\n   */\n  retryDelay?: number;\n  /**\n   * Priority (higher = more important)\n   */\n  priority?: number;\n  /**\n   * Scheduled time\n   */\n  scheduledAt?: number;\n}\n\nexport interface Job extends JobConfig {\n  /**\n   * Job ID\n   */\n  id: string;\n  /**\n   * Job status\n   */\n  status: JobStatus;\n  /**\n   * Retry count\n   */\n  retries: number;\n  /**\n   * Error message\n   */\n  error?: string;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Started at\n   */\n  startedAt?: number;\n  /**\n   * Completed at\n   */\n  completedAt?: number;\n}\n\nexport type JobHandler = (job: Job) => Promise<void>;\n\n/**\n * Job Queue Manager\n * \n * Manages background jobs with retry logic and scheduling\n */\nexport class JobQueue extends EventEmitter {\n  private jobs: Map<string, Job> = new Map();\n  private handlers: Map<string, JobHandler> = new Map();\n  private processing: Set<string> = new Set();\n  private processInterval: NodeJS.Timeout | null = null;\n  private maxConcurrent: number = 5;\n\n  constructor(maxConcurrent: number = 5) {\n    super();\n    this.maxConcurrent = maxConcurrent;\n    this.startProcessor();\n  }\n\n  /**\n   * Register job handler\n   */\n  register(name: string, handler: JobHandler): void {\n    this.handlers.set(name, handler);\n  }\n\n  /**\n   * Add job to queue\n   */\n  async add(config: JobConfig): Promise<string> {\n    const jobId = `job-${Date.now()}-${Math.random()}`;\n    const job: Job = {\n      ...config,\n      id: jobId,\n      status: 'pending',\n      retries: 0,\n      createdAt: Date.now(),\n    };\n\n    this.jobs.set(jobId, job);\n    this.emit('job:added', job);\n\n    return jobId;\n  }\n\n  /**\n   * Get job by ID\n   */\n  getJob(jobId: string): Job | null {\n    return this.jobs.get(jobId) || null;\n  }\n\n  /**\n   * Get all jobs\n   */\n  getAllJobs(): Job[] {\n    return Array.from(this.jobs.values());\n  }\n\n  /**\n   * Get jobs by status\n   */\n  getJobsByStatus(status: JobStatus): Job[] {\n    return Array.from(this.jobs.values()).filter((j) => j.status === status);\n  }\n\n  /**\n   * Cancel job\n   */\n  cancelJob(jobId: string): void {\n    const job = this.jobs.get(jobId);\n    if (job && job.status !== 'processing') {\n      job.status = 'cancelled';\n      this.emit('job:cancelled', job);\n    }\n  }\n\n  /**\n   * Process job\n   */\n  private async processJob(job: Job): Promise<void> {\n    try {\n      job.status = 'processing';\n      job.startedAt = Date.now();\n      this.emit('job:started', job);\n\n      const handler = this.handlers.get(job.name);\n      if (!handler) {\n        throw new Error(`No handler registered for job: ${job.name}`);\n      }\n\n      await handler(job);\n\n      job.status = 'completed';\n      job.completedAt = Date.now();\n      this.emit('job:completed', job);\n    } catch (error) {\n      const maxRetries = job.maxRetries || 3;\n      const retryDelay = job.retryDelay || 5000;\n\n      if (job.retries < maxRetries) {\n        job.retries++;\n        job.status = 'pending';\n        job.error = error instanceof Error ? error.message : 'Unknown error';\n        job.scheduledAt = Date.now() + retryDelay * job.retries;\n        this.emit('job:retry', job);\n      } else {\n        job.status = 'failed';\n        job.error = error instanceof Error ? error.message : 'Unknown error';\n        job.completedAt = Date.now();\n        this.emit('job:failed', job);\n      }\n    } finally {\n      this.processing.delete(job.id);\n    }\n  }\n\n  /**\n   * Start processor\n   */\n  private startProcessor(): void {\n    this.processInterval = setInterval(() => {\n      this.processQueue();\n    }, 1000);\n  }\n\n  /**\n   * Process queue\n   */\n  private async processQueue(): Promise<void> {\n    if (this.processing.size >= this.maxConcurrent) {\n      return;\n    }\n\n    const now = Date.now();\n    const pendingJobs = Array.from(this.jobs.values())\n      .filter(\n        (j) =>\n          j.status === 'pending' &&\n          (!j.scheduledAt || j.scheduledAt <= now)\n      )\n      .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n      .slice(0, this.maxConcurrent - this.processing.size);\n\n    for (const job of pendingJobs) {\n      this.processing.add(job.id);\n      this.processJob(job).catch((error) => {\n        console.error(`Error processing job ${job.id}:`, error);\n      });\n    }\n  }\n\n  /**\n   * Stop processor\n   */\n  stop(): void {\n    if (this.processInterval) {\n      clearInterval(this.processInterval);\n      this.processInterval = null;\n    }\n  }\n\n  /**\n   * Get queue stats\n   */\n  getStats(): {\n    total: number;\n    pending: number;\n    processing: number;\n    completed: number;\n    failed: number;\n    cancelled: number;\n  } {\n    const jobs = Array.from(this.jobs.values());\n    return {\n      total: jobs.length,\n      pending: jobs.filter((j) => j.status === 'pending').length,\n      processing: jobs.filter((j) => j.status === 'processing').length,\n      completed: jobs.filter((j) => j.status === 'completed').length,\n      failed: jobs.filter((j) => j.status === 'failed').length,\n      cancelled: jobs.filter((j) => j.status === 'cancelled').length,\n    };\n  }\n\n  /**\n   * Clear completed jobs\n   */\n  clearCompleted(): number {\n    let cleared = 0;\n    for (const [jobId, job] of this.jobs) {\n      if (job.status === 'completed' || job.status === 'failed' || job.status === 'cancelled') {\n        this.jobs.delete(jobId);\n        cleared++;\n      }\n    }\n    return cleared;\n  }\n}\n\n/**\n * Scheduled Job Manager\n * \n * Manages recurring scheduled jobs\n */\nexport class ScheduledJobManager {\n  private jobs: Map<string, { interval: NodeJS.Timeout; handler: () => Promise<void> }> = new Map();\n  private queue: JobQueue;\n\n  constructor(queue: JobQueue) {\n    this.queue = queue;\n  }\n\n  /**\n   * Schedule recurring job\n   */\n  scheduleRecurring(\n    name: string,\n    intervalMs: number,\n    handler: () => Promise<void>\n  ): string {\n    const jobId = `scheduled-${name}-${Date.now()}`;\n\n    const interval = setInterval(async () => {\n      try {\n        await handler();\n      } catch (error) {\n        console.error(`Error in scheduled job ${name}:`, error);\n      }\n    }, intervalMs);\n\n    this.jobs.set(jobId, { interval, handler });\n    return jobId;\n  }\n\n  /**\n   * Schedule cron-like job\n   */\n  scheduleCron(name: string, cronExpression: string, handler: () => Promise<void>): string {\n    // Simple cron parser (supports: \"0 0 * * *\" = daily at midnight)\n    const parts = cronExpression.split(' ');\n    if (parts.length !== 5) {\n      throw new Error('Invalid cron expression');\n    }\n\n    const [minute, hour, dayOfMonth, month, dayOfWeek] = parts.map((p) => (p === '*' ? -1 : parseInt(p)));\n\n    const jobId = `cron-${name}-${Date.now()}`;\n\n    const checkAndRun = async () => {\n      const now = new Date();\n      const m = now.getMinutes();\n      const h = now.getHours();\n      const d = now.getDate();\n      const mo = now.getMonth() + 1;\n      const dow = now.getDay();\n\n      const matches =\n        (minute === -1 || minute === m) &&\n        (hour === -1 || hour === h) &&\n        (dayOfMonth === -1 || dayOfMonth === d) &&\n        (month === -1 || month === mo) &&\n        (dayOfWeek === -1 || dayOfWeek === dow);\n\n      if (matches) {\n        try {\n          await handler();\n        } catch (error) {\n          console.error(`Error in cron job ${name}:`, error);\n        }\n      }\n    };\n\n    const interval = setInterval(checkAndRun, 60000); // Check every minute\n    this.jobs.set(jobId, { interval, handler: checkAndRun });\n\n    return jobId;\n  }\n\n  /**\n   * Cancel scheduled job\n   */\n  cancel(jobId: string): void {\n    const job = this.jobs.get(jobId);\n    if (job) {\n      clearInterval(job.interval);\n      this.jobs.delete(jobId);\n    }\n  }\n\n  /**\n   * Get all scheduled jobs\n   */\n  getAll(): string[] {\n    return Array.from(this.jobs.keys());\n  }\n\n  /**\n   * Stop all scheduled jobs\n   */\n  stopAll(): void {\n    for (const [jobId, job] of this.jobs) {\n      clearInterval(job.interval);\n    }\n    this.jobs.clear();\n  }\n}\n
