import { EventEmitter } from 'events';\n\nexport type NotificationChannel = 'email' | 'sms' | 'push' | 'in-app';\nexport type NotificationPriority = 'low' | 'normal' | 'high' | 'urgent';\nexport type NotificationStatus = 'pending' | 'sent' | 'delivered' | 'failed' | 'read';\nexport type NotificationType = 'alert' | 'info' | 'warning' | 'success' | 'error';\n\nexport interface NotificationTemplate {\n  /**\n   * Template ID\n   */\n  id: string;\n  /**\n   * Template name\n   */\n  name: string;\n  /**\n   * Subject (for email)\n   */\n  subject?: string;\n  /**\n   * Body template\n   */\n  body: string;\n  /**\n   * Variables\n   */\n  variables: string[];\n  /**\n   * Created at\n   */\n  createdAt: number;\n}\n\nexport interface Notification {\n  /**\n   * Notification ID\n   */\n  id: string;\n  /**\n   * User ID\n   */\n  userId: string;\n  /**\n   * Title\n   */\n  title: string;\n  /**\n   * Message\n   */\n  message: string;\n  /**\n   * Type\n   */\n  type: NotificationType;\n  /**\n   * Priority\n   */\n  priority: NotificationPriority;\n  /**\n   * Channels\n   */\n  channels: NotificationChannel[];\n  /**\n   * Status per channel\n   */\n  status: Record<NotificationChannel, NotificationStatus>;\n  /**\n   * Data\n   */\n  data?: Record<string, any>;\n  /**\n   * Read at\n   */\n  readAt?: number;\n  /**\n   * Scheduled for\n   */\n  scheduledFor?: number;\n  /**\n   * Expires at\n   */\n  expiresAt?: number;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n}\n\nexport interface NotificationPreferences {\n  /**\n   * User ID\n   */\n  userId: string;\n  /**\n   * Enabled channels\n   */\n  enabledChannels: NotificationChannel[];\n  /**\n   * Quiet hours (start, end in 24h format)\n   */\n  quietHours?: { start: number; end: number };\n  /**\n   * Notification frequency\n   */\n  frequency: 'instant' | 'daily' | 'weekly' | 'never';\n  /**\n   * Categories to receive\n   */\n  categories: string[];\n  /**\n   * Do not disturb\n   */\n  doNotDisturb: boolean;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n}\n\n/**\n * Notification Service\n */\nexport class NotificationService extends EventEmitter {\n  private notifications: Map<string, Notification> = new Map();\n  private templates: Map<string, NotificationTemplate> = new Map();\n  private preferences: Map<string, NotificationPreferences> = new Map();\n  private queue: Notification[] = [];\n  private processing: boolean = false;\n\n  /**\n   * Register template\n   */\n  registerTemplate(template: NotificationTemplate): void {\n    this.templates.set(template.id, template);\n    this.emit('template:registered', { id: template.id, name: template.name });\n  }\n\n  /**\n   * Get template\n   */\n  getTemplate(id: string): NotificationTemplate | null {\n    return this.templates.get(id) || null;\n  }\n\n  /**\n   * Send notification\n   */\n  async sendNotification(\n    userId: string,\n    title: string,\n    message: string,\n    options?: {\n      type?: NotificationType;\n      priority?: NotificationPriority;\n      channels?: NotificationChannel[];\n      data?: Record<string, any>;\n      scheduledFor?: number;\n    }\n  ): Promise<Notification> {\n    const notification: Notification = {\n      id: `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      title,\n      message,\n      type: options?.type || 'info',\n      priority: options?.priority || 'normal',\n      channels: options?.channels || ['in-app', 'email'],\n      status: {\n        email: 'pending',\n        sms: 'pending',\n        push: 'pending',\n        'in-app': 'pending',\n      },\n      data: options?.data,\n      scheduledFor: options?.scheduledFor,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.notifications.set(notification.id, notification);\n\n    // Check preferences\n    const prefs = this.preferences.get(userId);\n    if (prefs && !this.shouldSendNotification(notification, prefs)) {\n      notification.status['in-app'] = 'pending';\n      this.emit('notification:suppressed', { id: notification.id, reason: 'user-preferences' });\n      return notification;\n    }\n\n    // Queue for delivery\n    if (notification.scheduledFor && notification.scheduledFor > Date.now()) {\n      this.emit('notification:scheduled', { id: notification.id, scheduledFor: notification.scheduledFor });\n    } else {\n      this.queue.push(notification);\n      await this.processQueue();\n    }\n\n    return notification;\n  }\n\n  /**\n   * Send notification from template\n   */\n  async sendFromTemplate(\n    userId: string,\n    templateId: string,\n    variables: Record<string, any>,\n    options?: {\n      priority?: NotificationPriority;\n      channels?: NotificationChannel[];\n    }\n  ): Promise<Notification> {\n    const template = this.getTemplate(templateId);\n    if (!template) {\n      throw new Error(`Template not found: ${templateId}`);\n    }\n\n    let body = template.body;\n    for (const [key, value] of Object.entries(variables)) {\n      body = body.replace(new RegExp(`{{${key}}}`, 'g'), String(value));\n    }\n\n    return this.sendNotification(userId, template.subject || 'Notification', body, options);\n  }\n\n  /**\n   * Process notification queue\n   */\n  private async processQueue(): Promise<void> {\n    if (this.processing || this.queue.length === 0) return;\n\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const notification = this.queue.shift()!;\n\n      for (const channel of notification.channels) {\n        try {\n          await this.deliverViaChannel(notification, channel);\n          notification.status[channel] = 'delivered';\n          this.emit('notification:delivered', { id: notification.id, channel });\n        } catch (error) {\n          notification.status[channel] = 'failed';\n          this.emit('notification:failed', {\n            id: notification.id,\n            channel,\n            error: error instanceof Error ? error.message : 'Unknown error',\n          });\n        }\n      }\n\n      notification.updatedAt = Date.now();\n    }\n\n    this.processing = false;\n  }\n\n  /**\n   * Deliver via channel\n   */\n  private async deliverViaChannel(notification: Notification, channel: NotificationChannel): Promise<void> {\n    switch (channel) {\n      case 'email':\n        await this.sendEmail(notification);\n        break;\n      case 'sms':\n        await this.sendSMS(notification);\n        break;\n      case 'push':\n        await this.sendPush(notification);\n        break;\n      case 'in-app':\n        await this.storeInApp(notification);\n        break;\n    }\n  }\n\n  /**\n   * Send email\n   */\n  private async sendEmail(notification: Notification): Promise<void> {\n    // Simulate email sending\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        this.emit('email:sent', { userId: notification.userId, title: notification.title });\n        resolve();\n      }, 100);\n    });\n  }\n\n  /**\n   * Send SMS\n   */\n  private async sendSMS(notification: Notification): Promise<void> {\n    // Simulate SMS sending\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        this.emit('sms:sent', { userId: notification.userId, message: notification.message });\n        resolve();\n      }, 100);\n    });\n  }\n\n  /**\n   * Send push\n   */\n  private async sendPush(notification: Notification): Promise<void> {\n    // Simulate push notification\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        this.emit('push:sent', { userId: notification.userId, title: notification.title });\n        resolve();\n      }, 100);\n    });\n  }\n\n  /**\n   * Store in-app\n   */\n  private async storeInApp(notification: Notification): Promise<void> {\n    // In-app notifications are already stored\n    return Promise.resolve();\n  }\n\n  /**\n   * Should send notification\n   */\n  private shouldSendNotification(notification: Notification, prefs: NotificationPreferences): boolean {\n    // Check if user disabled all notifications\n    if (prefs.doNotDisturb) return false;\n\n    // Check quiet hours\n    if (prefs.quietHours) {\n      const now = new Date();\n      const hours = now.getHours();\n      if (hours >= prefs.quietHours.start && hours < prefs.quietHours.end) {\n        // Allow urgent notifications during quiet hours\n        if (notification.priority !== 'urgent') return false;\n      }\n    }\n\n    // Check enabled channels\n    const hasEnabledChannel = notification.channels.some((ch) => prefs.enabledChannels.includes(ch));\n    if (!hasEnabledChannel) return false;\n\n    return true;\n  }\n\n  /**\n   * Get notification\n   */\n  getNotification(id: string): Notification | null {\n    return this.notifications.get(id) || null;\n  }\n\n  /**\n   * Get user notifications\n   */\n  getUserNotifications(userId: string, limit: number = 50): Notification[] {\n    return Array.from(this.notifications.values())\n      .filter((n) => n.userId === userId)\n      .sort((a, b) => b.createdAt - a.createdAt)\n      .slice(0, limit);\n  }\n\n  /**\n   * Mark as read\n   */\n  markAsRead(id: string): boolean {\n    const notification = this.notifications.get(id);\n    if (!notification) return false;\n\n    notification.readAt = Date.now();\n    notification.status['in-app'] = 'read';\n    this.emit('notification:read', { id });\n    return true;\n  }\n\n  /**\n   * Delete notification\n   */\n  deleteNotification(id: string): boolean {\n    if (this.notifications.delete(id)) {\n      this.emit('notification:deleted', { id });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Set user preferences\n   */\n  setPreferences(userId: string, prefs: Partial<NotificationPreferences>): void {\n    const existing = this.preferences.get(userId) || {\n      userId,\n      enabledChannels: ['in-app', 'email'],\n      frequency: 'instant',\n      categories: [],\n      doNotDisturb: false,\n      updatedAt: Date.now(),\n    };\n\n    const updated = { ...existing, ...prefs, updatedAt: Date.now() };\n    this.preferences.set(userId, updated);\n    this.emit('preferences:updated', { userId });\n  }\n\n  /**\n   * Get user preferences\n   */\n  getPreferences(userId: string): NotificationPreferences | null {\n    return this.preferences.get(userId) || null;\n  }\n\n  /**\n   * Get notification stats\n   */\n  getStats(): {\n    total: number;\n    sent: number;\n    delivered: number;\n    failed: number;\n    pending: number;\n  } {\n    const notifications = Array.from(this.notifications.values());\n    const stats = {\n      total: notifications.length,\n      sent: 0,\n      delivered: 0,\n      failed: 0,\n      pending: 0,\n    };\n\n    for (const notif of notifications) {\n      const statuses = Object.values(notif.status);\n      if (statuses.includes('delivered')) stats.delivered++;\n      else if (statuses.includes('failed')) stats.failed++;\n      else if (statuses.includes('pending')) stats.pending++;\n      else stats.sent++;\n    }\n\n    return stats;\n  }\n}\n
