import { EventEmitter } from 'events';\n\nexport interface Metric {\n  /**\n   * Metric name\n   */\n  name: string;\n  /**\n   * Metric value\n   */\n  value: number;\n  /**\n   * Metric unit\n   */\n  unit?: string;\n  /**\n   * Timestamp\n   */\n  timestamp: number;\n  /**\n   * Labels\n   */\n  labels?: Record<string, string>;\n}\n\nexport interface HealthCheckResult {\n  /**\n   * Check name\n   */\n  name: string;\n  /**\n   * Is healthy\n   */\n  healthy: boolean;\n  /**\n   * Status message\n   */\n  message?: string;\n  /**\n   * Response time in ms\n   */\n  responseTime: number;\n  /**\n   * Check timestamp\n   */\n  timestamp: number;\n}\n\nexport interface SystemHealth {\n  /**\n   * Overall health status\n   */\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  /**\n   * Check results\n   */\n  checks: HealthCheckResult[];\n  /**\n   * Timestamp\n   */\n  timestamp: number;\n  /**\n   * Uptime in seconds\n   */\n  uptime: number;\n}\n\n/**\n * Metrics Collector\n */\nexport class MetricsCollector extends EventEmitter {\n  private metrics: Map<string, Metric[]> = new Map();\n  private counters: Map<string, number> = new Map();\n  private gauges: Map<string, number> = new Map();\n  private histograms: Map<string, number[]> = new Map();\n  private maxMetricsPerName: number = 1000;\n\n  /**\n   * Record metric\n   */\n  recordMetric(name: string, value: number, unit?: string, labels?: Record<string, string>): void {\n    const metric: Metric = {\n      name,\n      value,\n      unit,\n      timestamp: Date.now(),\n      labels,\n    };\n\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, []);\n    }\n\n    const metricList = this.metrics.get(name)!;\n    metricList.push(metric);\n\n    // Keep only recent metrics\n    if (metricList.length > this.maxMetricsPerName) {\n      metricList.shift();\n    }\n\n    this.emit('metric:recorded', metric);\n  }\n\n  /**\n   * Increment counter\n   */\n  incrementCounter(name: string, value: number = 1): void {\n    const current = this.counters.get(name) || 0;\n    this.counters.set(name, current + value);\n    this.emit('counter:incremented', { name, value: current + value });\n  }\n\n  /**\n   * Set gauge\n   */\n  setGauge(name: string, value: number): void {\n    this.gauges.set(name, value);\n    this.emit('gauge:set', { name, value });\n  }\n\n  /**\n   * Record histogram\n   */\n  recordHistogram(name: string, value: number): void {\n    if (!this.histograms.has(name)) {\n      this.histograms.set(name, []);\n    }\n\n    const histogram = this.histograms.get(name)!;\n    histogram.push(value);\n\n    // Keep only recent values\n    if (histogram.length > this.maxMetricsPerName) {\n      histogram.shift();\n    }\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics(name?: string): Metric[] {\n    if (name) {\n      return this.metrics.get(name) || [];\n    }\n\n    const allMetrics: Metric[] = [];\n    for (const metrics of this.metrics.values()) {\n      allMetrics.push(...metrics);\n    }\n    return allMetrics;\n  }\n\n  /**\n   * Get counter\n   */\n  getCounter(name: string): number {\n    return this.counters.get(name) || 0;\n  }\n\n  /**\n   * Get gauge\n   */\n  getGauge(name: string): number {\n    return this.gauges.get(name) || 0;\n  }\n\n  /**\n   * Get histogram stats\n   */\n  getHistogramStats(name: string): {\n    count: number;\n    min: number;\n    max: number;\n    avg: number;\n    p50: number;\n    p95: number;\n    p99: number;\n  } | null {\n    const histogram = this.histograms.get(name);\n    if (!histogram || histogram.length === 0) return null;\n\n    const sorted = [...histogram].sort((a, b) => a - b);\n    const sum = sorted.reduce((a, b) => a + b, 0);\n\n    return {\n      count: sorted.length,\n      min: sorted[0],\n      max: sorted[sorted.length - 1],\n      avg: sum / sorted.length,\n      p50: sorted[Math.floor(sorted.length * 0.5)],\n      p95: sorted[Math.floor(sorted.length * 0.95)],\n      p99: sorted[Math.floor(sorted.length * 0.99)],\n    };\n  }\n\n  /**\n   * Get all counters\n   */\n  getAllCounters(): Record<string, number> {\n    return Object.fromEntries(this.counters);\n  }\n\n  /**\n   * Get all gauges\n   */\n  getAllGauges(): Record<string, number> {\n    return Object.fromEntries(this.gauges);\n  }\n\n  /**\n   * Reset metric\n   */\n  resetMetric(name: string): void {\n    this.metrics.delete(name);\n    this.counters.delete(name);\n    this.gauges.delete(name);\n    this.histograms.delete(name);\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clearAll(): void {\n    this.metrics.clear();\n    this.counters.clear();\n    this.gauges.clear();\n    this.histograms.clear();\n  }\n}\n\n/**\n * Health Check Manager\n */\nexport class HealthCheckManager extends EventEmitter {\n  private checks: Map<string, () => Promise<boolean>> = new Map();\n  private results: Map<string, HealthCheckResult> = new Map();\n  private startTime: number = Date.now();\n\n  /**\n   * Register health check\n   */\n  registerCheck(name: string, check: () => Promise<boolean>): void {\n    this.checks.set(name, check);\n  }\n\n  /**\n   * Run health check\n   */\n  async runCheck(name: string): Promise<HealthCheckResult> {\n    const check = this.checks.get(name);\n    if (!check) {\n      throw new Error(`Health check not found: ${name}`);\n    }\n\n    const startTime = Date.now();\n    try {\n      const healthy = await check();\n      const result: HealthCheckResult = {\n        name,\n        healthy,\n        responseTime: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: healthy ? 'OK' : 'Check failed',\n      };\n\n      this.results.set(name, result);\n      this.emit('check:completed', result);\n\n      return result;\n    } catch (error) {\n      const result: HealthCheckResult = {\n        name,\n        healthy: false,\n        responseTime: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: error instanceof Error ? error.message : 'Unknown error',\n      };\n\n      this.results.set(name, result);\n      this.emit('check:failed', result);\n\n      return result;\n    }\n  }\n\n  /**\n   * Run all checks\n   */\n  async runAllChecks(): Promise<SystemHealth> {\n    const results = await Promise.all(\n      Array.from(this.checks.keys()).map((name) => this.runCheck(name))\n    );\n\n    const allHealthy = results.every((r) => r.healthy);\n    const anyUnhealthy = results.some((r) => !r.healthy);\n\n    const status = allHealthy ? 'healthy' : anyUnhealthy ? 'unhealthy' : 'degraded';\n\n    const health: SystemHealth = {\n      status,\n      checks: results,\n      timestamp: Date.now(),\n      uptime: Math.floor((Date.now() - this.startTime) / 1000),\n    };\n\n    this.emit('health:checked', health);\n\n    return health;\n  }\n\n  /**\n   * Get last check result\n   */\n  getLastResult(name: string): HealthCheckResult | null {\n    return this.results.get(name) || null;\n  }\n\n  /**\n   * Get all results\n   */\n  getAllResults(): HealthCheckResult[] {\n    return Array.from(this.results.values());\n  }\n}\n\n/**\n * Performance Monitor\n */\nexport class PerformanceMonitor {\n  private metrics: MetricsCollector;\n  private requestDurations: Map<string, number[]> = new Map();\n\n  constructor(metrics: MetricsCollector) {\n    this.metrics = metrics;\n  }\n\n  /**\n   * Record request\n   */\n  recordRequest(path: string, method: string, duration: number, status: number): void {\n    const key = `${method}:${path}`;\n\n    if (!this.requestDurations.has(key)) {\n      this.requestDurations.set(key, []);\n    }\n\n    this.requestDurations.get(key)!.push(duration);\n\n    this.metrics.recordMetric(`http_request_duration_ms`, duration, 'ms', {\n      method,\n      path,\n      status: status.toString(),\n    });\n\n    this.metrics.incrementCounter(`http_requests_total`, 1);\n    this.metrics.incrementCounter(`http_requests_${status}`, 1);\n  }\n\n  /**\n   * Record error\n   */\n  recordError(error: Error, context?: Record<string, any>): void {\n    this.metrics.incrementCounter('errors_total', 1);\n    this.metrics.recordMetric('error_recorded', 1, 'count', {\n      type: error.constructor.name,\n      ...context,\n    });\n  }\n\n  /**\n   * Record database query\n   */\n  recordDatabaseQuery(query: string, duration: number, success: boolean): void {\n    this.metrics.recordMetric('db_query_duration_ms', duration, 'ms', {\n      success: success.toString(),\n    });\n\n    this.metrics.incrementCounter('db_queries_total', 1);\n    if (success) {\n      this.metrics.incrementCounter('db_queries_success', 1);\n    } else {\n      this.metrics.incrementCounter('db_queries_failed', 1);\n    }\n  }\n\n  /**\n   * Record cache hit/miss\n   */\n  recordCacheOperation(hit: boolean, duration: number): void {\n    this.metrics.recordMetric('cache_operation_duration_ms', duration, 'ms', {\n      hit: hit.toString(),\n    });\n\n    if (hit) {\n      this.metrics.incrementCounter('cache_hits', 1);\n    } else {\n      this.metrics.incrementCounter('cache_misses', 1);\n    }\n  }\n\n  /**\n   * Get request stats\n   */\n  getRequestStats(path: string, method: string): {\n    count: number;\n    avgDuration: number;\n    minDuration: number;\n    maxDuration: number;\n  } | null {\n    const key = `${method}:${path}`;\n    const durations = this.requestDurations.get(key);\n\n    if (!durations || durations.length === 0) return null;\n\n    const sum = durations.reduce((a, b) => a + b, 0);\n\n    return {\n      count: durations.length,\n      avgDuration: sum / durations.length,\n      minDuration: Math.min(...durations),\n      maxDuration: Math.max(...durations),\n    };\n  }\n}\n\n/**\n * Logger\n */\nexport class Logger {\n  private logs: Array<{ level: string; message: string; timestamp: number; data?: any }> = [];\n  private maxLogs: number = 10000;\n\n  /**\n   * Log message\n   */\n  private log(level: string, message: string, data?: any): void {\n    const entry = {\n      level,\n      message,\n      timestamp: Date.now(),\n      data,\n    };\n\n    this.logs.push(entry);\n\n    // Keep only recent logs\n    if (this.logs.length > this.maxLogs) {\n      this.logs.shift();\n    }\n\n    console.log(`[${level}] ${message}`, data || '');\n  }\n\n  /**\n   * Log info\n   */\n  info(message: string, data?: any): void {\n    this.log('INFO', message, data);\n  }\n\n  /**\n   * Log warning\n   */\n  warn(message: string, data?: any): void {\n    this.log('WARN', message, data);\n  }\n\n  /**\n   * Log error\n   */\n  error(message: string, data?: any): void {\n    this.log('ERROR', message, data);\n  }\n\n  /**\n   * Log debug\n   */\n  debug(message: string, data?: any): void {\n    this.log('DEBUG', message, data);\n  }\n\n  /**\n   * Get logs\n   */\n  getLogs(level?: string, limit: number = 100): Array<any> {\n    let filtered = this.logs;\n\n    if (level) {\n      filtered = filtered.filter((l) => l.level === level);\n    }\n\n    return filtered.slice(-limit);\n  }\n\n  /**\n   * Clear logs\n   */\n  clearLogs(): void {\n    this.logs = [];\n  }\n}\n
