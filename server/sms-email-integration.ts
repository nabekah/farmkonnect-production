import { EventEmitter } from 'events';\n\nexport type MessageChannel = 'sms' | 'email' | 'both';\nexport type DeliveryStatus = 'pending' | 'sent' | 'delivered' | 'failed' | 'bounced' | 'unsubscribed';\nexport type MessagePriority = 'low' | 'normal' | 'high' | 'urgent';\n\nexport interface SMSMessage {\n  id: string;\n  phoneNumber: string;\n  content: string;\n  status: DeliveryStatus;\n  sentAt?: number;\n  deliveredAt?: number;\n  failureReason?: string;\n  externalId?: string; // Twilio SID\n  metadata?: Record<string, any>;\n}\n\nexport interface EmailMessage {\n  id: string;\n  toAddress: string;\n  subject: string;\n  htmlContent: string;\n  textContent?: string;\n  status: DeliveryStatus;\n  sentAt?: number;\n  deliveredAt?: number;\n  openedAt?: number;\n  clickedAt?: number;\n  failureReason?: string;\n  externalId?: string; // SendGrid message ID\n  attachments?: Array<{ filename: string; content: string; contentType: string }>;\n  metadata?: Record<string, any>;\n}\n\nexport interface MessageTemplate {\n  id: string;\n  name: string;\n  channel: MessageChannel;\n  smsTemplate?: string;\n  emailSubject?: string;\n  emailTemplate?: string;\n  variables: string[];\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface MessageQueue {\n  id: string;\n  userId: string;\n  channel: MessageChannel;\n  templateId: string;\n  variables: Record<string, string>;\n  priority: MessagePriority;\n  scheduledFor?: number;\n  status: 'queued' | 'processing' | 'sent' | 'failed';\n  createdAt: number;\n  processedAt?: number;\n}\n\nexport interface ChannelPreference {\n  userId: string;\n  preferredChannels: MessageChannel[];\n  smsOptIn: boolean;\n  emailOptIn: boolean;\n  phoneNumber?: string;\n  emailAddress?: string;\n  doNotDisturbStart?: number; // hour (0-23)\n  doNotDisturbEnd?: number; // hour (0-23)\n}\n\nexport interface DeliveryMetrics {\n  totalSent: number;\n  totalDelivered: number;\n  totalFailed: number;\n  totalBounced: number;\n  smsSent: number;\n  smsDelivered: number;\n  smsFailed: number;\n  emailSent: number;\n  emailDelivered: number;\n  emailFailed: number;\n  emailOpened: number;\n  emailClicked: number;\n  averageDeliveryTime: number;\n  deliveryRate: number;\n}\n\nclass SMSEmailIntegrationLayer extends EventEmitter {\n  private smsMessages: Map<string, SMSMessage> = new Map();\n  private emailMessages: Map<string, EmailMessage> = new Map();\n  private templates: Map<string, MessageTemplate> = new Map();\n  private messageQueue: MessageQueue[] = [];\n  private channelPreferences: Map<string, ChannelPreference> = new Map();\n  private metrics: DeliveryMetrics = {\n    totalSent: 0,\n    totalDelivered: 0,\n    totalFailed: 0,\n    totalBounced: 0,\n    smsSent: 0,\n    smsDelivered: 0,\n    smsFailed: 0,\n    emailSent: 0,\n    emailDelivered: 0,\n    emailFailed: 0,\n    emailOpened: 0,\n    emailClicked: 0,\n    averageDeliveryTime: 0,\n    deliveryRate: 0,\n  };\n  private deliveryTimes: number[] = [];\n  private processingInterval: NodeJS.Timeout | null = null;\n  private twilioAccountSid: string = process.env.TWILIO_ACCOUNT_SID || 'mock-sid';\n  private twilioAuthToken: string = process.env.TWILIO_AUTH_TOKEN || 'mock-token';\n  private twilioPhoneNumber: string = process.env.TWILIO_PHONE_NUMBER || '+1234567890';\n  private sendgridApiKey: string = process.env.SENDGRID_API_KEY || 'mock-key';\n  private sendgridFromEmail: string = 'noreply@farmkonnect.com';\n\n  constructor() {\n    super();\n    this.startQueueProcessor();\n  }\n\n  /**\n   * Create message template\n   */\n  createTemplate(\n    name: string,\n    channel: MessageChannel,\n    options?: {\n      smsTemplate?: string;\n      emailSubject?: string;\n      emailTemplate?: string;\n    }\n  ): MessageTemplate {\n    const variables: string[] = [];\n\n    // Extract variables from templates\n    const extractVariables = (text: string): string[] => {\n      const matches = text.match(/{{(\\w+)}}/g) || [];\n      return matches.map((m) => m.replace(/[{}]/g, ''));\n    };\n\n    if (options?.smsTemplate) {\n      variables.push(...extractVariables(options.smsTemplate));\n    }\n    if (options?.emailTemplate) {\n      variables.push(...extractVariables(options.emailTemplate));\n    }\n\n    const template: MessageTemplate = {\n      id: `tpl-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      channel,\n      smsTemplate: options?.smsTemplate,\n      emailSubject: options?.emailSubject,\n      emailTemplate: options?.emailTemplate,\n      variables: [...new Set(variables)],\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.templates.set(template.id, template);\n    this.emit('template:created', template);\n    return template;\n  }\n\n  /**\n   * Set channel preference\n   */\n  setChannelPreference(\n    userId: string,\n    options: Partial<ChannelPreference>\n  ): ChannelPreference {\n    const preference: ChannelPreference = {\n      userId,\n      preferredChannels: options.preferredChannels || ['email'],\n      smsOptIn: options.smsOptIn ?? false,\n      emailOptIn: options.emailOptIn ?? true,\n      phoneNumber: options.phoneNumber,\n      emailAddress: options.emailAddress,\n      doNotDisturbStart: options.doNotDisturbStart,\n      doNotDisturbEnd: options.doNotDisturbEnd,\n    };\n\n    this.channelPreferences.set(userId, preference);\n    this.emit('preference:updated', preference);\n    return preference;\n  }\n\n  /**\n   * Get channel preference\n   */\n  getChannelPreference(userId: string): ChannelPreference | undefined {\n    return this.channelPreferences.get(userId);\n  }\n\n  /**\n   * Send SMS\n   */\n  async sendSMS(\n    phoneNumber: string,\n    content: string,\n    metadata?: Record<string, any>\n  ): Promise<SMSMessage> {\n    // Validate phone number\n    if (!phoneNumber.match(/^\\+?[1-9]\\d{1,14}$/)) {\n      throw new Error('Invalid phone number format');\n    }\n\n    const message: SMSMessage = {\n      id: `sms-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      phoneNumber,\n      content,\n      status: 'pending',\n      metadata,\n    };\n\n    // Simulate Twilio API call\n    try {\n      // In production, this would call Twilio API\n      const externalId = `SM${Math.random().toString(36).substr(2, 9).toUpperCase()}`;\n      message.externalId = externalId;\n      message.status = 'sent';\n      message.sentAt = Date.now();\n\n      // Simulate delivery\n      setTimeout(() => {\n        if (Math.random() > 0.05) { // 95% delivery rate\n          message.status = 'delivered';\n          message.deliveredAt = Date.now();\n          this.metrics.smsDelivered++;\n          this.emit('sms:delivered', message);\n        } else {\n          message.status = 'failed';\n          message.failureReason = 'Simulated delivery failure';\n          this.metrics.smsFailed++;\n          this.emit('sms:failed', message);\n        }\n      }, Math.random() * 5000 + 1000);\n\n      this.smsMessages.set(message.id, message);\n      this.metrics.smsSent++;\n      this.metrics.totalSent++;\n\n      this.emit('sms:sent', message);\n      return message;\n    } catch (error) {\n      message.status = 'failed';\n      message.failureReason = error instanceof Error ? error.message : 'Unknown error';\n      this.metrics.smsFailed++;\n      this.emit('sms:failed', message);\n      throw error;\n    }\n  }\n\n  /**\n   * Send email\n   */\n  async sendEmail(\n    toAddress: string,\n    subject: string,\n    htmlContent: string,\n    options?: {\n      textContent?: string;\n      attachments?: Array<{ filename: string; content: string; contentType: string }>;\n      metadata?: Record<string, any>;\n    }\n  ): Promise<EmailMessage> {\n    // Validate email\n    if (!toAddress.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)) {\n      throw new Error('Invalid email address');\n    }\n\n    const message: EmailMessage = {\n      id: `email-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      toAddress,\n      subject,\n      htmlContent,\n      textContent: options?.textContent,\n      status: 'pending',\n      attachments: options?.attachments,\n      metadata: options?.metadata,\n    };\n\n    try {\n      // Simulate SendGrid API call\n      const externalId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      message.externalId = externalId;\n      message.status = 'sent';\n      message.sentAt = Date.now();\n\n      // Simulate delivery\n      setTimeout(() => {\n        if (Math.random() > 0.03) { // 97% delivery rate\n          message.status = 'delivered';\n          message.deliveredAt = Date.now();\n          this.metrics.emailDelivered++;\n\n          // Simulate open/click\n          setTimeout(() => {\n            if (Math.random() > 0.6) { // 40% open rate\n              message.openedAt = Date.now();\n              this.metrics.emailOpened++;\n              this.emit('email:opened', message);\n\n              if (Math.random() > 0.7) { // 30% click rate\n                message.clickedAt = Date.now();\n                this.metrics.emailClicked++;\n                this.emit('email:clicked', message);\n              }\n            }\n          }, Math.random() * 300000 + 60000); // 1-6 minutes\n\n          this.emit('email:delivered', message);\n        } else {\n          message.status = 'bounced';\n          message.failureReason = 'Simulated bounce';\n          this.metrics.emailFailed++;\n          this.metrics.totalBounced++;\n          this.emit('email:bounced', message);\n        }\n      }, Math.random() * 3000 + 500);\n\n      this.emailMessages.set(message.id, message);\n      this.metrics.emailSent++;\n      this.metrics.totalSent++;\n\n      this.emit('email:sent', message);\n      return message;\n    } catch (error) {\n      message.status = 'failed';\n      message.failureReason = error instanceof Error ? error.message : 'Unknown error';\n      this.metrics.emailFailed++;\n      this.emit('email:failed', message);\n      throw error;\n    }\n  }\n\n  /**\n   * Queue message\n   */\n  queueMessage(\n    userId: string,\n    templateId: string,\n    variables: Record<string, string>,\n    options?: {\n      channel?: MessageChannel;\n      priority?: MessagePriority;\n      scheduledFor?: number;\n    }\n  ): MessageQueue {\n    const template = this.templates.get(templateId);\n    if (!template) {\n      throw new Error('Template not found');\n    }\n\n    const queueItem: MessageQueue = {\n      id: `queue-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      channel: options?.channel || template.channel,\n      templateId,\n      variables,\n      priority: options?.priority || 'normal',\n      scheduledFor: options?.scheduledFor,\n      status: 'queued',\n      createdAt: Date.now(),\n    };\n\n    this.messageQueue.push(queueItem);\n    this.emit('message:queued', queueItem);\n    return queueItem;\n  }\n\n  /**\n   * Start queue processor\n   */\n  private startQueueProcessor(): void {\n    this.processingInterval = setInterval(() => {\n      this.processQueue();\n    }, 5000); // Process every 5 seconds\n  }\n\n  /**\n   * Process message queue\n   */\n  private async processQueue(): Promise<void> {\n    const now = Date.now();\n    const toProcess: MessageQueue[] = [];\n\n    for (let i = this.messageQueue.length - 1; i >= 0; i--) {\n      const item = this.messageQueue[i];\n      if (item.status === 'queued' && (!item.scheduledFor || item.scheduledFor <= now)) {\n        toProcess.push(item);\n        this.messageQueue.splice(i, 1);\n      }\n    }\n\n    for (const item of toProcess) {\n      item.status = 'processing';\n\n      try {\n        const template = this.templates.get(item.templateId);\n        if (!template) continue;\n\n        const preference = this.channelPreferences.get(item.userId);\n\n        // Check do-not-disturb\n        if (preference?.doNotDisturbStart !== undefined && preference?.doNotDisturbEnd !== undefined) {\n          const hour = new Date().getHours();\n          if (hour >= preference.doNotDisturbStart && hour < preference.doNotDisturbEnd) {\n            item.status = 'queued';\n            item.scheduledFor = now + 60 * 60 * 1000; // Reschedule for 1 hour later\n            this.messageQueue.push(item);\n            continue;\n          }\n        }\n\n        // Send based on channel\n        if (item.channel === 'sms' || item.channel === 'both') {\n          if (preference?.smsOptIn && preference?.phoneNumber && template.smsTemplate) {\n            const content = this.renderTemplate(template.smsTemplate, item.variables);\n            await this.sendSMS(preference.phoneNumber, content, { queueId: item.id });\n          }\n        }\n\n        if (item.channel === 'email' || item.channel === 'both') {\n          if (preference?.emailOptIn && preference?.emailAddress && template.emailTemplate) {\n            const htmlContent = this.renderTemplate(template.emailTemplate, item.variables);\n            const subject = template.emailSubject ? this.renderTemplate(template.emailSubject, item.variables) : 'Notification';\n            await this.sendEmail(preference.emailAddress, subject, htmlContent, { metadata: { queueId: item.id } });\n          }\n        }\n\n        item.status = 'sent';\n        item.processedAt = Date.now();\n        this.emit('message:processed', item);\n      } catch (error) {\n        item.status = 'failed';\n        this.emit('message:failed', { item, error });\n      }\n    }\n  }\n\n  /**\n   * Render template\n   */\n  private renderTemplate(template: string, variables: Record<string, string>): string {\n    let result = template;\n    for (const [key, value] of Object.entries(variables)) {\n      result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);\n    }\n    return result;\n  }\n\n  /**\n   * Get SMS message\n   */\n  getSMSMessage(messageId: string): SMSMessage | undefined {\n    return this.smsMessages.get(messageId);\n  }\n\n  /**\n   * Get email message\n   */\n  getEmailMessage(messageId: string): EmailMessage | undefined {\n    return this.emailMessages.get(messageId);\n  }\n\n  /**\n   * Get queue status\n   */\n  getQueueStatus(): { queueLength: number; processing: number } {\n    const processing = this.messageQueue.filter((m) => m.status === 'processing').length;\n    return {\n      queueLength: this.messageQueue.length,\n      processing,\n    };\n  }\n\n  /**\n   * Update metrics\n   */\n  private updateMetrics(): void {\n    if (this.deliveryTimes.length > 0) {\n      this.metrics.averageDeliveryTime =\n        this.deliveryTimes.reduce((a, b) => a + b, 0) / this.deliveryTimes.length;\n    }\n\n    const totalDelivered = this.metrics.smsDelivered + this.metrics.emailDelivered;\n    const totalAttempted = this.metrics.totalSent;\n    this.metrics.deliveryRate = totalAttempted > 0 ? (totalDelivered / totalAttempted) * 100 : 0;\n    this.metrics.totalDelivered = totalDelivered;\n    this.metrics.totalFailed = this.metrics.smsFailed + this.metrics.emailFailed;\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics(): DeliveryMetrics {\n    this.updateMetrics();\n    return { ...this.metrics };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval);\n    }\n  }\n}\n\nexport default SMSEmailIntegrationLayer;\n
