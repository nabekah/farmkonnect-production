import { EventEmitter } from 'events';\n\nexport type MessageType =\n  | 'notification'\n  | 'metric_update'\n  | 'alert'\n  | 'sync_status'\n  | 'user_activity'\n  | 'system_event'\n  | 'presence'\n  | 'collaboration'\n  | 'heartbeat'\n  | 'error';\n\nexport type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'reconnecting' | 'error';\n\nexport interface WebSocketMessage {\n  id: string;\n  type: MessageType;\n  userId: string;\n  payload: any;\n  timestamp: number;\n  priority?: 'low' | 'normal' | 'high' | 'critical';\n  requiresAck?: boolean;\n}\n\nexport interface WebSocketConnection {\n  id: string;\n  userId: string;\n  status: ConnectionStatus;\n  connectedAt: number;\n  lastHeartbeat: number;\n  messageCount: number;\n  bytesReceived: number;\n  bytesSent: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface WebSocketSubscription {\n  id: string;\n  userId: string;\n  channel: string;\n  filters?: Record<string, any>;\n  subscribedAt: number;\n}\n\nexport interface WebSocketStatistics {\n  totalConnections: number;\n  activeConnections: number;\n  totalMessages: number;\n  messageRate: number;\n  averageLatency: number;\n  p95Latency: number;\n  p99Latency: number;\n  errorRate: number;\n  uptime: number;\n}\n\nclass WebSocketLayer extends EventEmitter {\n  private connections: Map<string, WebSocketConnection> = new Map();\n  private subscriptions: Map<string, Set<WebSocketSubscription>> = new Map();\n  private messageQueue: WebSocketMessage[] = [];\n  private messageHistory: Map<string, WebSocketMessage[]> = new Map();\n  private latencies: number[] = [];\n  private startTime: number = Date.now();\n  private statistics: WebSocketStatistics = {\n    totalConnections: 0,\n    activeConnections: 0,\n    totalMessages: 0,\n    messageRate: 0,\n    averageLatency: 0,\n    p95Latency: 0,\n    p99Latency: 0,\n    errorRate: 0,\n    uptime: 0,\n  };\n  private messageRateWindow: number[] = [];\n  private heartbeatInterval: number = 30000; // 30 seconds\n  private reconnectAttempts: Map<string, number> = new Map();\n  private maxReconnectAttempts: number = 5;\n  private maxHistoryPerUser: number = 1000;\n\n  constructor() {\n    super();\n    this.startHeartbeat();\n    this.startCleanup();\n  }\n\n  /**\n   * Create new WebSocket connection\n   */\n  createConnection(userId: string, metadata?: Record<string, any>): WebSocketConnection {\n    const connection: WebSocketConnection = {\n      id: `ws-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      status: 'connected',\n      connectedAt: Date.now(),\n      lastHeartbeat: Date.now(),\n      messageCount: 0,\n      bytesReceived: 0,\n      bytesSent: 0,\n      metadata,\n    };\n\n    this.connections.set(connection.id, connection);\n    this.statistics.totalConnections++;\n    this.reconnectAttempts.delete(userId);\n\n    this.emit('connection:created', connection);\n    return connection;\n  }\n\n  /**\n   * Close connection\n   */\n  closeConnection(connectionId: string, reason?: string): boolean {\n    const connection = this.connections.get(connectionId);\n    if (!connection) return false;\n\n    connection.status = 'disconnected';\n    this.connections.delete(connectionId);\n\n    // Clean up subscriptions\n    const userSubscriptions = this.subscriptions.get(connection.userId);\n    if (userSubscriptions) {\n      userSubscriptions.forEach((sub) => {\n        if (sub.id === connectionId) {\n          userSubscriptions.delete(sub);\n        }\n      });\n    }\n\n    this.emit('connection:closed', { connectionId, userId: connection.userId, reason });\n    return true;\n  }\n\n  /**\n   * Send message to user\n   */\n  async sendMessage(\n    userId: string,\n    type: MessageType,\n    payload: any,\n    options?: {\n      priority?: 'low' | 'normal' | 'high' | 'critical';\n      requiresAck?: boolean;\n      connectionId?: string;\n    }\n  ): Promise<WebSocketMessage> {\n    const message: WebSocketMessage = {\n      id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      type,\n      userId,\n      payload,\n      timestamp: Date.now(),\n      priority: options?.priority || 'normal',\n      requiresAck: options?.requiresAck || false,\n    };\n\n    // Add to history\n    if (!this.messageHistory.has(userId)) {\n      this.messageHistory.set(userId, []);\n    }\n    const history = this.messageHistory.get(userId)!;\n    history.push(message);\n    if (history.length > this.maxHistoryPerUser) {\n      history.shift();\n    }\n\n    // Queue message\n    this.messageQueue.push(message);\n    this.statistics.totalMessages++;\n\n    // Update message rate\n    this.messageRateWindow.push(Date.now());\n    if (this.messageRateWindow.length > 1000) {\n      this.messageRateWindow.shift();\n    }\n\n    // Send to connection\n    const connection = this.getConnectionForUser(userId, options?.connectionId);\n    if (connection) {\n      connection.messageCount++;\n      connection.bytesSent += JSON.stringify(message).length;\n      this.emit('message:sent', message);\n    } else {\n      this.emit('message:queued', message);\n    }\n\n    return message;\n  }\n\n  /**\n   * Broadcast message to multiple users\n   */\n  async broadcastMessage(\n    userIds: string[],\n    type: MessageType,\n    payload: any,\n    options?: any\n  ): Promise<WebSocketMessage[]> {\n    const messages: WebSocketMessage[] = [];\n\n    for (const userId of userIds) {\n      const message = await this.sendMessage(userId, type, payload, options);\n      messages.push(message);\n    }\n\n    this.emit('broadcast:sent', { count: messages.length, type });\n    return messages;\n  }\n\n  /**\n   * Subscribe to channel\n   */\n  subscribe(\n    userId: string,\n    channel: string,\n    filters?: Record<string, any>\n  ): WebSocketSubscription {\n    if (!this.subscriptions.has(userId)) {\n      this.subscriptions.set(userId, new Set());\n    }\n\n    const subscription: WebSocketSubscription = {\n      id: `sub-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      channel,\n      filters,\n      subscribedAt: Date.now(),\n    };\n\n    this.subscriptions.get(userId)!.add(subscription);\n    this.emit('subscription:created', subscription);\n\n    return subscription;\n  }\n\n  /**\n   * Unsubscribe from channel\n   */\n  unsubscribe(userId: string, subscriptionId: string): boolean {\n    const userSubscriptions = this.subscriptions.get(userId);\n    if (!userSubscriptions) return false;\n\n    for (const sub of userSubscriptions) {\n      if (sub.id === subscriptionId) {\n        userSubscriptions.delete(sub);\n        this.emit('subscription:removed', { userId, subscriptionId });\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get subscriptions for user\n   */\n  getSubscriptions(userId: string): WebSocketSubscription[] {\n    const subs = this.subscriptions.get(userId);\n    return subs ? Array.from(subs) : [];\n  }\n\n  /**\n   * Publish to channel\n   */\n  async publishToChannel(\n    channel: string,\n    type: MessageType,\n    payload: any,\n    filters?: Record<string, any>\n  ): Promise<number> {\n    let messageCount = 0;\n\n    for (const [userId, subscriptions] of this.subscriptions.entries()) {\n      for (const sub of subscriptions) {\n        if (sub.channel === channel) {\n          // Check filters\n          if (filters && sub.filters) {\n            const matches = this.matchFilters(sub.filters, filters);\n            if (!matches) continue;\n          }\n\n          await this.sendMessage(userId, type, payload);\n          messageCount++;\n        }\n      }\n    }\n\n    this.emit('channel:published', { channel, messageCount });\n    return messageCount;\n  }\n\n  /**\n   * Match filters\n   */\n  private matchFilters(subscriptionFilters: Record<string, any>, messageFilters: Record<string, any>): boolean {\n    for (const [key, value] of Object.entries(subscriptionFilters)) {\n      if (messageFilters[key] !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get connection for user\n   */\n  private getConnectionForUser(userId: string, preferredConnectionId?: string): WebSocketConnection | null {\n    if (preferredConnectionId) {\n      const conn = this.connections.get(preferredConnectionId);\n      if (conn && conn.userId === userId && conn.status === 'connected') {\n        return conn;\n      }\n    }\n\n    for (const conn of this.connections.values()) {\n      if (conn.userId === userId && conn.status === 'connected') {\n        return conn;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Record latency\n   */\n  recordLatency(duration: number): void {\n    this.latencies.push(duration);\n\n    if (this.latencies.length > 10000) {\n      this.latencies.shift();\n    }\n\n    this.updateStatistics();\n  }\n\n  /**\n   * Acknowledge message\n   */\n  acknowledgeMessage(messageId: string, userId: string): boolean {\n    const history = this.messageHistory.get(userId);\n    if (!history) return false;\n\n    const message = history.find((m) => m.id === messageId);\n    if (!message) return false;\n\n    this.emit('message:acknowledged', { messageId, userId });\n    return true;\n  }\n\n  /**\n   * Get message history\n   */\n  getMessageHistory(userId: string, limit: number = 100): WebSocketMessage[] {\n    const history = this.messageHistory.get(userId) || [];\n    return history.slice(-limit);\n  }\n\n  /**\n   * Get connection info\n   */\n  getConnection(connectionId: string): WebSocketConnection | undefined {\n    return this.connections.get(connectionId);\n  }\n\n  /**\n   * Get user connections\n   */\n  getUserConnections(userId: string): WebSocketConnection[] {\n    const userConnections: WebSocketConnection[] = [];\n\n    for (const conn of this.connections.values()) {\n      if (conn.userId === userId) {\n        userConnections.push(conn);\n      }\n    }\n\n    return userConnections;\n  }\n\n  /**\n   * Start heartbeat\n   */\n  private startHeartbeat(): void {\n    setInterval(() => {\n      const now = Date.now();\n\n      for (const [connId, conn] of this.connections.entries()) {\n        if (now - conn.lastHeartbeat > this.heartbeatInterval * 2) {\n          // Connection is stale\n          this.closeConnection(connId, 'heartbeat_timeout');\n        } else if (conn.status === 'connected') {\n          // Send heartbeat\n          this.sendMessage(conn.userId, 'heartbeat', { timestamp: now }, {\n            priority: 'low',\n          });\n          conn.lastHeartbeat = now;\n        }\n      }\n    }, this.heartbeatInterval);\n  }\n\n  /**\n   * Start cleanup\n   */\n  private startCleanup(): void {\n    setInterval(() => {\n      const now = Date.now();\n      let cleaned = 0;\n\n      // Clean up old message history\n      for (const [userId, history] of this.messageHistory.entries()) {\n        const filtered = history.filter((m) => now - m.timestamp < 24 * 60 * 60 * 1000); // Keep 24 hours\n        if (filtered.length < history.length) {\n          this.messageHistory.set(userId, filtered);\n          cleaned++;\n        }\n      }\n\n      if (cleaned > 0) {\n        this.emit('cleanup:completed', { historiesCleanedUp: cleaned });\n      }\n    }, 60 * 60 * 1000); // Run every hour\n  }\n\n  /**\n   * Update statistics\n   */\n  private updateStatistics(): void {\n    this.statistics.activeConnections = Array.from(this.connections.values()).filter(\n      (c) => c.status === 'connected'\n    ).length;\n\n    // Calculate message rate (messages per second)\n    const now = Date.now();\n    const oneSecondAgo = now - 1000;\n    const recentMessages = this.messageRateWindow.filter((t) => t > oneSecondAgo);\n    this.statistics.messageRate = recentMessages.length;\n\n    // Calculate latencies\n    if (this.latencies.length > 0) {\n      const sorted = [...this.latencies].sort((a, b) => a - b);\n      this.statistics.averageLatency = sorted.reduce((a, b) => a + b, 0) / sorted.length;\n      this.statistics.p95Latency = sorted[Math.floor(sorted.length * 0.95)];\n      this.statistics.p99Latency = sorted[Math.floor(sorted.length * 0.99)];\n    }\n\n    this.statistics.uptime = Date.now() - this.startTime;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): WebSocketStatistics {\n    this.updateStatistics();\n    return { ...this.statistics };\n  }\n\n  /**\n   * Get queue status\n   */\n  getQueueStatus(): { queueLength: number; oldestMessageAge: number } {\n    if (this.messageQueue.length === 0) {\n      return { queueLength: 0, oldestMessageAge: 0 };\n    }\n\n    const oldestMessage = this.messageQueue[0];\n    return {\n      queueLength: this.messageQueue.length,\n      oldestMessageAge: Date.now() - oldestMessage.timestamp,\n    };\n  }\n\n  /**\n   * Process message queue\n   */\n  processQueue(): number {\n    let processed = 0;\n\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue.shift();\n      if (message) {\n        this.emit('queue:processed', message);\n        processed++;\n      }\n    }\n\n    return processed;\n  }\n\n  /**\n   * Simulate message reception\n   */\n  receiveMessage(connectionId: string, data: any): void {\n    const connection = this.connections.get(connectionId);\n    if (!connection) return;\n\n    connection.bytesReceived += JSON.stringify(data).length;\n    this.emit('message:received', { connectionId, data, userId: connection.userId });\n  }\n\n  /**\n   * Get active connections count\n   */\n  getActiveConnectionsCount(): number {\n    return Array.from(this.connections.values()).filter((c) => c.status === 'connected').length;\n  }\n\n  /**\n   * Reconnect user\n   */\n  reconnectUser(userId: string): boolean {\n    const attempts = this.reconnectAttempts.get(userId) || 0;\n\n    if (attempts >= this.maxReconnectAttempts) {\n      this.emit('reconnect:failed', { userId, reason: 'max_attempts_exceeded' });\n      return false;\n    }\n\n    this.reconnectAttempts.set(userId, attempts + 1);\n    this.emit('reconnect:attempted', { userId, attempt: attempts + 1 });\n\n    return true;\n  }\n\n  /**\n   * Clear all connections\n   */\n  clearConnections(): void {\n    this.connections.clear();\n    this.subscriptions.clear();\n    this.messageQueue = [];\n    this.messageHistory.clear();\n    this.emit('connections:cleared');\n  }\n}\n\nexport default WebSocketLayer;\n
