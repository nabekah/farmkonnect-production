import { EventEmitter } from 'events';\n\nexport type TemplateType = 'email' | 'sms' | 'push' | 'in_app' | 'webhook';\nexport type ConditionType = 'if' | 'if_else' | 'switch';\nexport type VariableType = 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object';\n\nexport interface TemplateVariable {\n  name: string;\n  type: VariableType;\n  required: boolean;\n  defaultValue?: any;\n  description?: string;\n}\n\nexport interface ConditionalBlock {\n  id: string;\n  type: ConditionType;\n  condition: string; // JavaScript expression\n  trueContent: string;\n  falseContent?: string;\n}\n\nexport interface NotificationTemplate {\n  id: string;\n  name: string;\n  description: string;\n  type: TemplateType;\n  language: string; // e.g., 'en', 'es', 'fr'\n  subject?: string; // For email\n  body: string;\n  variables: TemplateVariable[];\n  conditionals: ConditionalBlock[];\n  metadata?: Record<string, any>;\n  createdAt: number;\n  updatedAt: number;\n  createdBy: string;\n  isActive: boolean;\n  version: number;\n}\n\nexport interface TemplateVersion {\n  id: string;\n  templateId: string;\n  version: number;\n  content: NotificationTemplate;\n  createdAt: number;\n  createdBy: string;\n}\n\nexport interface RenderedTemplate {\n  id: string;\n  templateId: string;\n  subject?: string;\n  body: string;\n  renderedAt: number;\n}\n\nexport interface TemplateStatistics {\n  totalTemplates: number;\n  activeTemplates: number;\n  byType: Record<TemplateType, number>;\n  byLanguage: Record<string, number>;\n  totalVersions: number;\n  mostUsedTemplate: { name: string; usageCount: number };\n}\n\nclass NotificationTemplateBuilder extends EventEmitter {\n  private templates: Map<string, NotificationTemplate> = new Map();\n  private versions: Map<string, TemplateVersion[]> = new Map(); // templateId -> versions\n  private usageCount: Map<string, number> = new Map();\n  private renderCache: Map<string, RenderedTemplate> = new Map();\n  private cacheTTL: number = 10 * 60 * 1000; // 10 minutes\n  private cacheExpiry: Map<string, number> = new Map();\n  private statistics: TemplateStatistics = {\n    totalTemplates: 0,\n    activeTemplates: 0,\n    byType: { email: 0, sms: 0, push: 0, in_app: 0, webhook: 0 },\n    byLanguage: {},\n    totalVersions: 0,\n    mostUsedTemplate: { name: '', usageCount: 0 },\n  };\n\n  constructor() {\n    super();\n    this.startCacheCleanup();\n  }\n\n  /**\n   * Create template\n   */\n  createTemplate(\n    name: string,\n    description: string,\n    type: TemplateType,\n    body: string,\n    createdBy: string,\n    options?: {\n      language?: string;\n      subject?: string;\n      variables?: TemplateVariable[];\n      conditionals?: ConditionalBlock[];\n      metadata?: Record<string, any>;\n    }\n  ): NotificationTemplate {\n    const template: NotificationTemplate = {\n      id: `tpl-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      description,\n      type,\n      language: options?.language || 'en',\n      subject: options?.subject,\n      body,\n      variables: options?.variables || [],\n      conditionals: options?.conditionals || [],\n      metadata: options?.metadata,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      createdBy,\n      isActive: true,\n      version: 1,\n    };\n\n    this.templates.set(template.id, template);\n    this.versions.set(template.id, [\n      {\n        id: `v-${Date.now()}-1`,\n        templateId: template.id,\n        version: 1,\n        content: JSON.parse(JSON.stringify(template)),\n        createdAt: Date.now(),\n        createdBy,\n      },\n    ]);\n\n    this.statistics.totalTemplates++;\n    this.statistics.activeTemplates++;\n    this.statistics.byType[type]++;\n    this.statistics.byLanguage[template.language] = (this.statistics.byLanguage[template.language] || 0) + 1;\n    this.statistics.totalVersions++;\n\n    this.emit('template:created', template);\n    return template;\n  }\n\n  /**\n   * Update template\n   */\n  updateTemplate(templateId: string, updates: Partial<NotificationTemplate>, updatedBy: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    // Create new version\n    const newVersion = template.version + 1;\n    const updatedTemplate: NotificationTemplate = {\n      ...template,\n      ...updates,\n      version: newVersion,\n      updatedAt: Date.now(),\n    };\n\n    // Store old version\n    const templateVersions = this.versions.get(templateId) || [];\n    templateVersions.push({\n      id: `v-${Date.now()}-${newVersion}`,\n      templateId,\n      version: template.version,\n      content: JSON.parse(JSON.stringify(template)),\n      createdAt: Date.now(),\n      createdBy: updatedBy,\n    });\n    this.versions.set(templateId, templateVersions);\n\n    this.templates.set(templateId, updatedTemplate);\n    this.statistics.totalVersions++;\n    this.invalidateCache(templateId);\n\n    this.emit('template:updated', { templateId, newVersion });\n    return true;\n  }\n\n  /**\n   * Render template\n   */\n  renderTemplate(templateId: string, variables: Record<string, any>): RenderedTemplate | null {\n    const template = this.templates.get(templateId);\n    if (!template || !template.isActive) return null;\n\n    // Check cache\n    const cacheKey = `${templateId}:${JSON.stringify(variables)}`;\n    const cached = this.renderCache.get(cacheKey);\n    if (cached && this.cacheExpiry.get(cacheKey)! > Date.now()) {\n      return cached;\n    }\n\n    try {\n      let body = template.body;\n      let subject = template.subject || '';\n\n      // Replace variables\n      for (const variable of template.variables) {\n        const value = variables[variable.name];\n        if (value !== undefined) {\n          const regex = new RegExp(`{{\\s*${variable.name}\\s*}}`, 'g');\n          const stringValue = this.formatValue(value, variable.type);\n          body = body.replace(regex, stringValue);\n          subject = subject.replace(regex, stringValue);\n        } else if (variable.required) {\n          throw new Error(`Missing required variable: ${variable.name}`);\n        } else if (variable.defaultValue !== undefined) {\n          const regex = new RegExp(`{{\\s*${variable.name}\\s*}}`, 'g');\n          const stringValue = this.formatValue(variable.defaultValue, variable.type);\n          body = body.replace(regex, stringValue);\n          subject = subject.replace(regex, stringValue);\n        }\n      }\n\n      // Process conditionals\n      for (const conditional of template.conditionals) {\n        body = this.processConditional(body, conditional, variables);\n      }\n\n      const rendered: RenderedTemplate = {\n        id: `render-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        templateId,\n        subject: subject || undefined,\n        body,\n        renderedAt: Date.now(),\n      };\n\n      // Cache result\n      this.renderCache.set(cacheKey, rendered);\n      this.cacheExpiry.set(cacheKey, Date.now() + this.cacheTTL);\n\n      // Track usage\n      this.usageCount.set(templateId, (this.usageCount.get(templateId) || 0) + 1);\n\n      this.emit('template:rendered', { templateId, renderedId: rendered.id });\n      return rendered;\n    } catch (error) {\n      this.emit('render:error', { templateId, error });\n      return null;\n    }\n  }\n\n  /**\n   * Format value based on type\n   */\n  private formatValue(value: any, type: VariableType): string {\n    switch (type) {\n      case 'date':\n        return new Date(value).toLocaleString();\n      case 'number':\n        return Number(value).toFixed(2);\n      case 'boolean':\n        return value ? 'Yes' : 'No';\n      case 'array':\n        return Array.isArray(value) ? value.join(', ') : String(value);\n      case 'object':\n        return JSON.stringify(value);\n      default:\n        return String(value);\n    }\n  }\n\n  /**\n   * Process conditional block\n   */\n  private processConditional(\n    content: string,\n    conditional: ConditionalBlock,\n    variables: Record<string, any>\n  ): string {\n    try {\n      // Create safe evaluation context\n      const context = { ...variables };\n      const conditionResult = this.evaluateCondition(conditional.condition, context);\n\n      const blockRegex = new RegExp(\n        `{{#${conditional.id}}}([\\\\s\\\\S]*?){{/\\\\s*${conditional.id}\\\\s*}}`,\n        'g'\n      );\n\n      if (conditionResult) {\n        return content.replace(blockRegex, conditional.trueContent);\n      } else if (conditional.falseContent) {\n        return content.replace(blockRegex, conditional.falseContent);\n      } else {\n        return content.replace(blockRegex, '');\n      }\n    } catch (error) {\n      return content;\n    }\n  }\n\n  /**\n   * Evaluate condition safely\n   */\n  private evaluateCondition(condition: string, context: Record<string, any>): boolean {\n    try {\n      // Create a safe function to evaluate the condition\n      const keys = Object.keys(context);\n      const values = Object.values(context);\n      const func = new Function(...keys, `return ${condition}`);\n      return Boolean(func(...values));\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Add variable to template\n   */\n  addVariable(templateId: string, variable: TemplateVariable): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    // Check if variable already exists\n    if (template.variables.some((v) => v.name === variable.name)) {\n      return false;\n    }\n\n    template.variables.push(variable);\n    template.updatedAt = Date.now();\n    this.invalidateCache(templateId);\n\n    this.emit('variable:added', { templateId, variable });\n    return true;\n  }\n\n  /**\n   * Remove variable from template\n   */\n  removeVariable(templateId: string, variableName: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    const index = template.variables.findIndex((v) => v.name === variableName);\n    if (index < 0) return false;\n\n    template.variables.splice(index, 1);\n    template.updatedAt = Date.now();\n    this.invalidateCache(templateId);\n\n    this.emit('variable:removed', { templateId, variableName });\n    return true;\n  }\n\n  /**\n   * Add conditional block\n   */\n  addConditional(templateId: string, conditional: ConditionalBlock): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    template.conditionals.push(conditional);\n    template.updatedAt = Date.now();\n    this.invalidateCache(templateId);\n\n    this.emit('conditional:added', { templateId, conditional });\n    return true;\n  }\n\n  /**\n   * Remove conditional block\n   */\n  removeConditional(templateId: string, conditionalId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    const index = template.conditionals.findIndex((c) => c.id === conditionalId);\n    if (index < 0) return false;\n\n    template.conditionals.splice(index, 1);\n    template.updatedAt = Date.now();\n    this.invalidateCache(templateId);\n\n    this.emit('conditional:removed', { templateId, conditionalId });\n    return true;\n  }\n\n  /**\n   * Get template\n   */\n  getTemplate(templateId: string): NotificationTemplate | undefined {\n    return this.templates.get(templateId);\n  }\n\n  /**\n   * List templates\n   */\n  listTemplates(type?: TemplateType, language?: string): NotificationTemplate[] {\n    const templates = Array.from(this.templates.values());\n\n    return templates.filter((t) => {\n      if (type && t.type !== type) return false;\n      if (language && t.language !== language) return false;\n      return true;\n    });\n  }\n\n  /**\n   * Get template versions\n   */\n  getTemplateVersions(templateId: string): TemplateVersion[] {\n    return this.versions.get(templateId) || [];\n  }\n\n  /**\n   * Restore template version\n   */\n  restoreVersion(templateId: string, version: number, restoredBy: string): boolean {\n    const versions = this.versions.get(templateId);\n    if (!versions) return false;\n\n    const versionToRestore = versions.find((v) => v.version === version);\n    if (!versionToRestore) return false;\n\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    // Create new version from old content\n    const restoredTemplate: NotificationTemplate = {\n      ...versionToRestore.content,\n      version: template.version + 1,\n      updatedAt: Date.now(),\n    };\n\n    this.updateTemplate(templateId, restoredTemplate, restoredBy);\n    this.emit('version:restored', { templateId, fromVersion: version, toVersion: restoredTemplate.version });\n\n    return true;\n  }\n\n  /**\n   * Duplicate template\n   */\n  duplicateTemplate(templateId: string, newName: string, createdBy: string): NotificationTemplate | null {\n    const original = this.templates.get(templateId);\n    if (!original) return null;\n\n    const duplicated = this.createTemplate(\n      newName,\n      `Duplicate of ${original.description}`,\n      original.type,\n      original.body,\n      createdBy,\n      {\n        language: original.language,\n        subject: original.subject,\n        variables: JSON.parse(JSON.stringify(original.variables)),\n        conditionals: JSON.parse(JSON.stringify(original.conditionals)),\n        metadata: { ...original.metadata, duplicatedFrom: templateId },\n      }\n    );\n\n    this.emit('template:duplicated', { originalId: templateId, duplicatedId: duplicated.id });\n    return duplicated;\n  }\n\n  /**\n   * Activate template\n   */\n  activateTemplate(templateId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    if (!template.isActive) {\n      template.isActive = true;\n      this.statistics.activeTemplates++;\n      this.emit('template:activated', { templateId });\n    }\n\n    return true;\n  }\n\n  /**\n   * Deactivate template\n   */\n  deactivateTemplate(templateId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    if (template.isActive) {\n      template.isActive = false;\n      this.statistics.activeTemplates--;\n      this.emit('template:deactivated', { templateId });\n    }\n\n    return true;\n  }\n\n  /**\n   * Delete template\n   */\n  deleteTemplate(templateId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    this.templates.delete(templateId);\n    this.versions.delete(templateId);\n    this.usageCount.delete(templateId);\n    this.invalidateCache(templateId);\n\n    this.statistics.totalTemplates--;\n    if (template.isActive) {\n      this.statistics.activeTemplates--;\n    }\n    this.statistics.byType[template.type]--;\n\n    this.emit('template:deleted', { templateId });\n    return true;\n  }\n\n  /**\n   * Invalidate cache\n   */\n  private invalidateCache(templateId: string): void {\n    for (const [key] of this.renderCache.entries()) {\n      if (key.startsWith(templateId)) {\n        this.renderCache.delete(key);\n        this.cacheExpiry.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Start cache cleanup\n   */\n  private startCacheCleanup(): void {\n    setInterval(() => {\n      const now = Date.now();\n      let cleaned = 0;\n\n      for (const [key, expiry] of this.cacheExpiry.entries()) {\n        if (expiry < now) {\n          this.renderCache.delete(key);\n          this.cacheExpiry.delete(key);\n          cleaned++;\n        }\n      }\n\n      if (cleaned > 0) {\n        this.emit('cache:cleanup', { itemsCleaned: cleaned });\n      }\n    }, 5 * 60 * 1000); // Run every 5 minutes\n  }\n\n  /**\n   * Update statistics\n   */\n  private updateStatistics(): void {\n    this.statistics.totalTemplates = this.templates.size;\n    this.statistics.activeTemplates = Array.from(this.templates.values()).filter((t) => t.isActive).length;\n\n    // Count by type and language\n    this.statistics.byType = { email: 0, sms: 0, push: 0, in_app: 0, webhook: 0 };\n    this.statistics.byLanguage = {};\n\n    for (const template of this.templates.values()) {\n      this.statistics.byType[template.type]++;\n      this.statistics.byLanguage[template.language] = (this.statistics.byLanguage[template.language] || 0) + 1;\n    }\n\n    // Find most used template\n    let mostUsed = { name: '', usageCount: 0 };\n    for (const [templateId, count] of this.usageCount.entries()) {\n      if (count > mostUsed.usageCount) {\n        const template = this.templates.get(templateId);\n        if (template) {\n          mostUsed = { name: template.name, usageCount: count };\n        }\n      }\n    }\n    this.statistics.mostUsedTemplate = mostUsed;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): TemplateStatistics {\n    this.updateStatistics();\n    return { ...this.statistics };\n  }\n}\n\nexport default NotificationTemplateBuilder;\n
