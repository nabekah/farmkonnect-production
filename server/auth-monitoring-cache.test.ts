import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { RBACManager, AuthManager, MFAManager, SessionManager } from './auth.system';\nimport { MetricsCollector, HealthCheckManager, PerformanceMonitor, Logger } from './monitoring';\nimport { CacheManager, DistributedCacheManager, CacheKeyBuilder, CacheInvalidationManager } from './cache';\n\n/**\n * RBAC Manager Tests\n */\ndescribe('RBAC Manager', () => {\n  let rbac: RBACManager;\n\n  beforeEach(() => {\n    rbac = new RBACManager();\n  });\n\n  it('should check admin permissions', () => {\n    expect(rbac.hasPermission('admin', 'user:create')).toBe(true);\n    expect(rbac.hasPermission('admin', 'system:manage')).toBe(true);\n  });\n\n  it('should check worker permissions', () => {\n    expect(rbac.hasPermission('worker', 'task:read')).toBe(true);\n    expect(rbac.hasPermission('worker', 'user:create')).toBe(false);\n  });\n\n  it('should check multiple permissions (AND)', () => {\n    expect(rbac.hasAllPermissions('admin', ['user:create', 'farm:delete'])).toBe(true);\n    expect(rbac.hasAllPermissions('worker', ['task:read', 'user:create'])).toBe(false);\n  });\n\n  it('should check multiple permissions (OR)', () => {\n    expect(rbac.hasAnyPermission('worker', ['task:read', 'user:create'])).toBe(true);\n    expect(rbac.hasAnyPermission('viewer', ['user:create', 'user:delete'])).toBe(false);\n  });\n\n  it('should get role permissions', () => {\n    const perms = rbac.getPermissions('admin');\n    expect(perms.length).toBeGreaterThan(0);\n    expect(perms).toContain('user:create');\n  });\n\n  it('should create custom role', () => {\n    rbac.createRole('supervisor', ['task:read', 'task:update', 'report:create']);\n    expect(rbac.hasPermission('supervisor', 'task:read')).toBe(true);\n  });\n\n  it('should update role', () => {\n    rbac.createRole('custom', ['read']);\n    rbac.updateRole('custom', ['read', 'write']);\n    expect(rbac.hasPermission('custom', 'write')).toBe(true);\n  });\n\n  it('should delete role', () => {\n    rbac.createRole('temp', ['read']);\n    rbac.deleteRole('temp');\n    expect(rbac.getPermissions('temp')).toEqual([]);\n  });\n});\n\n/**\n * Auth Manager Tests\n */\ndescribe('Auth Manager', () => {\n  let auth: AuthManager;\n  let rbac: RBACManager;\n\n  beforeEach(() => {\n    rbac = new RBACManager();\n    auth = new AuthManager('test-secret', 'test-refresh-secret', rbac);\n  });\n\n  it('should hash password', () => {\n    const hash1 = auth.hashPassword('password123');\n    const hash2 = auth.hashPassword('password123');\n    expect(hash1).toBe(hash2);\n    expect(hash1).not.toBe('password123');\n  });\n\n  it('should verify password', () => {\n    const hash = auth.hashPassword('password123');\n    expect(auth.verifyPassword('password123', hash)).toBe(true);\n    expect(auth.verifyPassword('wrong', hash)).toBe(false);\n  });\n\n  it('should generate access token', () => {\n    const user = {\n      id: 1,\n      username: 'john',\n      email: 'john@example.com',\n      passwordHash: 'hash',\n      role: 'admin' as const,\n      isActive: true,\n      isApproved: true,\n      mfaEnabled: false,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    const token = auth.generateAccessToken(user);\n    expect(token).toBeDefined();\n    expect(typeof token).toBe('string');\n  });\n\n  it('should verify access token', () => {\n    const user = {\n      id: 1,\n      username: 'john',\n      email: 'john@example.com',\n      passwordHash: 'hash',\n      role: 'admin' as const,\n      isActive: true,\n      isApproved: true,\n      mfaEnabled: false,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    const token = auth.generateAccessToken(user);\n    const payload = auth.verifyAccessToken(token);\n\n    expect(payload).not.toBeNull();\n    expect(payload?.sub).toBe(1);\n    expect(payload?.role).toBe('admin');\n  });\n\n  it('should generate and verify refresh token', () => {\n    const token = auth.generateRefreshToken(1);\n    const payload = auth.verifyRefreshToken(token);\n\n    expect(payload).not.toBeNull();\n    expect(payload?.sub).toBe(1);\n    expect(payload?.type).toBe('refresh');\n  });\n\n  it('should revoke refresh token', () => {\n    const token = auth.generateRefreshToken(1);\n    auth.revokeRefreshToken(token);\n\n    const payload = auth.verifyRefreshToken(token);\n    expect(payload).toBeNull();\n  });\n});\n\n/**\n * MFA Manager Tests\n */\ndescribe('MFA Manager', () => {\n  let mfa: MFAManager;\n\n  beforeEach(() => {\n    mfa = new MFAManager();\n  });\n\n  it('should generate secret', () => {\n    const secret = mfa.generateSecret();\n    expect(secret).toBeDefined();\n    expect(typeof secret).toBe('string');\n    expect(secret.length).toBeGreaterThan(0);\n  });\n\n  it('should generate TOTP code', () => {\n    const secret = mfa.generateSecret();\n    const code = mfa.generateTOTP(secret);\n\n    expect(code).toBeDefined();\n    expect(code.length).toBe(6);\n    expect(/^\\d{6}$/.test(code)).toBe(true);\n  });\n\n  it('should verify TOTP code', () => {\n    const secret = mfa.generateSecret();\n    const code = mfa.generateTOTP(secret);\n\n    expect(mfa.verifyTOTP(secret, code)).toBe(true);\n    expect(mfa.verifyTOTP(secret, '000000')).toBe(false);\n  });\n});\n\n/**\n * Session Manager Tests\n */\ndescribe('Session Manager', () => {\n  let sessions: SessionManager;\n\n  beforeEach(() => {\n    sessions = new SessionManager();\n  });\n\n  afterEach(() => {\n    sessions.stop();\n  });\n\n  it('should create session', () => {\n    const sessionId = sessions.createSession(1);\n    expect(sessionId).toBeDefined();\n    expect(typeof sessionId).toBe('string');\n  });\n\n  it('should get session', () => {\n    const sessionId = sessions.createSession(1, 3600000, { data: 'test' });\n    const session = sessions.getSession(sessionId);\n\n    expect(session).not.toBeNull();\n    expect(session?.userId).toBe(1);\n  });\n\n  it('should update session data', () => {\n    const sessionId = sessions.createSession(1);\n    sessions.updateSessionData(sessionId, { key: 'value' });\n\n    const session = sessions.getSession(sessionId);\n    expect(session?.data.key).toBe('value');\n  });\n\n  it('should destroy session', () => {\n    const sessionId = sessions.createSession(1);\n    sessions.destroySession(sessionId);\n\n    const session = sessions.getSession(sessionId);\n    expect(session).toBeNull();\n  });\n});\n\n/**\n * Metrics Collector Tests\n */\ndescribe('Metrics Collector', () => {\n  let metrics: MetricsCollector;\n\n  beforeEach(() => {\n    metrics = new MetricsCollector();\n  });\n\n  it('should record metric', () => {\n    metrics.recordMetric('response_time', 100, 'ms');\n    const recorded = metrics.getMetrics('response_time');\n\n    expect(recorded.length).toBe(1);\n    expect(recorded[0].value).toBe(100);\n  });\n\n  it('should increment counter', () => {\n    metrics.incrementCounter('requests');\n    metrics.incrementCounter('requests', 2);\n\n    expect(metrics.getCounter('requests')).toBe(3);\n  });\n\n  it('should set gauge', () => {\n    metrics.setGauge('memory', 512);\n    expect(metrics.getGauge('memory')).toBe(512);\n  });\n\n  it('should record histogram', () => {\n    metrics.recordHistogram('latency', 100);\n    metrics.recordHistogram('latency', 200);\n    metrics.recordHistogram('latency', 150);\n\n    const stats = metrics.getHistogramStats('latency');\n    expect(stats?.count).toBe(3);\n    expect(stats?.min).toBe(100);\n    expect(stats?.max).toBe(200);\n  });\n});\n\n/**\n * Health Check Manager Tests\n */\ndescribe('Health Check Manager', () => {\n  let health: HealthCheckManager;\n\n  beforeEach(() => {\n    health = new HealthCheckManager();\n  });\n\n  it('should register health check', () => {\n    health.registerCheck('db', async () => true);\n    expect(health.getAllResults().length).toBe(0);\n  });\n\n  it('should run health check', async () => {\n    health.registerCheck('db', async () => true);\n    const result = await health.runCheck('db');\n\n    expect(result.name).toBe('db');\n    expect(result.healthy).toBe(true);\n  });\n\n  it('should run all checks', async () => {\n    health.registerCheck('db', async () => true);\n    health.registerCheck('cache', async () => true);\n\n    const systemHealth = await health.runAllChecks();\n\n    expect(systemHealth.status).toBe('healthy');\n    expect(systemHealth.checks.length).toBe(2);\n  });\n\n  it('should handle check failure', async () => {\n    health.registerCheck('db', async () => {\n      throw new Error('Connection failed');\n    });\n\n    const result = await health.runCheck('db');\n    expect(result.healthy).toBe(false);\n    expect(result.message).toContain('Connection failed');\n  });\n});\n\n/**\n * Cache Manager Tests\n */\ndescribe('Cache Manager', () => {\n  let cache: CacheManager;\n\n  beforeEach(() => {\n    cache = new CacheManager();\n  });\n\n  afterEach(() => {\n    cache.stop();\n  });\n\n  it('should set and get value', () => {\n    cache.set('key', 'value');\n    expect(cache.get('key')).toBe('value');\n  });\n\n  it('should return null for missing key', () => {\n    expect(cache.get('missing')).toBeNull();\n  });\n\n  it('should delete value', () => {\n    cache.set('key', 'value');\n    cache.delete('key');\n    expect(cache.get('key')).toBeNull();\n  });\n\n  it('should delete by pattern', () => {\n    cache.set('user:1', 'data1');\n    cache.set('user:2', 'data2');\n    cache.set('post:1', 'data3');\n\n    const deleted = cache.deleteByPattern(/^user:/);\n    expect(deleted).toBe(2);\n    expect(cache.get('post:1')).toBe('data3');\n  });\n\n  it('should get or set', async () => {\n    const fn = vi.fn(async () => 'computed');\n\n    const result1 = await cache.getOrSet('key', fn);\n    const result2 = await cache.getOrSet('key', fn);\n\n    expect(result1).toBe('computed');\n    expect(result2).toBe('computed');\n    expect(fn).toHaveBeenCalledTimes(1);\n  });\n\n  it('should track cache stats', () => {\n    cache.set('key1', 'value1');\n    cache.get('key1');\n    cache.get('key1');\n    cache.get('missing');\n\n    const stats = cache.getStats();\n    expect(stats.hits).toBe(2);\n    expect(stats.misses).toBe(1);\n    expect(stats.hitRate).toBeGreaterThan(0);\n  });\n});\n\n/**\n * Distributed Cache Manager Tests\n */\ndescribe('Distributed Cache Manager', () => {\n  let cache: DistributedCacheManager;\n\n  beforeEach(() => {\n    cache = new DistributedCacheManager();\n  });\n\n  afterEach(() => {\n    cache.stop();\n  });\n\n  it('should set and get value', async () => {\n    await cache.set('key', 'value');\n    const result = await cache.get('key');\n    expect(result).toBe('value');\n  });\n\n  it('should work with remote store', async () => {\n    cache.enableRemoteStore();\n\n    await cache.set('key', 'value');\n    const result = await cache.get('key');\n\n    expect(result).toBe('value');\n    cache.disableRemoteStore();\n  });\n});\n\n/**\n * Cache Key Builder Tests\n */\ndescribe('Cache Key Builder', () => {\n  let builder: CacheKeyBuilder;\n\n  beforeEach(() => {\n    builder = new CacheKeyBuilder('farm');\n  });\n\n  it('should build key', () => {\n    const key = builder.build('user', 1, 'profile');\n    expect(key).toBe('farm:user:1:profile');\n  });\n\n  it('should build user key', () => {\n    const key = builder.user(1, 'profile');\n    expect(key).toBe('farm:user:1:profile');\n  });\n\n  it('should build farm key', () => {\n    const key = builder.farm(1, 'data');\n    expect(key).toBe('farm:farm:1:data');\n  });\n\n  it('should build pattern', () => {\n    const pattern = builder.pattern('user', 1, '*');\n    expect(pattern.test('farm:user:1:profile')).toBe(true);\n    expect(pattern.test('farm:user:2:profile')).toBe(false);\n  });\n});\n\n/**\n * Integration Tests\n */\ndescribe('Integration Tests', () => {\n  it('should work with auth and sessions', () => {\n    const rbac = new RBACManager();\n    const auth = new AuthManager('secret', 'refresh', rbac);\n    const sessions = new SessionManager();\n\n    const user = {\n      id: 1,\n      username: 'john',\n      email: 'john@example.com',\n      passwordHash: auth.hashPassword('pass'),\n      role: 'admin' as const,\n      isActive: true,\n      isApproved: true,\n      mfaEnabled: false,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    const token = auth.generateAccessToken(user);\n    const sessionId = sessions.createSession(user.id);\n\n    expect(token).toBeDefined();\n    expect(sessionId).toBeDefined();\n\n    sessions.stop();\n  });\n\n  it('should work with metrics and health checks', async () => {\n    const metrics = new MetricsCollector();\n    const health = new HealthCheckManager();\n\n    health.registerCheck('metrics', async () => {\n      metrics.incrementCounter('health_checks');\n      return true;\n    });\n\n    const result = await health.runCheck('metrics');\n    expect(result.healthy).toBe(true);\n    expect(metrics.getCounter('health_checks')).toBe(1);\n  });\n\n  it('should work with cache and invalidation', async () => {\n    const cache = new DistributedCacheManager();\n    const keyBuilder = new CacheKeyBuilder('app');\n    const invalidation = new CacheInvalidationManager(cache, keyBuilder);\n\n    await cache.set(keyBuilder.user(1, 'profile'), { name: 'John' });\n    await cache.set(keyBuilder.user(1, 'settings'), { theme: 'dark' });\n\n    const invalidated = await invalidation.invalidateUser(1);\n    expect(invalidated).toBe(2);\n\n    cache.stop();\n  });\n});\n
