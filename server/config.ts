import { EventEmitter } from 'events';\n\nexport type ConfigValueType = string | number | boolean | Record<string, any> | any[];\nexport type Environment = 'development' | 'staging' | 'production';\n\nexport interface ConfigEntry {\n  /**\n   * Config key\n   */\n  key: string;\n  /**\n   * Config value\n   */\n  value: ConfigValueType;\n  /**\n   * Environment\n   */\n  environment: Environment;\n  /**\n   * Description\n   */\n  description?: string;\n  /**\n   * Is secret\n   */\n  isSecret: boolean;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n  /**\n   * Updated by\n   */\n  updatedBy?: string;\n}\n\nexport interface FeatureFlag {\n  /**\n   * Flag name\n   */\n  name: string;\n  /**\n   * Flag enabled\n   */\n  enabled: boolean;\n  /**\n   * Environments where enabled\n   */\n  environments: Environment[];\n  /**\n   * Rollout percentage (0-100)\n   */\n  rolloutPercentage: number;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n}\n\n/**\n * Configuration Manager\n */\nexport class ConfigurationManager extends EventEmitter {\n  private configs: Map<string, ConfigEntry> = new Map();\n  private featureFlags: Map<string, FeatureFlag> = new Map();\n  private environment: Environment = 'development';\n  private changeHistory: Array<{ key: string; oldValue: ConfigValueType; newValue: ConfigValueType; timestamp: number; changedBy?: string }> = [];\n  private maxHistorySize: number = 10000;\n\n  constructor(environment: Environment = 'development') {\n    super();\n    this.environment = environment;\n  }\n\n  /**\n   * Set config\n   */\n  setConfig(key: string, value: ConfigValueType, options?: { description?: string; isSecret?: boolean; changedBy?: string }): void {\n    const oldValue = this.configs.get(key)?.value;\n\n    const entry: ConfigEntry = {\n      key,\n      value,\n      environment: this.environment,\n      description: options?.description,\n      isSecret: options?.isSecret || false,\n      updatedAt: Date.now(),\n      updatedBy: options?.changedBy,\n    };\n\n    this.configs.set(key, entry);\n\n    // Record change\n    if (oldValue !== undefined) {\n      this.changeHistory.push({\n        key,\n        oldValue,\n        newValue: value,\n        timestamp: Date.now(),\n        changedBy: options?.changedBy,\n      });\n\n      if (this.changeHistory.length > this.maxHistorySize) {\n        this.changeHistory.shift();\n      }\n    }\n\n    this.emit('config:updated', { key, value, environment: this.environment });\n  }\n\n  /**\n   * Get config\n   */\n  getConfig(key: string, defaultValue?: ConfigValueType): ConfigValueType | undefined {\n    const entry = this.configs.get(key);\n    return entry?.value ?? defaultValue;\n  }\n\n  /**\n   * Get config entry\n   */\n  getConfigEntry(key: string): ConfigEntry | null {\n    return this.configs.get(key) || null;\n  }\n\n  /**\n   * Delete config\n   */\n  deleteConfig(key: string): boolean {\n    if (this.configs.has(key)) {\n      this.configs.delete(key);\n      this.emit('config:deleted', { key });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get all configs\n   */\n  getAllConfigs(includeSecrets: boolean = false): Record<string, ConfigValueType> {\n    const result: Record<string, ConfigValueType> = {};\n\n    for (const [key, entry] of this.configs) {\n      if (!entry.isSecret || includeSecrets) {\n        result[key] = entry.value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get configs by environment\n   */\n  getConfigsByEnvironment(environment: Environment): Record<string, ConfigValueType> {\n    const result: Record<string, ConfigValueType> = {};\n\n    for (const [key, entry] of this.configs) {\n      if (entry.environment === environment) {\n        result[key] = entry.value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Create feature flag\n   */\n  createFeatureFlag(name: string, options?: { enabled?: boolean; environments?: Environment[]; rolloutPercentage?: number }): void {\n    const flag: FeatureFlag = {\n      name,\n      enabled: options?.enabled || false,\n      environments: options?.environments || ['development'],\n      rolloutPercentage: options?.rolloutPercentage || 100,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.featureFlags.set(name, flag);\n    this.emit('feature-flag:created', { name });\n  }\n\n  /**\n   * Update feature flag\n   */\n  updateFeatureFlag(name: string, options: { enabled?: boolean; environments?: Environment[]; rolloutPercentage?: number }): boolean {\n    const flag = this.featureFlags.get(name);\n    if (!flag) {\n      return false;\n    }\n\n    if (options.enabled !== undefined) {\n      flag.enabled = options.enabled;\n    }\n    if (options.environments) {\n      flag.environments = options.environments;\n    }\n    if (options.rolloutPercentage !== undefined) {\n      flag.rolloutPercentage = options.rolloutPercentage;\n    }\n\n    flag.updatedAt = Date.now();\n    this.emit('feature-flag:updated', { name });\n    return true;\n  }\n\n  /**\n   * Is feature enabled\n   */\n  isFeatureEnabled(name: string, userId?: string): boolean {\n    const flag = this.featureFlags.get(name);\n    if (!flag) {\n      return false;\n    }\n\n    // Check environment\n    if (!flag.environments.includes(this.environment)) {\n      return false;\n    }\n\n    // Check if enabled\n    if (!flag.enabled) {\n      return false;\n    }\n\n    // Check rollout percentage\n    if (flag.rolloutPercentage < 100) {\n      const hash = userId ? this.hashUserId(userId) : Math.random() * 100;\n      return hash < flag.rolloutPercentage;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get feature flag\n   */\n  getFeatureFlag(name: string): FeatureFlag | null {\n    return this.featureFlags.get(name) || null;\n  }\n\n  /**\n   * Get all feature flags\n   */\n  getAllFeatureFlags(): FeatureFlag[] {\n    return Array.from(this.featureFlags.values());\n  }\n\n  /**\n   * Delete feature flag\n   */\n  deleteFeatureFlag(name: string): boolean {\n    if (this.featureFlags.has(name)) {\n      this.featureFlags.delete(name);\n      this.emit('feature-flag:deleted', { name });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get change history\n   */\n  getChangeHistory(key?: string): typeof this.changeHistory {\n    if (key) {\n      return this.changeHistory.filter((h) => h.key === key);\n    }\n    return this.changeHistory;\n  }\n\n  /**\n   * Hash user ID for rollout\n   */\n  private hashUserId(userId: string): number {\n    let hash = 0;\n    for (let i = 0; i < userId.length; i++) {\n      const char = userId.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return Math.abs(hash) % 100;\n  }\n\n  /**\n   * Get environment\n   */\n  getEnvironment(): Environment {\n    return this.environment;\n  }\n\n  /**\n   * Set environment\n   */\n  setEnvironment(environment: Environment): void {\n    this.environment = environment;\n    this.emit('config:environment-changed', { environment });\n  }\n\n  /**\n   * Export configs\n   */\n  exportConfigs(includeSecrets: boolean = false): Record<string, any> {\n    return {\n      environment: this.environment,\n      configs: this.getAllConfigs(includeSecrets),\n      featureFlags: this.getAllFeatureFlags(),\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Import configs\n   */\n  importConfigs(data: Record<string, any>): void {\n    if (data.configs) {\n      for (const [key, value] of Object.entries(data.configs)) {\n        this.setConfig(key, value as ConfigValueType);\n      }\n    }\n\n    if (data.featureFlags) {\n      for (const flag of data.featureFlags as FeatureFlag[]) {\n        this.createFeatureFlag(flag.name, {\n          enabled: flag.enabled,\n          environments: flag.environments,\n          rolloutPercentage: flag.rolloutPercentage,\n        });\n      }\n    }\n\n    this.emit('config:imported', { timestamp: Date.now() });\n  }\n}\n\n/**\n * Configuration Validator\n */\nexport class ConfigurationValidator extends EventEmitter {\n  private schemas: Map<string, { type: string; required?: boolean; min?: number; max?: number; pattern?: RegExp; enum?: any[] }> = new Map();\n\n  /**\n   * Define schema\n   */\n  defineSchema(\n    key: string,\n    schema: { type: string; required?: boolean; min?: number; max?: number; pattern?: RegExp; enum?: any[] }\n  ): void {\n    this.schemas.set(key, schema);\n  }\n\n  /**\n   * Validate config\n   */\n  validate(key: string, value: ConfigValueType): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const schema = this.schemas.get(key);\n\n    if (!schema) {\n      return { valid: true, errors: [] };\n    }\n\n    // Check type\n    if (typeof value !== schema.type) {\n      errors.push(`Expected type ${schema.type}, got ${typeof value}`);\n    }\n\n    // Check required\n    if (schema.required && (value === null || value === undefined)) {\n      errors.push('Value is required');\n    }\n\n    // Check min\n    if (schema.min !== undefined && typeof value === 'number' && value < schema.min) {\n      errors.push(`Value must be >= ${schema.min}`);\n    }\n\n    // Check max\n    if (schema.max !== undefined && typeof value === 'number' && value > schema.max) {\n      errors.push(`Value must be <= ${schema.max}`);\n    }\n\n    // Check pattern\n    if (schema.pattern && typeof value === 'string' && !schema.pattern.test(value)) {\n      errors.push(`Value does not match pattern ${schema.pattern}`);\n    }\n\n    // Check enum\n    if (schema.enum && !schema.enum.includes(value)) {\n      errors.push(`Value must be one of ${schema.enum.join(', ')}`);\n    }\n\n    return { valid: errors.length === 0, errors };\n  }\n}\n
