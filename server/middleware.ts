import { Request, Response, NextFunction } from 'express';\nimport { ZodSchema, z } from 'zod';\n\nexport interface RequestLog {\n  /**\n   * Request ID\n   */\n  id: string;\n  /**\n   * HTTP method\n   */\n  method: string;\n  /**\n   * Request path\n   */\n  path: string;\n  /**\n   * Status code\n   */\n  status?: number;\n  /**\n   * Response time in ms\n   */\n  duration?: number;\n  /**\n   * Error message\n   */\n  error?: string;\n  /**\n   * Timestamp\n   */\n  timestamp: number;\n  /**\n   * User ID\n   */\n  userId?: string | number;\n}\n\nexport interface RateLimitOptions {\n  /**\n   * Window size in ms\n   */\n  windowMs: number;\n  /**\n   * Max requests per window\n   */\n  maxRequests: number;\n  /**\n   * Key generator\n   */\n  keyGenerator?: (req: Request) => string;\n}\n\n/**\n * Request logging middleware\n */\nexport function requestLogger() {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const requestId = `req-${Date.now()}-${Math.random()}`;\n    const startTime = Date.now();\n\n    // Attach request ID to response\n    res.setHeader('X-Request-ID', requestId);\n\n    // Log request\n    const log: RequestLog = {\n      id: requestId,\n      method: req.method,\n      path: req.path,\n      timestamp: startTime,\n    };\n\n    // Override res.send to capture status\n    const originalSend = res.send;\n    res.send = function (data: any) {\n      log.status = res.statusCode;\n      log.duration = Date.now() - startTime;\n\n      console.log(\n        `[${log.method}] ${log.path} - ${log.status} (${log.duration}ms)`\n      );\n\n      return originalSend.call(this, data);\n    };\n\n    next();\n  };\n}\n\n/**\n * Error handling middleware\n */\nexport function errorHandler() {\n  return (err: any, req: Request, res: Response, next: NextFunction) => {\n    console.error('[Error]', err);\n\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || 'Internal Server Error';\n\n    res.status(status).json({\n      error: {\n        message,\n        status,\n        timestamp: Date.now(),\n      },\n    });\n  };\n}\n\n/**\n * Request validation middleware\n */\nexport function validateRequest(schema: ZodSchema) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const validated = schema.parse({\n        body: req.body,\n        query: req.query,\n        params: req.params,\n      });\n\n      req.body = validated.body || req.body;\n      req.query = validated.query || req.query;\n      req.params = validated.params || req.params;\n\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({\n          error: {\n            message: 'Validation failed',\n            details: error.errors,\n          },\n        });\n      }\n\n      next(error);\n    }\n  };\n}\n\n/**\n * Rate limiting middleware\n */\nexport function rateLimit(options: RateLimitOptions) {\n  const requests: Map<string, number[]> = new Map();\n\n  return (req: Request, res: Response, next: NextFunction) => {\n    const key = options.keyGenerator ? options.keyGenerator(req) : req.ip || 'unknown';\n    const now = Date.now();\n    const windowStart = now - options.windowMs;\n\n    // Get requests in current window\n    let requestTimes = requests.get(key) || [];\n    requestTimes = requestTimes.filter((time) => time > windowStart);\n\n    if (requestTimes.length >= options.maxRequests) {\n      return res.status(429).json({\n        error: {\n          message: 'Too many requests',\n          retryAfter: Math.ceil(options.windowMs / 1000),\n        },\n      });\n    }\n\n    requestTimes.push(now);\n    requests.set(key, requestTimes);\n\n    // Cleanup old entries\n    if (requests.size > 1000) {\n      for (const [k, times] of requests.entries()) {\n        if (times.every((t) => t <= windowStart)) {\n          requests.delete(k);\n        }\n      }\n    }\n\n    next();\n  };\n}\n\n/**\n * CORS middleware\n */\nexport function corsMiddleware(options: any = {}) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const allowedOrigins = options.allowedOrigins || ['*'];\n    const origin = req.headers.origin;\n\n    if (allowedOrigins.includes('*') || allowedOrigins.includes(origin)) {\n      res.setHeader('Access-Control-Allow-Origin', origin || '*');\n    }\n\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    res.setHeader('Access-Control-Allow-Credentials', 'true');\n\n    if (req.method === 'OPTIONS') {\n      return res.sendStatus(200);\n    }\n\n    next();\n  };\n}\n\n/**\n * Request timeout middleware\n */\nexport function requestTimeout(timeoutMs: number = 30000) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const timer = setTimeout(() => {\n      res.status(408).json({\n        error: {\n          message: 'Request timeout',\n        },\n      });\n    }, timeoutMs);\n\n    res.on('finish', () => clearTimeout(timer));\n    res.on('close', () => clearTimeout(timer));\n\n    next();\n  };\n}\n\n/**\n * Security headers middleware\n */\nexport function securityHeaders() {\n  return (req: Request, res: Response, next: NextFunction) => {\n    res.setHeader('X-Content-Type-Options', 'nosniff');\n    res.setHeader('X-Frame-Options', 'DENY');\n    res.setHeader('X-XSS-Protection', '1; mode=block');\n    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n    res.setHeader('Content-Security-Policy', \"default-src 'self'\");\n\n    next();\n  };\n}\n\n/**\n * Request compression middleware\n */\nexport function compressionMiddleware() {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const acceptEncoding = req.headers['accept-encoding'] || '';\n\n    if (acceptEncoding.includes('gzip')) {\n      res.setHeader('Content-Encoding', 'gzip');\n    } else if (acceptEncoding.includes('deflate')) {\n      res.setHeader('Content-Encoding', 'deflate');\n    }\n\n    next();\n  };\n}\n\n/**\n * Request deduplication middleware\n */\nexport function deduplication() {\n  const cache: Map<string, { response: any; timestamp: number }> = new Map();\n  const CACHE_TTL = 5000; // 5 seconds\n\n  return (req: Request, res: Response, next: NextFunction) => {\n    // Only cache GET requests\n    if (req.method !== 'GET') {\n      return next();\n    }\n\n    const key = `${req.method}:${req.path}:${JSON.stringify(req.query)}`;\n    const cached = cache.get(key);\n\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n      res.setHeader('X-Cache', 'HIT');\n      return res.json(cached.response);\n    }\n\n    const originalJson = res.json.bind(res);\n    res.json = function (data: any) {\n      cache.set(key, { response: data, timestamp: Date.now() });\n      res.setHeader('X-Cache', 'MISS');\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\n/**\n * Middleware chain builder\n */\nexport class MiddlewareChain {\n  private middlewares: Array<(req: Request, res: Response, next: NextFunction) => void> = [];\n\n  add(middleware: (req: Request, res: Response, next: NextFunction) => void): this {\n    this.middlewares.push(middleware);\n    return this;\n  }\n\n  use(middleware: (req: Request, res: Response, next: NextFunction) => void): this {\n    return this.add(middleware);\n  }\n\n  build(): (req: Request, res: Response, next: NextFunction) => void {\n    return (req: Request, res: Response, next: NextFunction) => {\n      let index = 0;\n\n      const executeNext = () => {\n        if (index < this.middlewares.length) {\n          const middleware = this.middlewares[index++];\n          middleware(req, res, executeNext);\n        } else {\n          next();\n        }\n      };\n\n      executeNext();\n    };\n  }\n}\n
