import { EventEmitter } from 'events';\nimport crypto from 'crypto';\n\nexport type WebhookProvider = 'twilio' | 'sendgrid';\nexport type WebhookEventType =\n  | 'sms_sent'\n  | 'sms_delivered'\n  | 'sms_failed'\n  | 'sms_bounced'\n  | 'email_sent'\n  | 'email_delivered'\n  | 'email_opened'\n  | 'email_clicked'\n  | 'email_bounced'\n  | 'email_unsubscribed';\n\nexport interface WebhookEvent {\n  id: string;\n  provider: WebhookProvider;\n  eventType: WebhookEventType;\n  messageId: string;\n  externalId: string;\n  recipient: string;\n  timestamp: number;\n  metadata?: Record<string, any>;\n  processed: boolean;\n  processedAt?: number;\n}\n\nexport interface WebhookSignature {\n  provider: WebhookProvider;\n  timestamp: number;\n  signature: string;\n  isValid: boolean;\n}\n\nexport interface WebhookEndpoint {\n  id: string;\n  provider: WebhookProvider;\n  url: string;\n  signingKey: string;\n  active: boolean;\n  createdAt: number;\n  lastEventAt?: number;\n}\n\nexport interface WebhookMetrics {\n  totalReceived: number;\n  totalProcessed: number;\n  totalFailed: number;\n  smsEvents: number;\n  emailEvents: number;\n  deliveryRate: number;\n  processingTime: number;\n}\n\nclass WebhookEventHandler extends EventEmitter {\n  private events: Map<string, WebhookEvent> = new Map();\n  private endpoints: Map<string, WebhookEndpoint> = new Map();\n  private metrics: WebhookMetrics = {\n    totalReceived: 0,\n    totalProcessed: 0,\n    totalFailed: 0,\n    smsEvents: 0,\n    emailEvents: 0,\n    deliveryRate: 0,\n    processingTime: 0,\n  };\n  private processingTimes: number[] = [];\n  private eventQueue: WebhookEvent[] = [];\n  private processingInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    super();\n    this.startEventProcessor();\n  }\n\n  /**\n   * Register webhook endpoint\n   */\n  registerEndpoint(\n    provider: WebhookProvider,\n    url: string,\n    signingKey: string\n  ): WebhookEndpoint {\n    const endpoint: WebhookEndpoint = {\n      id: `ep-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      provider,\n      url,\n      signingKey,\n      active: true,\n      createdAt: Date.now(),\n    };\n\n    this.endpoints.set(endpoint.id, endpoint);\n    this.emit('endpoint:registered', endpoint);\n    return endpoint;\n  }\n\n  /**\n   * Get endpoint\n   */\n  getEndpoint(endpointId: string): WebhookEndpoint | undefined {\n    return this.endpoints.get(endpointId);\n  }\n\n  /**\n   * Get endpoints by provider\n   */\n  getEndpointsByProvider(provider: WebhookProvider): WebhookEndpoint[] {\n    return Array.from(this.endpoints.values()).filter(\n      (ep) => ep.provider === provider && ep.active\n    );\n  }\n\n  /**\n   * Verify Twilio webhook signature\n   */\n  verifyTwilioSignature(\n    url: string,\n    params: Record<string, any>,\n    signature: string,\n    authToken: string\n  ): boolean {\n    const data = url + Object.keys(params)\n      .sort()\n      .reduce((acc, key) => acc + key + params[key], '');\n\n    const hash = crypto\n      .createHmac('sha1', authToken)\n      .update(data)\n      .digest('base64');\n\n    return hash === signature;\n  }\n\n  /**\n   * Verify SendGrid webhook signature\n   */\n  verifySendGridSignature(\n    payload: string,\n    signature: string,\n    publicKey: string\n  ): boolean {\n    try {\n      const hash = crypto\n        .createHmac('sha256', publicKey)\n        .update(payload)\n        .digest('base64');\n\n      return hash === signature;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle Twilio webhook\n   */\n  handleTwilioWebhook(\n    params: Record<string, any>,\n    signature: string,\n    authToken: string\n  ): WebhookEvent | null {\n    // Verify signature\n    const url = 'https://your-domain.com/webhooks/twilio';\n    if (!this.verifyTwilioSignature(url, params, signature, authToken)) {\n      this.emit('webhook:invalid_signature', { provider: 'twilio' });\n      return null;\n    }\n\n    const messageStatus = params.MessageStatus || params.SmsStatus;\n    let eventType: WebhookEventType;\n\n    switch (messageStatus) {\n      case 'sent':\n        eventType = 'sms_sent';\n        break;\n      case 'delivered':\n        eventType = 'sms_delivered';\n        break;\n      case 'failed':\n        eventType = 'sms_failed';\n        break;\n      case 'bounced':\n        eventType = 'sms_bounced';\n        break;\n      default:\n        return null;\n    }\n\n    const event: WebhookEvent = {\n      id: `evt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      provider: 'twilio',\n      eventType,\n      messageId: params.MessageSid || '',\n      externalId: params.MessageSid || '',\n      recipient: params.To || '',\n      timestamp: Date.now(),\n      metadata: {\n        numSegments: params.NumSegments,\n        numMedia: params.NumMedia,\n        errorCode: params.ErrorCode,\n      },\n      processed: false,\n    };\n\n    return this.processEvent(event);\n  }\n\n  /**\n   * Handle SendGrid webhook\n   */\n  handleSendGridWebhook(\n    events: Array<Record<string, any>>,\n    signature: string,\n    publicKey: string\n  ): WebhookEvent[] {\n    const processedEvents: WebhookEvent[] = [];\n\n    for (const eventData of events) {\n      let eventType: WebhookEventType;\n\n      switch (eventData.event) {\n        case 'sent':\n          eventType = 'email_sent';\n          break;\n        case 'delivered':\n          eventType = 'email_delivered';\n          break;\n        case 'open':\n          eventType = 'email_opened';\n          break;\n        case 'click':\n          eventType = 'email_clicked';\n          break;\n        case 'bounce':\n          eventType = 'email_bounced';\n          break;\n        case 'unsubscribe':\n          eventType = 'email_unsubscribed';\n          break;\n        default:\n          continue;\n      }\n\n      const event: WebhookEvent = {\n        id: `evt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        provider: 'sendgrid',\n        eventType,\n        messageId: eventData.message_id || '',\n        externalId: eventData.message_id || '',\n        recipient: eventData.email || '',\n        timestamp: eventData.timestamp ? eventData.timestamp * 1000 : Date.now(),\n        metadata: {\n          category: eventData.category,\n          reason: eventData.reason,\n          status: eventData.status,\n          useragent: eventData.useragent,\n          ip: eventData.ip,\n        },\n        processed: false,\n      };\n\n      const processed = this.processEvent(event);\n      if (processed) {\n        processedEvents.push(processed);\n      }\n    }\n\n    return processedEvents;\n  }\n\n  /**\n   * Process event\n   */\n  private processEvent(event: WebhookEvent): WebhookEvent {\n    this.events.set(event.id, event);\n    this.eventQueue.push(event);\n    this.metrics.totalReceived++;\n\n    if (event.eventType.startsWith('sms')) {\n      this.metrics.smsEvents++;\n    } else {\n      this.metrics.emailEvents++;\n    }\n\n    this.emit('webhook:received', event);\n    return event;\n  }\n\n  /**\n   * Start event processor\n   */\n  private startEventProcessor(): void {\n    this.processingInterval = setInterval(() => {\n      this.processQueue();\n    }, 1000); // Process every second\n  }\n\n  /**\n   * Process event queue\n   */\n  private async processQueue(): Promise<void> {\n    if (this.eventQueue.length === 0) return;\n\n    const startTime = Date.now();\n    const eventsToProcess = [...this.eventQueue];\n    this.eventQueue = [];\n\n    for (const event of eventsToProcess) {\n      try {\n        await this.handleEvent(event);\n        event.processed = true;\n        event.processedAt = Date.now();\n        this.metrics.totalProcessed++;\n        this.emit('webhook:processed', event);\n      } catch (error) {\n        this.metrics.totalFailed++;\n        this.emit('webhook:failed', { event, error });\n      }\n    }\n\n    const processingTime = Date.now() - startTime;\n    this.processingTimes.push(processingTime);\n    if (this.processingTimes.length > 1000) {\n      this.processingTimes.shift();\n    }\n\n    this.updateMetrics();\n  }\n\n  /**\n   * Handle event\n   */\n  private async handleEvent(event: WebhookEvent): Promise<void> {\n    // Emit specific event\n    this.emit(`event:${event.eventType}`, event);\n\n    // Update message status in database\n    // In a real app, this would update the message record\n    switch (event.eventType) {\n      case 'sms_delivered':\n      case 'email_delivered':\n        this.emit('message:delivered', event);\n        break;\n      case 'sms_failed':\n      case 'email_bounced':\n        this.emit('message:failed', event);\n        break;\n      case 'email_opened':\n        this.emit('message:opened', event);\n        break;\n      case 'email_clicked':\n        this.emit('message:clicked', event);\n        break;\n      case 'email_unsubscribed':\n        this.emit('user:unsubscribed', event);\n        break;\n    }\n  }\n\n  /**\n   * Get event\n   */\n  getEvent(eventId: string): WebhookEvent | undefined {\n    return this.events.get(eventId);\n  }\n\n  /**\n   * Get events by message ID\n   */\n  getEventsByMessageId(messageId: string): WebhookEvent[] {\n    return Array.from(this.events.values()).filter(\n      (e) => e.messageId === messageId\n    );\n  }\n\n  /**\n   * Get events by type\n   */\n  getEventsByType(eventType: WebhookEventType): WebhookEvent[] {\n    return Array.from(this.events.values()).filter(\n      (e) => e.eventType === eventType\n    );\n  }\n\n  /**\n   * Get unprocessed events\n   */\n  getUnprocessedEvents(): WebhookEvent[] {\n    return Array.from(this.events.values()).filter((e) => !e.processed);\n  }\n\n  /**\n   * Retry failed event\n   */\n  retryEvent(eventId: string): boolean {\n    const event = this.events.get(eventId);\n    if (!event) return false;\n\n    event.processed = false;\n    this.eventQueue.push(event);\n    return true;\n  }\n\n  /**\n   * Update metrics\n   */\n  private updateMetrics(): void {\n    const total = this.metrics.totalReceived;\n    this.metrics.deliveryRate = total > 0 ? (this.metrics.totalProcessed / total) * 100 : 0;\n\n    if (this.processingTimes.length > 0) {\n      this.metrics.processingTime =\n        this.processingTimes.reduce((a, b) => a + b, 0) / this.processingTimes.length;\n    }\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics(): WebhookMetrics {\n    this.updateMetrics();\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get event statistics\n   */\n  getEventStatistics(timeRange?: { start: number; end: number }): Record<string, number> {\n    const stats: Record<string, number> = {};\n\n    for (const event of this.events.values()) {\n      if (timeRange && (event.timestamp < timeRange.start || event.timestamp > timeRange.end)) {\n        continue;\n      }\n\n      stats[event.eventType] = (stats[event.eventType] || 0) + 1;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval);\n    }\n  }\n}\n\nexport default WebhookEventHandler;\n
