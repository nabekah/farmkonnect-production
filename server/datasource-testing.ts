import { EventEmitter } from 'events';\n\nexport type DataSourceType = 'api' | 'database' | 'cache' | 'computed' | 'webhook';\n\nexport interface DataSourceConfig {\n  id: string;\n  name: string;\n  type: DataSourceType;\n  enabled: boolean;\n  config: Record<string, any>;\n  transformation?: {\n    enabled: boolean;\n    script: string;\n  };\n  caching?: {\n    enabled: boolean;\n    ttl: number; // seconds\n  };\n}\n\nexport interface TestResult {\n  id: string;\n  sourceId: string;\n  timestamp: number;\n  status: 'success' | 'error' | 'timeout' | 'validation_failed';\n  duration: number; // milliseconds\n  data?: any;\n  error?: string;\n  validationErrors?: string[];\n  sampleData?: any;\n}\n\nexport interface DataSourceTest {\n  id: string;\n  sourceId: string;\n  name: string;\n  description?: string;\n  config: DataSourceConfig;\n  lastTestResult?: TestResult;\n  testHistory: TestResult[];\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport class DataSourceTester extends EventEmitter {\n  private tests: Map<string, DataSourceTest> = new Map();\n  private testResults: Map<string, TestResult[]> = new Map();\n  private testCounter = 0;\n  private resultCounter = 0;\n\n  /**\n   * Create a new data source test\n   */\n  createTest(sourceId: string, config: DataSourceConfig, name?: string): DataSourceTest {\n    const testId = `test-${++this.testCounter}`;\n    const test: DataSourceTest = {\n      id: testId,\n      sourceId,\n      name: name || config.name,\n      config,\n      testHistory: [],\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.tests.set(testId, test);\n    this.testResults.set(testId, []);\n    this.emit('test:created', test);\n\n    return test;\n  }\n\n  /**\n   * Test API data source\n   */\n  async testApiSource(config: DataSourceConfig): Promise<TestResult> {\n    const startTime = Date.now();\n    const resultId = `result-${++this.resultCounter}`;\n\n    try {\n      const { url, method = 'GET', headers = {}, timeout = 5000 } = config.config;\n\n      if (!url) {\n        throw new Error('API URL is required');\n      }\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const response = await fetch(url, {\n        method,\n        headers,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      const duration = Date.now() - startTime;\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'success',\n        duration,\n        data,\n        sampleData: Array.isArray(data) ? data.slice(0, 5) : data,\n      };\n\n      this.emit('test:success', result);\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: errorMessage.includes('abort') ? 'timeout' : 'error',\n        duration,\n        error: errorMessage,\n      };\n\n      this.emit('test:error', result);\n      return result;\n    }\n  }\n\n  /**\n   * Test database data source\n   */\n  async testDatabaseSource(config: DataSourceConfig): Promise<TestResult> {\n    const startTime = Date.now();\n    const resultId = `result-${++this.resultCounter}`;\n\n    try {\n      const { query, timeout = 5000 } = config.config;\n\n      if (!query) {\n        throw new Error('Database query is required');\n      }\n\n      // Simulate database query\n      const data = await this.simulateDatabaseQuery(query, timeout);\n      const duration = Date.now() - startTime;\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'success',\n        duration,\n        data,\n        sampleData: Array.isArray(data) ? data.slice(0, 5) : data,\n      };\n\n      this.emit('test:success', result);\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'error',\n        duration,\n        error: errorMessage,\n      };\n\n      this.emit('test:error', result);\n      return result;\n    }\n  }\n\n  /**\n   * Test cache data source\n   */\n  async testCacheSource(config: DataSourceConfig): Promise<TestResult> {\n    const startTime = Date.now();\n    const resultId = `result-${++this.resultCounter}`;\n\n    try {\n      const { key, timeout = 1000 } = config.config;\n\n      if (!key) {\n        throw new Error('Cache key is required');\n      }\n\n      // Simulate cache retrieval\n      const data = await this.simulateCacheRetrieval(key, timeout);\n      const duration = Date.now() - startTime;\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'success',\n        duration,\n        data,\n        sampleData: data,\n      };\n\n      this.emit('test:success', result);\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'error',\n        duration,\n        error: errorMessage,\n      };\n\n      this.emit('test:error', result);\n      return result;\n    }\n  }\n\n  /**\n   * Test computed data source\n   */\n  async testComputedSource(config: DataSourceConfig): Promise<TestResult> {\n    const startTime = Date.now();\n    const resultId = `result-${++this.resultCounter}`;\n\n    try {\n      const { script, inputs = {} } = config.config;\n\n      if (!script) {\n        throw new Error('Computation script is required');\n      }\n\n      // Simulate computation\n      const data = await this.simulateComputation(script, inputs);\n      const duration = Date.now() - startTime;\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'success',\n        duration,\n        data,\n        sampleData: data,\n      };\n\n      this.emit('test:success', result);\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'error',\n        duration,\n        error: errorMessage,\n      };\n\n      this.emit('test:error', result);\n      return result;\n    }\n  }\n\n  /**\n   * Test webhook data source\n   */\n  async testWebhookSource(config: DataSourceConfig): Promise<TestResult> {\n    const startTime = Date.now();\n    const resultId = `result-${++this.resultCounter}`;\n\n    try {\n      const { url, method = 'POST', payload = {}, timeout = 5000 } = config.config;\n\n      if (!url) {\n        throw new Error('Webhook URL is required');\n      }\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const response = await fetch(url, {\n        method,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      const duration = Date.now() - startTime;\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: 'success',\n        duration,\n        data,\n        sampleData: data,\n      };\n\n      this.emit('test:success', result);\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const result: TestResult = {\n        id: resultId,\n        sourceId: config.id,\n        timestamp: Date.now(),\n        status: errorMessage.includes('abort') ? 'timeout' : 'error',\n        duration,\n        error: errorMessage,\n      };\n\n      this.emit('test:error', result);\n      return result;\n    }\n  }\n\n  /**\n   * Run test for data source\n   */\n  async runTest(testId: string): Promise<TestResult> {\n    const test = this.tests.get(testId);\n    if (!test) {\n      throw new Error(`Test ${testId} not found`);\n    }\n\n    let result: TestResult;\n\n    switch (test.config.type) {\n      case 'api':\n        result = await this.testApiSource(test.config);\n        break;\n      case 'database':\n        result = await this.testDatabaseSource(test.config);\n        break;\n      case 'cache':\n        result = await this.testCacheSource(test.config);\n        break;\n      case 'computed':\n        result = await this.testComputedSource(test.config);\n        break;\n      case 'webhook':\n        result = await this.testWebhookSource(test.config);\n        break;\n      default:\n        throw new Error(`Unknown data source type: ${test.config.type}`);\n    }\n\n    // Store result\n    test.lastTestResult = result;\n    test.testHistory.push(result);\n    test.updatedAt = Date.now();\n\n    const history = this.testResults.get(testId) || [];\n    history.push(result);\n    this.testResults.set(testId, history);\n\n    this.emit('test:completed', result);\n    return result;\n  }\n\n  /**\n   * Validate data against schema\n   */\n  validateData(data: any, schema: Record<string, any>): string[] {\n    const errors: string[] = [];\n\n    if (!schema) return errors;\n\n    if (schema.type === 'array') {\n      if (!Array.isArray(data)) {\n        errors.push('Expected array data');\n      } else if (schema.items) {\n        for (let i = 0; i < Math.min(data.length, 5); i++) {\n          const itemErrors = this.validateObject(data[i], schema.items);\n          errors.push(...itemErrors.map((e) => `[${i}] ${e}`));\n        }\n      }\n    } else if (schema.type === 'object') {\n      const objErrors = this.validateObject(data, schema);\n      errors.push(...objErrors);\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validate object against schema\n   */\n  private validateObject(obj: any, schema: Record<string, any>): string[] {\n    const errors: string[] = [];\n\n    if (schema.required) {\n      for (const field of schema.required) {\n        if (!(field in obj)) {\n          errors.push(`Missing required field: ${field}`);\n        }\n      }\n    }\n\n    if (schema.properties) {\n      for (const [field, fieldSchema] of Object.entries(schema.properties)) {\n        if (field in obj) {\n          const value = obj[field];\n          const fieldConfig = fieldSchema as Record<string, any>;\n\n          if (fieldConfig.type && typeof value !== fieldConfig.type) {\n            errors.push(`Field ${field}: expected ${fieldConfig.type}, got ${typeof value}`);\n          }\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Simulate database query\n   */\n  private async simulateDatabaseQuery(query: string, timeout: number): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error('Database query timeout'));\n      }, timeout);\n\n      // Simulate query execution\n      setTimeout(() => {\n        clearTimeout(timer);\n        resolve([\n          { id: 1, name: 'Sample 1', value: 100 },\n          { id: 2, name: 'Sample 2', value: 200 },\n        ]);\n      }, Math.random() * 100);\n    });\n  }\n\n  /**\n   * Simulate cache retrieval\n   */\n  private async simulateCacheRetrieval(key: string, timeout: number): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error('Cache retrieval timeout'));\n      }, timeout);\n\n      setTimeout(() => {\n        clearTimeout(timer);\n        resolve({ key, value: 'cached_data', timestamp: Date.now() });\n      }, Math.random() * 50);\n    });\n  }\n\n  /**\n   * Simulate computation\n   */\n  private async simulateComputation(script: string, inputs: Record<string, any>): Promise<any> {\n    // In real implementation, use safe evaluation or sandboxed execution\n    try {\n      // Simple computation simulation\n      const result = {\n        computed: true,\n        inputs,\n        output: Object.values(inputs).reduce((a: any, b: any) => {\n          if (typeof a === 'number' && typeof b === 'number') {\n            return a + b;\n          }\n          return a;\n        }, 0),\n      };\n\n      return result;\n    } catch (error) {\n      throw new Error(`Computation error: ${error}`);\n    }\n  }\n\n  /**\n   * Get test\n   */\n  getTest(testId: string): DataSourceTest | undefined {\n    return this.tests.get(testId);\n  }\n\n  /**\n   * Get all tests\n   */\n  getAllTests(): DataSourceTest[] {\n    return Array.from(this.tests.values());\n  }\n\n  /**\n   * Get test results\n   */\n  getTestResults(testId: string): TestResult[] {\n    return this.testResults.get(testId) || [];\n  }\n\n  /**\n   * Get latest test result\n   */\n  getLatestResult(testId: string): TestResult | undefined {\n    const test = this.tests.get(testId);\n    return test?.lastTestResult;\n  }\n\n  /**\n   * Delete test\n   */\n  deleteTest(testId: string): boolean {\n    const deleted = this.tests.delete(testId);\n    if (deleted) {\n      this.testResults.delete(testId);\n      this.emit('test:deleted', testId);\n    }\n    return deleted;\n  }\n}\n
