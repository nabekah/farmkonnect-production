import { EventEmitter } from 'events';\n\nexport type SearchType = 'farms' | 'users' | 'reports' | 'all';\nexport type SortOrder = 'asc' | 'desc';\n\nexport interface SearchFilter {\n  /**\n   * Filter field\n   */\n  field: string;\n  /**\n   * Filter operator\n   */\n  operator: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'gt' | 'lt' | 'gte' | 'lte' | 'in' | 'between';\n  /**\n   * Filter value\n   */\n  value: any;\n}\n\nexport interface SearchOptions {\n  /**\n   * Search query\n   */\n  query: string;\n  /**\n   * Search type\n   */\n  type: SearchType;\n  /**\n   * Filters\n   */\n  filters?: SearchFilter[];\n  /**\n   * Sort field\n   */\n  sortBy?: string;\n  /**\n   * Sort order\n   */\n  sortOrder?: SortOrder;\n  /**\n   * Page number\n   */\n  page?: number;\n  /**\n   * Items per page\n   */\n  limit?: number;\n  /**\n   * Highlight matches\n   */\n  highlight?: boolean;\n}\n\nexport interface SearchResult<T = any> {\n  /**\n   * Result ID\n   */\n  id: string;\n  /**\n   * Result type\n   */\n  type: string;\n  /**\n   * Result data\n   */\n  data: T;\n  /**\n   * Relevance score\n   */\n  score: number;\n  /**\n   * Highlighted text\n   */\n  highlight?: string;\n}\n\nexport interface SearchResponse<T = any> {\n  /**\n   * Query\n   */\n  query: string;\n  /**\n   * Total results\n   */\n  total: number;\n  /**\n   * Results\n   */\n  results: SearchResult<T>[];\n  /**\n   * Facets\n   */\n  facets?: Record<string, { value: string; count: number }[]>;\n  /**\n   * Suggestions\n   */\n  suggestions?: string[];\n  /**\n   * Search time in ms\n   */\n  searchTime: number;\n}\n\n/**\n * Full-text Search Engine\n */\nexport class SearchEngine extends EventEmitter {\n  private index: Map<string, Map<string, Set<string>>> = new Map();\n  private data: Map<string, Record<string, any>> = new Map();\n  private suggestions: Set<string> = new Set();\n  private searchCache: Map<string, SearchResponse> = new Map();\n  private cacheExpiry: number = 5 * 60 * 1000; // 5 minutes\n\n  /**\n   * Index document\n   */\n  indexDocument(id: string, type: string, data: Record<string, any>): void {\n    const docKey = `${type}:${id}`;\n    this.data.set(docKey, data);\n\n    // Index searchable fields\n    const searchableFields = this.getSearchableFields(data);\n    for (const field of searchableFields) {\n      const tokens = this.tokenize(field);\n      for (const token of tokens) {\n        if (!this.index.has(token)) {\n          this.index.set(token, new Map());\n        }\n\n        const typeIndex = this.index.get(token)!;\n        if (!typeIndex.has(type)) {\n          typeIndex.set(type, new Set());\n        }\n\n        typeIndex.get(type)!.add(docKey);\n        this.suggestions.add(token);\n      }\n    }\n\n    this.emit('document:indexed', { id, type });\n  }\n\n  /**\n   * Search\n   */\n  search(options: SearchOptions): SearchResponse {\n    const startTime = Date.now();\n    const cacheKey = JSON.stringify(options);\n\n    // Check cache\n    const cached = this.searchCache.get(cacheKey);\n    if (cached && Date.now() - cached.searchTime < this.cacheExpiry) {\n      this.emit('search:cached', { query: options.query });\n      return cached;\n    }\n\n    const tokens = this.tokenize(options.query);\n    const results: Map<string, SearchResult> = new Map();\n\n    // Find matching documents\n    for (const token of tokens) {\n      const typeIndex = this.index.get(token);\n      if (!typeIndex) continue;\n\n      for (const [type, docIds] of typeIndex) {\n        if (options.type !== 'all' && type !== options.type) continue;\n\n        for (const docId of docIds) {\n          const data = this.data.get(docId);\n          if (!data) continue;\n\n          if (!results.has(docId)) {\n            results.set(docId, {\n              id: docId,\n              type,\n              data,\n              score: 0,\n            });\n          }\n\n          const result = results.get(docId)!;\n          result.score += this.calculateRelevance(options.query, data);\n        }\n      }\n    }\n\n    // Apply filters\n    let filtered = Array.from(results.values());\n    if (options.filters && options.filters.length > 0) {\n      filtered = filtered.filter((result) => this.applyFilters(result.data, options.filters!));\n    }\n\n    // Sort\n    filtered.sort((a, b) => {\n      if (options.sortBy) {\n        const aVal = a.data[options.sortBy];\n        const bVal = b.data[options.sortBy];\n        const order = options.sortOrder === 'asc' ? 1 : -1;\n        return (aVal > bVal ? 1 : -1) * order;\n      }\n      return b.score - a.score;\n    });\n\n    // Pagination\n    const page = options.page || 1;\n    const limit = options.limit || 10;\n    const start = (page - 1) * limit;\n    const paginated = filtered.slice(start, start + limit);\n\n    // Highlight\n    if (options.highlight) {\n      for (const result of paginated) {\n        result.highlight = this.highlightMatches(options.query, result.data);\n      }\n    }\n\n    const response: SearchResponse = {\n      query: options.query,\n      total: filtered.length,\n      results: paginated,\n      facets: this.generateFacets(filtered),\n      suggestions: this.generateSuggestions(options.query),\n      searchTime: Date.now() - startTime,\n    };\n\n    // Cache result\n    this.searchCache.set(cacheKey, response);\n\n    this.emit('search:completed', { query: options.query, results: paginated.length, time: response.searchTime });\n    return response;\n  }\n\n  /**\n   * Tokenize text\n   */\n  private tokenize(text: string): string[] {\n    return text\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter((token) => token.length > 0);\n  }\n\n  /**\n   * Get searchable fields\n   */\n  private getSearchableFields(data: Record<string, any>): string[] {\n    const fields: string[] = [];\n    for (const [key, value] of Object.entries(data)) {\n      if (typeof value === 'string' || typeof value === 'number') {\n        fields.push(String(value));\n      }\n    }\n    return fields;\n  }\n\n  /**\n   * Calculate relevance score\n   */\n  private calculateRelevance(query: string, data: Record<string, any>): number {\n    let score = 0;\n    const queryLower = query.toLowerCase();\n\n    for (const value of Object.values(data)) {\n      const str = String(value).toLowerCase();\n      if (str === queryLower) score += 10;\n      else if (str.startsWith(queryLower)) score += 5;\n      else if (str.includes(queryLower)) score += 2;\n    }\n\n    return score;\n  }\n\n  /**\n   * Apply filters\n   */\n  private applyFilters(data: Record<string, any>, filters: SearchFilter[]): boolean {\n    for (const filter of filters) {\n      const value = data[filter.field];\n      if (!this.matchesFilter(value, filter)) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Match filter\n   */\n  private matchesFilter(value: any, filter: SearchFilter): boolean {\n    switch (filter.operator) {\n      case 'equals':\n        return value === filter.value;\n      case 'contains':\n        return String(value).includes(String(filter.value));\n      case 'startsWith':\n        return String(value).startsWith(String(filter.value));\n      case 'endsWith':\n        return String(value).endsWith(String(filter.value));\n      case 'gt':\n        return value > filter.value;\n      case 'lt':\n        return value < filter.value;\n      case 'gte':\n        return value >= filter.value;\n      case 'lte':\n        return value <= filter.value;\n      case 'in':\n        return Array.isArray(filter.value) && filter.value.includes(value);\n      case 'between':\n        return Array.isArray(filter.value) && value >= filter.value[0] && value <= filter.value[1];\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Highlight matches\n   */\n  private highlightMatches(query: string, data: Record<string, any>): string {\n    const tokens = this.tokenize(query);\n    let text = JSON.stringify(data);\n\n    for (const token of tokens) {\n      const regex = new RegExp(`\\\\b${token}\\\\b`, 'gi');\n      text = text.replace(regex, `<mark>${token}</mark>`);\n    }\n\n    return text;\n  }\n\n  /**\n   * Generate facets\n   */\n  private generateFacets(results: SearchResult[]): Record<string, { value: string; count: number }[]> {\n    const facets: Record<string, Map<string, number>> = {};\n\n    for (const result of results) {\n      for (const [key, value] of Object.entries(result.data)) {\n        if (typeof value === 'string' || typeof value === 'number') {\n          if (!facets[key]) facets[key] = new Map();\n          const str = String(value);\n          facets[key].set(str, (facets[key].get(str) || 0) + 1);\n        }\n      }\n    }\n\n    const result: Record<string, { value: string; count: number }[]> = {};\n    for (const [key, map] of Object.entries(facets)) {\n      result[key] = Array.from(map.entries())\n        .map(([value, count]) => ({ value, count }))\n        .sort((a, b) => b.count - a.count)\n        .slice(0, 10);\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate suggestions\n   */\n  private generateSuggestions(query: string): string[] {\n    const tokens = this.tokenize(query);\n    const suggestions: string[] = [];\n\n    for (const token of tokens) {\n      for (const suggestion of this.suggestions) {\n        if (suggestion.startsWith(token) && suggestion !== token && suggestions.length < 5) {\n          suggestions.push(suggestion);\n        }\n      }\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * Delete document\n   */\n  deleteDocument(id: string, type: string): void {\n    const docKey = `${type}:${id}`;\n    this.data.delete(docKey);\n\n    // Remove from index\n    for (const typeIndex of this.index.values()) {\n      const docIds = typeIndex.get(type);\n      if (docIds) {\n        docIds.delete(docKey);\n        if (docIds.size === 0) {\n          typeIndex.delete(type);\n        }\n      }\n    }\n\n    this.emit('document:deleted', { id, type });\n  }\n\n  /**\n   * Clear search cache\n   */\n  clearCache(): void {\n    this.searchCache.clear();\n    this.emit('cache:cleared');\n  }\n\n  /**\n   * Get search stats\n   */\n  getSearchStats(): {\n    indexedDocuments: number;\n    indexSize: number;\n    cachedQueries: number;\n    suggestions: number;\n  } {\n    return {\n      indexedDocuments: this.data.size,\n      indexSize: this.index.size,\n      cachedQueries: this.searchCache.size,\n      suggestions: this.suggestions.size,\n    };\n  }\n\n  /**\n   * Rebuild index\n   */\n  rebuildIndex(): void {\n    this.index.clear();\n    this.suggestions.clear();\n    this.searchCache.clear();\n\n    for (const [docKey, data] of this.data) {\n      const [type, id] = docKey.split(':');\n      this.indexDocument(id, type, data);\n    }\n\n    this.emit('index:rebuilt');\n  }\n}\n
