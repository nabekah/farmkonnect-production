import { EventEmitter } from 'events';\n\nexport type EventCategory = 'user' | 'farm' | 'report' | 'transaction' | 'system';\nexport type EventAction = string;\n\nexport interface AnalyticsEvent {\n  /**\n   * Event ID\n   */\n  id: string;\n  /**\n   * User ID\n   */\n  userId: string;\n  /**\n   * Category\n   */\n  category: EventCategory;\n  /**\n   * Action\n   */\n  action: EventAction;\n  /**\n   * Label\n   */\n  label?: string;\n  /**\n   * Value\n   */\n  value?: number;\n  /**\n   * Properties\n   */\n  properties?: Record<string, any>;\n  /**\n   * Session ID\n   */\n  sessionId: string;\n  /**\n   * Timestamp\n   */\n  timestamp: number;\n}\n\nexport interface FunnelStep {\n  /**\n   * Step name\n   */\n  name: string;\n  /**\n   * Event action\n   */\n  action: string;\n  /**\n   * User count\n   */\n  users: number;\n  /**\n   * Conversion rate\n   */\n  conversionRate: number;\n}\n\nexport interface FunnelAnalysis {\n  /**\n   * Funnel name\n   */\n  name: string;\n  /**\n   * Steps\n   */\n  steps: FunnelStep[];\n  /**\n   * Total users\n   */\n  totalUsers: number;\n  /**\n   * Completion rate\n   */\n  completionRate: number;\n}\n\nexport interface MetricData {\n  /**\n   * Metric name\n   */\n  name: string;\n  /**\n   * Value\n   */\n  value: number;\n  /**\n   * Timestamp\n   */\n  timestamp: number;\n}\n\n/**\n * Analytics Engine\n */\nexport class AnalyticsEngine extends EventEmitter {\n  private events: Map<string, AnalyticsEvent> = new Map();\n  private sessions: Map<string, { userId: string; startTime: number; endTime?: number }> = new Map();\n  private funnels: Map<string, string[]> = new Map();\n  private metrics: Map<string, MetricData[]> = new Map();\n\n  /**\n   * Track event\n   */\n  trackEvent(\n    userId: string,\n    category: EventCategory,\n    action: EventAction,\n    options?: {\n      label?: string;\n      value?: number;\n      properties?: Record<string, any>;\n      sessionId?: string;\n    }\n  ): AnalyticsEvent {\n    const sessionId = options?.sessionId || `session-${userId}-${Date.now()}`;\n    const event: AnalyticsEvent = {\n      id: `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      category,\n      action,\n      label: options?.label,\n      value: options?.value,\n      properties: options?.properties,\n      sessionId,\n      timestamp: Date.now(),\n    };\n\n    this.events.set(event.id, event);\n\n    // Create session if not exists\n    if (!this.sessions.has(sessionId)) {\n      this.sessions.set(sessionId, { userId, startTime: Date.now() });\n    }\n\n    this.emit('event:tracked', { id: event.id, category, action });\n    return event;\n  }\n\n  /**\n   * Define funnel\n   */\n  defineFunnel(name: string, steps: string[]): void {\n    this.funnels.set(name, steps);\n    this.emit('funnel:defined', { name, steps: steps.length });\n  }\n\n  /**\n   * Analyze funnel\n   */\n  analyzeFunnel(name: string): FunnelAnalysis | null {\n    const steps = this.funnels.get(name);\n    if (!steps) return null;\n\n    const funnelSteps: FunnelStep[] = [];\n    let previousUsers = new Set<string>();\n\n    for (let i = 0; i < steps.length; i++) {\n      const action = steps[i];\n      const usersAtStep = new Set<string>();\n\n      for (const event of this.events.values()) {\n        if (event.action === action) {\n          usersAtStep.add(event.userId);\n        }\n      }\n\n      const conversionRate = i === 0 ? 100 : (usersAtStep.size / previousUsers.size) * 100;\n\n      funnelSteps.push({\n        name: `Step ${i + 1}: ${action}`,\n        action,\n        users: usersAtStep.size,\n        conversionRate,\n      });\n\n      previousUsers = usersAtStep;\n    }\n\n    const totalUsers = funnelSteps[0]?.users || 0;\n    const completionRate = funnelSteps.length > 0 ? (funnelSteps[funnelSteps.length - 1].users / totalUsers) * 100 : 0;\n\n    return {\n      name,\n      steps: funnelSteps,\n      totalUsers,\n      completionRate,\n    };\n  }\n\n  /**\n   * Record metric\n   */\n  recordMetric(name: string, value: number): void {\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, []);\n    }\n\n    this.metrics.get(name)!.push({\n      name,\n      value,\n      timestamp: Date.now(),\n    });\n\n    this.emit('metric:recorded', { name, value });\n  }\n\n  /**\n   * Get metric data\n   */\n  getMetricData(name: string, limit: number = 100): MetricData[] {\n    const data = this.metrics.get(name) || [];\n    return data.slice(-limit);\n  }\n\n  /**\n   * Get metric stats\n   */\n  getMetricStats(name: string): {\n    current: number;\n    average: number;\n    min: number;\n    max: number;\n    trend: 'up' | 'down' | 'stable';\n  } | null {\n    const data = this.metrics.get(name);\n    if (!data || data.length === 0) return null;\n\n    const values = data.map((d) => d.value);\n    const current = values[values.length - 1];\n    const average = values.reduce((a, b) => a + b, 0) / values.length;\n    const min = Math.min(...values);\n    const max = Math.max(...values);\n\n    let trend: 'up' | 'down' | 'stable' = 'stable';\n    if (values.length > 1) {\n      const recent = values.slice(-5);\n      const older = values.slice(-10, -5);\n      const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;\n      const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;\n      if (recentAvg > olderAvg * 1.1) trend = 'up';\n      else if (recentAvg < olderAvg * 0.9) trend = 'down';\n    }\n\n    return { current, average, min, max, trend };\n  }\n\n  /**\n   * Get user journey\n   */\n  getUserJourney(userId: string): AnalyticsEvent[] {\n    return Array.from(this.events.values())\n      .filter((e) => e.userId === userId)\n      .sort((a, b) => a.timestamp - b.timestamp);\n  }\n\n  /**\n   * Get cohort analysis\n   */\n  getCohortAnalysis(startDate: number, endDate: number): {\n    cohortSize: number;\n    activeUsers: number;\n    retentionRate: number;\n    averageSessionDuration: number;\n  } {\n    const cohortUsers = new Set<string>();\n    let totalSessionDuration = 0;\n    let sessionCount = 0;\n\n    for (const event of this.events.values()) {\n      if (event.timestamp >= startDate && event.timestamp <= endDate) {\n        cohortUsers.add(event.userId);\n      }\n    }\n\n    for (const session of this.sessions.values()) {\n      if (session.startTime >= startDate && session.startTime <= endDate) {\n        const duration = (session.endTime || Date.now()) - session.startTime;\n        totalSessionDuration += duration;\n        sessionCount++;\n      }\n    }\n\n    const averageSessionDuration = sessionCount > 0 ? totalSessionDuration / sessionCount : 0;\n\n    return {\n      cohortSize: cohortUsers.size,\n      activeUsers: cohortUsers.size,\n      retentionRate: 0, // Simplified\n      averageSessionDuration,\n    };\n  }\n\n  /**\n   * Get event stats\n   */\n  getEventStats(category?: EventCategory): {\n    total: number;\n    byCategory: Record<EventCategory, number>;\n    byAction: Record<string, number>;\n    uniqueUsers: number;\n  } {\n    const stats = {\n      total: 0,\n      byCategory: {\n        user: 0,\n        farm: 0,\n        report: 0,\n        transaction: 0,\n        system: 0,\n      } as Record<EventCategory, number>,\n      byAction: {} as Record<string, number>,\n      uniqueUsers: 0,\n    };\n\n    const uniqueUsers = new Set<string>();\n\n    for (const event of this.events.values()) {\n      if (category && event.category !== category) continue;\n\n      stats.total++;\n      stats.byCategory[event.category]++;\n      stats.byAction[event.action] = (stats.byAction[event.action] || 0) + 1;\n      uniqueUsers.add(event.userId);\n    }\n\n    stats.uniqueUsers = uniqueUsers.size;\n    return stats;\n  }\n\n  /**\n   * Get top events\n   */\n  getTopEvents(limit: number = 10): Array<{ action: string; count: number }> {\n    const actionCounts: Record<string, number> = {};\n\n    for (const event of this.events.values()) {\n      actionCounts[event.action] = (actionCounts[event.action] || 0) + 1;\n    }\n\n    return Object.entries(actionCounts)\n      .map(([action, count]) => ({ action, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, limit);\n  }\n\n  /**\n   * End session\n   */\n  endSession(sessionId: string): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.endTime = Date.now();\n      this.emit('session:ended', { sessionId, duration: session.endTime - session.startTime });\n    }\n  }\n\n  /**\n   * Get dashboard data\n   */\n  getDashboardData(): {\n    totalEvents: number;\n    uniqueUsers: number;\n    totalSessions: number;\n    averageSessionDuration: number;\n    topEvents: Array<{ action: string; count: number }>;\n  } {\n    const stats = this.getEventStats();\n    const sessions = Array.from(this.sessions.values());\n    const sessionDurations = sessions\n      .filter((s) => s.endTime)\n      .map((s) => (s.endTime || 0) - s.startTime);\n    const averageSessionDuration =\n      sessionDurations.length > 0 ? sessionDurations.reduce((a, b) => a + b, 0) / sessionDurations.length : 0;\n\n    return {\n      totalEvents: stats.total,\n      uniqueUsers: stats.uniqueUsers,\n      totalSessions: sessions.length,\n      averageSessionDuration,\n      topEvents: this.getTopEvents(5),\n    };\n  }\n\n  /**\n   * Clear old events\n   */\n  clearOldEvents(olderThanDays: number): number {\n    const cutoffTime = Date.now() - olderThanDays * 24 * 60 * 60 * 1000;\n    let count = 0;\n\n    for (const [id, event] of this.events) {\n      if (event.timestamp < cutoffTime) {\n        this.events.delete(id);\n        count++;\n      }\n    }\n\n    this.emit('events:cleared', { count, olderThanDays });\n    return count;\n  }\n}\n
