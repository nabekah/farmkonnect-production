import { EventEmitter } from 'events';\n\nexport type SegmentationType = 'demographic' | 'behavioral' | 'geographic' | 'psychographic' | 'firmographic';\nexport type SegmentOperator = 'equals' | 'not_equals' | 'contains' | 'not_contains' | 'greater_than' | 'less_than' | 'in' | 'not_in' | 'between' | 'regex';\nexport type LogicalOperator = 'AND' | 'OR';\n\nexport interface SegmentRule {\n  id: string;\n  field: string;\n  operator: SegmentOperator;\n  value: any;\n  caseSensitive?: boolean;\n}\n\nexport interface SegmentGroup {\n  id: string;\n  rules: SegmentRule[];\n  operator: LogicalOperator;\n}\n\nexport interface UserSegment {\n  id: string;\n  name: string;\n  description: string;\n  type: SegmentationType;\n  rules: SegmentGroup[];\n  userIds: Set<string>;\n  createdAt: number;\n  updatedAt: number;\n  isActive: boolean;\n  metadata?: Record<string, any>;\n}\n\nexport interface UserProfile {\n  userId: string;\n  email: string;\n  role: string;\n  farmType?: string;\n  location?: string;\n  activityLevel?: 'low' | 'medium' | 'high';\n  joinedAt: number;\n  lastActiveAt: number;\n  properties: Record<string, any>;\n}\n\nexport interface SegmentationStatistics {\n  totalSegments: number;\n  activeSegments: number;\n  totalUsers: number;\n  segmentedUsers: number;\n  averageSegmentSize: number;\n  largestSegment: { name: string; size: number };\n  smallestSegment: { name: string; size: number };\n}\n\nclass UserSegmentationSystem extends EventEmitter {\n  private segments: Map<string, UserSegment> = new Map();\n  private userProfiles: Map<string, UserProfile> = new Map();\n  private segmentMembership: Map<string, Set<string>> = new Map(); // userId -> segmentIds\n  private segmentCache: Map<string, Set<string>> = new Map(); // segmentId -> userIds (cached)\n  private cacheExpiry: Map<string, number> = new Map();\n  private cacheTTL: number = 5 * 60 * 1000; // 5 minutes\n  private statistics: SegmentationStatistics = {\n    totalSegments: 0,\n    activeSegments: 0,\n    totalUsers: 0,\n    segmentedUsers: 0,\n    averageSegmentSize: 0,\n    largestSegment: { name: '', size: 0 },\n    smallestSegment: { name: '', size: 0 },\n  };\n\n  constructor() {\n    super();\n    this.startCacheCleanup();\n  }\n\n  /**\n   * Create user segment\n   */\n  createSegment(\n    name: string,\n    description: string,\n    type: SegmentationType,\n    rules: SegmentGroup[],\n    metadata?: Record<string, any>\n  ): UserSegment {\n    const segment: UserSegment = {\n      id: `seg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      description,\n      type,\n      rules,\n      userIds: new Set(),\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      isActive: true,\n      metadata,\n    };\n\n    this.segments.set(segment.id, segment);\n    this.statistics.totalSegments++;\n    this.statistics.activeSegments++;\n\n    this.emit('segment:created', segment);\n    return segment;\n  }\n\n  /**\n   * Add user profile\n   */\n  addUserProfile(profile: UserProfile): void {\n    this.userProfiles.set(profile.userId, profile);\n    this.statistics.totalUsers++;\n\n    if (!this.segmentMembership.has(profile.userId)) {\n      this.segmentMembership.set(profile.userId, new Set());\n    }\n\n    this.emit('user:added', profile);\n  }\n\n  /**\n   * Update user profile\n   */\n  updateUserProfile(userId: string, updates: Partial<UserProfile>): boolean {\n    const profile = this.userProfiles.get(userId);\n    if (!profile) return false;\n\n    Object.assign(profile, updates);\n    profile.lastActiveAt = Date.now();\n\n    // Invalidate segment cache\n    this.invalidateSegmentCache();\n\n    this.emit('user:updated', profile);\n    return true;\n  }\n\n  /**\n   * Evaluate rule\n   */\n  private evaluateRule(rule: SegmentRule, value: any): boolean {\n    switch (rule.operator) {\n      case 'equals':\n        if (rule.caseSensitive) {\n          return value === rule.value;\n        }\n        return String(value).toLowerCase() === String(rule.value).toLowerCase();\n\n      case 'not_equals':\n        if (rule.caseSensitive) {\n          return value !== rule.value;\n        }\n        return String(value).toLowerCase() !== String(rule.value).toLowerCase();\n\n      case 'contains':\n        return String(value).includes(String(rule.value));\n\n      case 'not_contains':\n        return !String(value).includes(String(rule.value));\n\n      case 'greater_than':\n        return Number(value) > Number(rule.value);\n\n      case 'less_than':\n        return Number(value) < Number(rule.value);\n\n      case 'in':\n        return Array.isArray(rule.value) && rule.value.includes(value);\n\n      case 'not_in':\n        return Array.isArray(rule.value) && !rule.value.includes(value);\n\n      case 'between':\n        if (Array.isArray(rule.value) && rule.value.length === 2) {\n          return Number(value) >= Number(rule.value[0]) && Number(value) <= Number(rule.value[1]);\n        }\n        return false;\n\n      case 'regex':\n        try {\n          const regex = new RegExp(rule.value);\n          return regex.test(String(value));\n        } catch {\n          return false;\n        }\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Evaluate rule group\n   */\n  private evaluateRuleGroup(group: SegmentGroup, profile: UserProfile): boolean {\n    const results = group.rules.map((rule) => {\n      const value = profile.properties[rule.field] || profile[rule.field as keyof UserProfile];\n      return this.evaluateRule(rule, value);\n    });\n\n    if (group.operator === 'AND') {\n      return results.every((r) => r);\n    } else {\n      return results.some((r) => r);\n    }\n  }\n\n  /**\n   * Check if user matches segment\n   */\n  userMatchesSegment(userId: string, segmentId: string): boolean {\n    const profile = this.userProfiles.get(userId);\n    const segment = this.segments.get(segmentId);\n\n    if (!profile || !segment || !segment.isActive) {\n      return false;\n    }\n\n    // Evaluate all rule groups\n    return segment.rules.every((group) => this.evaluateRuleGroup(group, profile));\n  }\n\n  /**\n   * Evaluate segment for all users\n   */\n  evaluateSegment(segmentId: string): Set<string> {\n    const segment = this.segments.get(segmentId);\n    if (!segment) return new Set();\n\n    const matchingUsers = new Set<string>();\n\n    for (const [userId, profile] of this.userProfiles.entries()) {\n      if (this.userMatchesSegment(userId, segmentId)) {\n        matchingUsers.add(userId);\n      }\n    }\n\n    segment.userIds = matchingUsers;\n    segment.updatedAt = Date.now();\n\n    // Update membership\n    for (const userId of matchingUsers) {\n      const membership = this.segmentMembership.get(userId);\n      if (membership) {\n        membership.add(segmentId);\n      }\n    }\n\n    // Cache result\n    this.segmentCache.set(segmentId, matchingUsers);\n    this.cacheExpiry.set(segmentId, Date.now() + this.cacheTTL);\n\n    this.emit('segment:evaluated', { segmentId, userCount: matchingUsers.size });\n    return matchingUsers;\n  }\n\n  /**\n   * Get segment members\n   */\n  getSegmentMembers(segmentId: string, useCache: boolean = true): Set<string> {\n    if (useCache) {\n      const cached = this.segmentCache.get(segmentId);\n      const expiry = this.cacheExpiry.get(segmentId);\n\n      if (cached && expiry && expiry > Date.now()) {\n        return new Set(cached);\n      }\n    }\n\n    return this.evaluateSegment(segmentId);\n  }\n\n  /**\n   * Get user segments\n   */\n  getUserSegments(userId: string): UserSegment[] {\n    const segmentIds = this.segmentMembership.get(userId);\n    if (!segmentIds) return [];\n\n    const userSegments: UserSegment[] = [];\n    for (const segmentId of segmentIds) {\n      const segment = this.segments.get(segmentId);\n      if (segment && segment.isActive) {\n        userSegments.push(segment);\n      }\n    }\n\n    return userSegments;\n  }\n\n  /**\n   * Add rule to segment\n   */\n  addRuleToSegment(segmentId: string, groupIndex: number, rule: SegmentRule): boolean {\n    const segment = this.segments.get(segmentId);\n    if (!segment || !segment.rules[groupIndex]) return false;\n\n    segment.rules[groupIndex].rules.push(rule);\n    segment.updatedAt = Date.now();\n    this.invalidateSegmentCache();\n\n    this.emit('rule:added', { segmentId, groupIndex, rule });\n    return true;\n  }\n\n  /**\n   * Remove rule from segment\n   */\n  removeRuleFromSegment(segmentId: string, groupIndex: number, ruleId: string): boolean {\n    const segment = this.segments.get(segmentId);\n    if (!segment || !segment.rules[groupIndex]) return false;\n\n    const ruleIndex = segment.rules[groupIndex].rules.findIndex((r) => r.id === ruleId);\n    if (ruleIndex < 0) return false;\n\n    segment.rules[groupIndex].rules.splice(ruleIndex, 1);\n    segment.updatedAt = Date.now();\n    this.invalidateSegmentCache();\n\n    this.emit('rule:removed', { segmentId, groupIndex, ruleId });\n    return true;\n  }\n\n  /**\n   * Get segment\n   */\n  getSegment(segmentId: string): UserSegment | undefined {\n    return this.segments.get(segmentId);\n  }\n\n  /**\n   * List segments\n   */\n  listSegments(type?: SegmentationType): UserSegment[] {\n    const segments = Array.from(this.segments.values());\n\n    if (type) {\n      return segments.filter((s) => s.type === type);\n    }\n\n    return segments;\n  }\n\n  /**\n   * Delete segment\n   */\n  deleteSegment(segmentId: string): boolean {\n    const segment = this.segments.get(segmentId);\n    if (!segment) return false;\n\n    // Remove from user memberships\n    for (const userId of segment.userIds) {\n      const membership = this.segmentMembership.get(userId);\n      if (membership) {\n        membership.delete(segmentId);\n      }\n    }\n\n    this.segments.delete(segmentId);\n    this.segmentCache.delete(segmentId);\n    this.cacheExpiry.delete(segmentId);\n\n    this.statistics.totalSegments--;\n    if (segment.isActive) {\n      this.statistics.activeSegments--;\n    }\n\n    this.emit('segment:deleted', { segmentId });\n    return true;\n  }\n\n  /**\n   * Activate segment\n   */\n  activateSegment(segmentId: string): boolean {\n    const segment = this.segments.get(segmentId);\n    if (!segment) return false;\n\n    if (!segment.isActive) {\n      segment.isActive = true;\n      this.statistics.activeSegments++;\n      this.invalidateSegmentCache();\n      this.emit('segment:activated', { segmentId });\n    }\n\n    return true;\n  }\n\n  /**\n   * Deactivate segment\n   */\n  deactivateSegment(segmentId: string): boolean {\n    const segment = this.segments.get(segmentId);\n    if (!segment) return false;\n\n    if (segment.isActive) {\n      segment.isActive = false;\n      this.statistics.activeSegments--;\n      this.invalidateSegmentCache();\n      this.emit('segment:deactivated', { segmentId });\n    }\n\n    return true;\n  }\n\n  /**\n   * Invalidate segment cache\n   */\n  private invalidateSegmentCache(): void {\n    this.segmentCache.clear();\n    this.cacheExpiry.clear();\n  }\n\n  /**\n   * Start cache cleanup\n   */\n  private startCacheCleanup(): void {\n    setInterval(() => {\n      const now = Date.now();\n      let cleaned = 0;\n\n      for (const [segmentId, expiry] of this.cacheExpiry.entries()) {\n        if (expiry < now) {\n          this.segmentCache.delete(segmentId);\n          this.cacheExpiry.delete(segmentId);\n          cleaned++;\n        }\n      }\n\n      if (cleaned > 0) {\n        this.emit('cache:cleanup', { itemsCleaned: cleaned });\n      }\n    }, 60000); // Run every minute\n  }\n\n  /**\n   * Update statistics\n   */\n  private updateStatistics(): void {\n    this.statistics.totalSegments = this.segments.size;\n    this.statistics.activeSegments = Array.from(this.segments.values()).filter((s) => s.isActive).length;\n    this.statistics.totalUsers = this.userProfiles.size;\n\n    let segmentedUsers = 0;\n    for (const membership of this.segmentMembership.values()) {\n      if (membership.size > 0) {\n        segmentedUsers++;\n      }\n    }\n    this.statistics.segmentedUsers = segmentedUsers;\n\n    // Calculate segment sizes\n    let totalSize = 0;\n    let minSize = Infinity;\n    let maxSize = 0;\n    let largestSegment = { name: '', size: 0 };\n    let smallestSegment = { name: '', size: Infinity };\n\n    for (const segment of this.segments.values()) {\n      if (segment.isActive) {\n        const size = segment.userIds.size;\n        totalSize += size;\n        minSize = Math.min(minSize, size);\n        maxSize = Math.max(maxSize, size);\n\n        if (size > largestSegment.size) {\n          largestSegment = { name: segment.name, size };\n        }\n\n        if (size < smallestSegment.size) {\n          smallestSegment = { name: segment.name, size };\n        }\n      }\n    }\n\n    this.statistics.averageSegmentSize =\n      this.statistics.activeSegments > 0 ? totalSize / this.statistics.activeSegments : 0;\n    this.statistics.largestSegment = largestSegment;\n    this.statistics.smallestSegment = smallestSegment.size === Infinity ? { name: '', size: 0 } : smallestSegment;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): SegmentationStatistics {\n    this.updateStatistics();\n    return { ...this.statistics };\n  }\n\n  /**\n   * Export segment\n   */\n  exportSegment(segmentId: string, format: 'csv' | 'json' = 'json'): string {\n    const members = this.getSegmentMembers(segmentId);\n    const segment = this.segments.get(segmentId);\n\n    if (!segment) return '';\n\n    const data = Array.from(members).map((userId) => {\n      const profile = this.userProfiles.get(userId);\n      return {\n        userId,\n        email: profile?.email,\n        role: profile?.role,\n        farmType: profile?.farmType,\n        location: profile?.location,\n      };\n    });\n\n    if (format === 'csv') {\n      const headers = ['userId', 'email', 'role', 'farmType', 'location'];\n      const rows = data.map((d) => headers.map((h) => d[h as keyof typeof d] || '').join(','));\n      return [headers.join(','), ...rows].join('\\n');\n    }\n\n    return JSON.stringify(data, null, 2);\n  }\n\n  /**\n   * Clone segment\n   */\n  cloneSegment(segmentId: string, newName: string): UserSegment | null {\n    const original = this.segments.get(segmentId);\n    if (!original) return null;\n\n    const cloned = this.createSegment(\n      newName,\n      `Clone of ${original.description}`,\n      original.type,\n      JSON.parse(JSON.stringify(original.rules)),\n      { ...original.metadata }\n    );\n\n    this.emit('segment:cloned', { originalId: segmentId, clonedId: cloned.id });\n    return cloned;\n  }\n}\n\nexport default UserSegmentationSystem;\n
