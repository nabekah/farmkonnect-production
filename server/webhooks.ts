import { EventEmitter } from 'events';\nimport crypto from 'crypto';\n\nexport type WebhookEvent = 'farm.created' | 'farm.updated' | 'farm.deleted' | 'user.created' | 'user.updated' | 'report.generated' | 'alert.triggered';\nexport type WebhookStatus = 'active' | 'inactive' | 'failed';\nexport type RetryStrategy = 'exponential' | 'linear' | 'fixed';\n\nexport interface WebhookPayload {\n  /**\n   * Event type\n   */\n  event: WebhookEvent;\n  /**\n   * Timestamp\n   */\n  timestamp: number;\n  /**\n   * Data\n   */\n  data: Record<string, any>;\n  /**\n   * Webhook ID\n   */\n  webhookId: string;\n}\n\nexport interface WebhookConfig {\n  /**\n   * Webhook ID\n   */\n  id: string;\n  /**\n   * Target URL\n   */\n  url: string;\n  /**\n   * Events to subscribe to\n   */\n  events: WebhookEvent[];\n  /**\n   * Secret for signing\n   */\n  secret: string;\n  /**\n   * Status\n   */\n  status: WebhookStatus;\n  /**\n   * Retry strategy\n   */\n  retryStrategy: RetryStrategy;\n  /**\n   * Max retries\n   */\n  maxRetries: number;\n  /**\n   * Retry delay in ms\n   */\n  retryDelay: number;\n  /**\n   * Timeout in ms\n   */\n  timeout: number;\n  /**\n   * Headers\n   */\n  headers?: Record<string, string>;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n}\n\nexport interface WebhookDelivery {\n  /**\n   * Delivery ID\n   */\n  id: string;\n  /**\n   * Webhook ID\n   */\n  webhookId: string;\n  /**\n   * Payload\n   */\n  payload: WebhookPayload;\n  /**\n   * Status\n   */\n  status: 'pending' | 'delivered' | 'failed';\n  /**\n   * Attempt count\n   */\n  attempts: number;\n  /**\n   * Response status\n   */\n  responseStatus?: number;\n  /**\n   * Response body\n   */\n  responseBody?: string;\n  /**\n   * Error\n   */\n  error?: string;\n  /**\n   * Next retry at\n   */\n  nextRetryAt?: number;\n  /**\n   * Created at\n   */\n  createdAt: number;\n  /**\n   * Updated at\n   */\n  updatedAt: number;\n}\n\n/**\n * Webhook Manager\n */\nexport class WebhookManager extends EventEmitter {\n  private webhooks: Map<string, WebhookConfig> = new Map();\n  private deliveries: Map<string, WebhookDelivery> = new Map();\n  private retryQueues: Map<string, NodeJS.Timeout> = new Map();\n\n  /**\n   * Register webhook\n   */\n  registerWebhook(config: WebhookConfig): void {\n    this.webhooks.set(config.id, config);\n    this.emit('webhook:registered', { id: config.id, url: config.url });\n  }\n\n  /**\n   * Get webhook\n   */\n  getWebhook(id: string): WebhookConfig | null {\n    return this.webhooks.get(id) || null;\n  }\n\n  /**\n   * Get all webhooks\n   */\n  getAllWebhooks(): WebhookConfig[] {\n    return Array.from(this.webhooks.values());\n  }\n\n  /**\n   * Get webhooks for event\n   */\n  getWebhooksForEvent(event: WebhookEvent): WebhookConfig[] {\n    return Array.from(this.webhooks.values()).filter(\n      (w) => w.status === 'active' && w.events.includes(event)\n    );\n  }\n\n  /**\n   * Update webhook\n   */\n  updateWebhook(id: string, updates: Partial<WebhookConfig>): boolean {\n    const webhook = this.webhooks.get(id);\n    if (!webhook) return false;\n\n    this.webhooks.set(id, { ...webhook, ...updates, updatedAt: Date.now() });\n    this.emit('webhook:updated', { id });\n    return true;\n  }\n\n  /**\n   * Delete webhook\n   */\n  deleteWebhook(id: string): boolean {\n    if (this.webhooks.delete(id)) {\n      this.emit('webhook:deleted', { id });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Trigger event\n   */\n  async triggerEvent(event: WebhookEvent, data: Record<string, any>): Promise<void> {\n    const webhooks = this.getWebhooksForEvent(event);\n    const payload: WebhookPayload = {\n      event,\n      timestamp: Date.now(),\n      data,\n      webhookId: '',\n    };\n\n    for (const webhook of webhooks) {\n      payload.webhookId = webhook.id;\n      await this.deliverPayload(webhook, payload);\n    }\n  }\n\n  /**\n   * Deliver payload\n   */\n  private async deliverPayload(webhook: WebhookConfig, payload: WebhookPayload): Promise<void> {\n    const deliveryId = crypto.randomUUID();\n    const delivery: WebhookDelivery = {\n      id: deliveryId,\n      webhookId: webhook.id,\n      payload,\n      status: 'pending',\n      attempts: 0,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.deliveries.set(deliveryId, delivery);\n    await this.attemptDelivery(webhook, delivery);\n  }\n\n  /**\n   * Attempt delivery\n   */\n  private async attemptDelivery(webhook: WebhookConfig, delivery: WebhookDelivery): Promise<void> {\n    delivery.attempts++;\n    delivery.updatedAt = Date.now();\n\n    try {\n      const signature = this.generateSignature(delivery.payload, webhook.secret);\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Webhook-Signature': signature,\n        'X-Webhook-ID': webhook.id,\n        'X-Delivery-ID': delivery.id,\n        ...webhook.headers,\n      };\n\n      const response = await fetch(webhook.url, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(delivery.payload),\n        signal: AbortSignal.timeout(webhook.timeout),\n      });\n\n      delivery.responseStatus = response.status;\n      delivery.responseBody = await response.text();\n\n      if (response.ok) {\n        delivery.status = 'delivered';\n        this.emit('delivery:success', { deliveryId, webhookId: webhook.id });\n      } else {\n        throw new Error(`HTTP ${response.status}`);\n      }\n    } catch (error) {\n      delivery.error = error instanceof Error ? error.message : 'Unknown error';\n\n      if (delivery.attempts < webhook.maxRetries) {\n        delivery.status = 'pending';\n        const delay = this.calculateRetryDelay(webhook, delivery.attempts);\n        delivery.nextRetryAt = Date.now() + delay;\n\n        const timeoutId = setTimeout(() => {\n          this.attemptDelivery(webhook, delivery);\n        }, delay);\n\n        this.retryQueues.set(delivery.id, timeoutId);\n        this.emit('delivery:retry', { deliveryId: delivery.id, attempt: delivery.attempts, nextRetry: delay });\n      } else {\n        delivery.status = 'failed';\n        this.emit('delivery:failed', { deliveryId: delivery.id, error: delivery.error });\n      }\n    }\n  }\n\n  /**\n   * Calculate retry delay\n   */\n  private calculateRetryDelay(webhook: WebhookConfig, attempt: number): number {\n    switch (webhook.retryStrategy) {\n      case 'exponential':\n        return webhook.retryDelay * Math.pow(2, attempt - 1);\n      case 'linear':\n        return webhook.retryDelay * attempt;\n      case 'fixed':\n        return webhook.retryDelay;\n      default:\n        return webhook.retryDelay;\n    }\n  }\n\n  /**\n   * Generate signature\n   */\n  private generateSignature(payload: WebhookPayload, secret: string): string {\n    const data = JSON.stringify(payload);\n    return crypto.createHmac('sha256', secret).update(data).digest('hex');\n  }\n\n  /**\n   * Get delivery\n   */\n  getDelivery(id: string): WebhookDelivery | null {\n    return this.deliveries.get(id) || null;\n  }\n\n  /**\n   * Get deliveries for webhook\n   */\n  getDeliveriesForWebhook(webhookId: string, limit: number = 100): WebhookDelivery[] {\n    return Array.from(this.deliveries.values())\n      .filter((d) => d.webhookId === webhookId)\n      .sort((a, b) => b.createdAt - a.createdAt)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get delivery stats\n   */\n  getDeliveryStats(webhookId?: string): {\n    total: number;\n    delivered: number;\n    failed: number;\n    pending: number;\n    successRate: number;\n  } {\n    const deliveries = webhookId\n      ? Array.from(this.deliveries.values()).filter((d) => d.webhookId === webhookId)\n      : Array.from(this.deliveries.values());\n\n    const stats = {\n      total: deliveries.length,\n      delivered: deliveries.filter((d) => d.status === 'delivered').length,\n      failed: deliveries.filter((d) => d.status === 'failed').length,\n      pending: deliveries.filter((d) => d.status === 'pending').length,\n      successRate: 0,\n    };\n\n    if (stats.total > 0) {\n      stats.successRate = (stats.delivered / stats.total) * 100;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Retry failed delivery\n   */\n  async retryDelivery(deliveryId: string): Promise<boolean> {\n    const delivery = this.deliveries.get(deliveryId);\n    if (!delivery) return false;\n\n    const webhook = this.webhooks.get(delivery.webhookId);\n    if (!webhook) return false;\n\n    delivery.attempts = 0;\n    delivery.status = 'pending';\n    delivery.error = undefined;\n    delivery.nextRetryAt = undefined;\n\n    await this.attemptDelivery(webhook, delivery);\n    return true;\n  }\n\n  /**\n   * Cancel delivery\n   */\n  cancelDelivery(deliveryId: string): boolean {\n    const timeout = this.retryQueues.get(deliveryId);\n    if (timeout) {\n      clearTimeout(timeout);\n      this.retryQueues.delete(deliveryId);\n    }\n\n    const delivery = this.deliveries.get(deliveryId);\n    if (delivery) {\n      delivery.status = 'failed';\n      delivery.error = 'Cancelled by user';\n      this.emit('delivery:cancelled', { deliveryId });\n      return true;\n    }\n\n    return false;\n  }\n}\n
