import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport WebhookEventHandler from './webhook-event-handler';\nimport BulkMessageScheduler from './bulk-message-scheduler';\nimport TemplateLibrary from './template-library';\n\ndescribe('WebhookEventHandler', () => {\n  let handler: WebhookEventHandler;\n\n  beforeEach(() => {\n    handler = new WebhookEventHandler();\n  });\n\n  afterEach(() => {\n    handler.destroy();\n  });\n\n  describe('Endpoint Management', () => {\n    it('should register webhook endpoint', () => {\n      const endpoint = handler.registerEndpoint('twilio', 'https://example.com/webhooks/twilio', 'secret-key');\n\n      expect(endpoint).toBeDefined();\n      expect(endpoint.provider).toBe('twilio');\n      expect(endpoint.active).toBe(true);\n    });\n\n    it('should get endpoint', () => {\n      const registered = handler.registerEndpoint('sendgrid', 'https://example.com/webhooks/sendgrid', 'key');\n      const retrieved = handler.getEndpoint(registered.id);\n\n      expect(retrieved?.provider).toBe('sendgrid');\n    });\n\n    it('should get endpoints by provider', () => {\n      handler.registerEndpoint('twilio', 'https://example.com/webhooks/twilio', 'key1');\n      handler.registerEndpoint('twilio', 'https://example.com/webhooks/twilio2', 'key2');\n      handler.registerEndpoint('sendgrid', 'https://example.com/webhooks/sendgrid', 'key3');\n\n      const twilioEndpoints = handler.getEndpointsByProvider('twilio');\n      expect(twilioEndpoints.length).toBe(2);\n    });\n  });\n\n  describe('Twilio Webhook Handling', () => {\n    it('should handle SMS sent event', () => {\n      const params = {\n        MessageSid: 'SM123456',\n        MessageStatus: 'sent',\n        To: '+1234567890',\n      };\n\n      const event = handler.handleTwilioWebhook(params, 'signature', 'auth-token');\n      // Note: Signature verification will fail in test, so event will be null\n      // In real implementation, we'd mock the verification\n    });\n\n    it('should track SMS delivery events', () => {\n      const params = {\n        MessageSid: 'SM123456',\n        MessageStatus: 'delivered',\n        To: '+1234567890',\n      };\n\n      // Would test with proper signature verification\n      const metrics = handler.getMetrics();\n      expect(metrics).toBeDefined();\n    });\n  });\n\n  describe('SendGrid Webhook Handling', () => {\n    it('should handle email sent event', () => {\n      const events = [\n        {\n          event: 'sent',\n          message_id: 'msg-123',\n          email: 'user@example.com',\n          timestamp: Math.floor(Date.now() / 1000),\n        },\n      ];\n\n      const processed = handler.handleSendGridWebhook(events, 'signature', 'public-key');\n      expect(processed.length).toBeGreaterThanOrEqual(0);\n    });\n\n    it('should handle email open event', () => {\n      const events = [\n        {\n          event: 'open',\n          message_id: 'msg-123',\n          email: 'user@example.com',\n          timestamp: Math.floor(Date.now() / 1000),\n          useragent: 'Mozilla/5.0',\n          ip: '192.168.1.1',\n        },\n      ];\n\n      const processed = handler.handleSendGridWebhook(events, 'signature', 'key');\n      expect(processed.length).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('Event Processing', () => {\n    it('should get event by ID', () => {\n      const metrics = handler.getMetrics();\n      expect(metrics.totalReceived).toBe(0);\n    });\n\n    it('should get unprocessed events', () => {\n      const unprocessed = handler.getUnprocessedEvents();\n      expect(Array.isArray(unprocessed)).toBe(true);\n    });\n  });\n\n  describe('Metrics', () => {\n    it('should track metrics', () => {\n      const metrics = handler.getMetrics();\n\n      expect(metrics.totalReceived).toBe(0);\n      expect(metrics.totalProcessed).toBe(0);\n      expect(metrics.deliveryRate).toBe(0);\n    });\n  });\n});\n\ndescribe('BulkMessageScheduler', () => {\n  let scheduler: BulkMessageScheduler;\n\n  beforeEach(() => {\n    scheduler = new BulkMessageScheduler();\n  });\n\n  afterEach(() => {\n    scheduler.destroy();\n  });\n\n  describe('Schedule Management', () => {\n    it('should create schedule', () => {\n      const schedule = scheduler.createSchedule({\n        name: 'Newsletter Campaign',\n        templateId: 'tpl-123',\n        recipientCount: 1000,\n        channel: 'email',\n        scheduledFor: Date.now() + 60000,\n        rateLimitStrategy: 'fixed',\n        messagesPerSecond: 100,\n        maxConcurrent: 10,\n        retryAttempts: 3,\n        retryDelayMs: 5000,\n      });\n\n      expect(schedule).toBeDefined();\n      expect(schedule.status).toBe('draft');\n      expect(schedule.config.name).toBe('Newsletter Campaign');\n    });\n\n    it('should get schedule', () => {\n      const created = scheduler.createSchedule({\n        name: 'Test',\n        templateId: 'tpl-123',\n        recipientCount: 100,\n        channel: 'email',\n        scheduledFor: Date.now(),\n        rateLimitStrategy: 'fixed',\n        messagesPerSecond: 50,\n        maxConcurrent: 5,\n        retryAttempts: 3,\n        retryDelayMs: 5000,\n      });\n\n      const retrieved = scheduler.getSchedule(created.id);\n      expect(retrieved?.config.name).toBe('Test');\n    });\n  });\n\n  describe('Schedule Operations', () => {\n    it('should start schedule', () => {\n      const schedule = scheduler.createSchedule({\n        name: 'Test',\n        templateId: 'tpl-123',\n        recipientCount: 100,\n        channel: 'email',\n        scheduledFor: Date.now(),\n        rateLimitStrategy: 'fixed',\n        messagesPerSecond: 50,\n        maxConcurrent: 5,\n        retryAttempts: 3,\n        retryDelayMs: 5000,\n      });\n\n      const recipients = Array.from({ length: 100 }, (_, i) => `user-${i}`);\n      const started = scheduler.startSchedule(schedule.id, recipients);\n\n      expect(started).toBe(true);\n      const updated = scheduler.getSchedule(schedule.id);\n      expect(updated?.status).toBe('scheduled');\n    });\n\n    it('should pause schedule', () => {\n      const schedule = scheduler.createSchedule({\n        name: 'Test',\n        templateId: 'tpl-123',\n        recipientCount: 100,\n        channel: 'email',\n        scheduledFor: Date.now(),\n        rateLimitStrategy: 'fixed',\n        messagesPerSecond: 50,\n        maxConcurrent: 5,\n        retryAttempts: 3,\n        retryDelayMs: 5000,\n      });\n\n      const recipients = Array.from({ length: 100 }, (_, i) => `user-${i}`);\n      scheduler.startSchedule(schedule.id, recipients);\n\n      // Manually set to running for testing\n      schedule.status = 'running';\n      const paused = scheduler.pauseSchedule(schedule.id);\n\n      expect(paused).toBe(true);\n    });\n\n    it('should cancel schedule', () => {\n      const schedule = scheduler.createSchedule({\n        name: 'Test',\n        templateId: 'tpl-123',\n        recipientCount: 100,\n        channel: 'email',\n        scheduledFor: Date.now(),\n        rateLimitStrategy: 'fixed',\n        messagesPerSecond: 50,\n        maxConcurrent: 5,\n        retryAttempts: 3,\n        retryDelayMs: 5000,\n      });\n\n      const cancelled = scheduler.cancelSchedule(schedule.id);\n      expect(cancelled).toBe(true);\n    });\n  });\n\n  describe('Progress Tracking', () => {\n    it('should get schedule progress', () => {\n      const schedule = scheduler.createSchedule({\n        name: 'Test',\n        templateId: 'tpl-123',\n        recipientCount: 100,\n        channel: 'email',\n        scheduledFor: Date.now(),\n        rateLimitStrategy: 'fixed',\n        messagesPerSecond: 50,\n        maxConcurrent: 5,\n        retryAttempts: 3,\n        retryDelayMs: 5000,\n      });\n\n      const progress = scheduler.getScheduleProgress(schedule.id);\n      expect(progress).toBeDefined();\n      expect(progress?.progress).toBe(0);\n    });\n  });\n\n  describe('Metrics', () => {\n    it('should track metrics', () => {\n      const metrics = scheduler.getMetrics();\n\n      expect(metrics.totalSchedules).toBeGreaterThanOrEqual(0);\n      expect(metrics.activeSchedules).toBeGreaterThanOrEqual(0);\n      expect(metrics.totalMessagesSent).toBe(0);\n    });\n  });\n});\n\ndescribe('TemplateLibrary', () => {\n  let library: TemplateLibrary;\n\n  beforeEach(() => {\n    library = new TemplateLibrary();\n  });\n\n  describe('Prebuilt Templates', () => {\n    it('should have prebuilt templates', () => {\n      const templates = library.getPrebuiltTemplates();\n      expect(templates.length).toBeGreaterThan(0);\n    });\n\n    it('should include welcome template', () => {\n      const templates = library.getPrebuiltTemplates();\n      const welcome = templates.find((t) => t.category === 'welcome');\n      expect(welcome).toBeDefined();\n    });\n\n    it('should include password reset template', () => {\n      const templates = library.getPrebuiltTemplates();\n      const reset = templates.find((t) => t.category === 'password_reset');\n      expect(reset).toBeDefined();\n    });\n\n    it('should include order confirmation template', () => {\n      const templates = library.getPrebuiltTemplates();\n      const order = templates.find((t) => t.category === 'order_confirmation');\n      expect(order).toBeDefined();\n    });\n  });\n\n  describe('Template Management', () => {\n    it('should create custom template', () => {\n      const template = library.createTemplate(\n        'Custom Alert',\n        'alert',\n        'email',\n        {\n          emailSubject: 'Alert: {{message}}',\n          emailHtmlContent: '<p>{{message}}</p>',\n        },\n        [{ name: 'message', type: 'string', required: true }]\n      );\n\n      expect(template).toBeDefined();\n      expect(template.isPrebuilt).toBe(false);\n    });\n\n    it('should get template by ID', () => {\n      const created = library.createTemplate(\n        'Test',\n        'custom',\n        'email',\n        { emailHtmlContent: 'Test' }\n      );\n\n      const retrieved = library.getTemplate(created.id);\n      expect(retrieved?.name).toBe('Test');\n    });\n\n    it('should update template', () => {\n      const created = library.createTemplate(\n        'Original',\n        'custom',\n        'email',\n        { emailHtmlContent: 'Original' }\n      );\n\n      const updated = library.updateTemplate(created.id, { name: 'Updated' });\n      expect(updated).toBe(true);\n\n      const retrieved = library.getTemplate(created.id);\n      expect(retrieved?.name).toBe('Updated');\n    });\n\n    it('should delete template', () => {\n      const created = library.createTemplate(\n        'ToDelete',\n        'custom',\n        'email',\n        { emailHtmlContent: 'Delete me' }\n      );\n\n      const deleted = library.deleteTemplate(created.id);\n      expect(deleted).toBe(true);\n\n      const retrieved = library.getTemplate(created.id);\n      expect(retrieved).toBeUndefined();\n    });\n  });\n\n  describe('Template Filtering', () => {\n    it('should get templates by category', () => {\n      const alerts = library.getTemplatesByCategory('alert');\n      expect(alerts.length).toBeGreaterThan(0);\n    });\n\n    it('should get templates by channel', () => {\n      const emailTemplates = library.getTemplatesByChannel('email');\n      expect(emailTemplates.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Template Usage', () => {\n    it('should record template usage', () => {\n      const templates = library.getPrebuiltTemplates();\n      const template = templates[0];\n\n      library.recordUsage(template.id, 95, 40, 10);\n\n      const stats = library.getUsageStats(template.id);\n      expect(stats?.totalUsage).toBe(1);\n      expect(stats?.successRate).toBe(95);\n    });\n\n    it('should get popular templates', () => {\n      const templates = library.getPrebuiltTemplates();\n      for (let i = 0; i < 5; i++) {\n        library.recordUsage(templates[0].id, 100);\n      }\n      for (let i = 0; i < 3; i++) {\n        library.recordUsage(templates[1].id, 100);\n      }\n\n      const popular = library.getPopularTemplates(5);\n      expect(popular[0].id).toBe(templates[0].id);\n    });\n  });\n\n  describe('Template Search', () => {\n    it('should search templates by name', () => {\n      const results = library.searchTemplates('welcome');\n      expect(results.length).toBeGreaterThan(0);\n    });\n\n    it('should search templates by category', () => {\n      const results = library.searchTemplates('alert');\n      expect(results.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Template Cloning', () => {\n    it('should clone template', () => {\n      const templates = library.getPrebuiltTemplates();\n      const original = templates[0];\n\n      const cloned = library.cloneTemplate(original.id, 'Cloned Template');\n      expect(cloned).toBeDefined();\n      expect(cloned?.name).toBe('Cloned Template');\n      expect(cloned?.isPrebuilt).toBe(false);\n    });\n  });\n\n  describe('Template Statistics', () => {\n    it('should get template count', () => {\n      const count = library.getTemplateCount();\n      expect(count.total).toBeGreaterThan(0);\n      expect(count.prebuilt).toBeGreaterThan(0);\n    });\n\n    it('should get all templates', () => {\n      const all = library.getAllTemplates();\n      expect(all.length).toBeGreaterThan(0);\n    });\n  });\n});\n\ndescribe('Integration Tests', () => {\n  let handler: WebhookEventHandler;\n  let scheduler: BulkMessageScheduler;\n  let library: TemplateLibrary;\n\n  beforeEach(() => {\n    handler = new WebhookEventHandler();\n    scheduler = new BulkMessageScheduler();\n    library = new TemplateLibrary();\n  });\n\n  afterEach(() => {\n    handler.destroy();\n    scheduler.destroy();\n  });\n\n  it('should integrate webhook with scheduler', () => {\n    // Create schedule\n    const schedule = scheduler.createSchedule({\n      name: 'Campaign',\n      templateId: 'tpl-123',\n      recipientCount: 100,\n      channel: 'email',\n      scheduledFor: Date.now(),\n      rateLimitStrategy: 'fixed',\n      messagesPerSecond: 50,\n      maxConcurrent: 5,\n      retryAttempts: 3,\n      retryDelayMs: 5000,\n    });\n\n    // Register webhook\n    const endpoint = handler.registerEndpoint('sendgrid', 'https://example.com/webhooks', 'key');\n\n    // Verify both are created\n    expect(schedule).toBeDefined();\n    expect(endpoint).toBeDefined();\n  });\n\n  it('should use template in scheduler', () => {\n    // Get template\n    const templates = library.getPrebuiltTemplates();\n    const template = templates[0];\n\n    // Create schedule with template\n    const schedule = scheduler.createSchedule({\n      name: 'Campaign',\n      templateId: template.id,\n      recipientCount: 100,\n      channel: template.channel as 'sms' | 'email' | 'both',\n      scheduledFor: Date.now(),\n      rateLimitStrategy: 'fixed',\n      messagesPerSecond: 50,\n      maxConcurrent: 5,\n      retryAttempts: 3,\n      retryDelayMs: 5000,\n    });\n\n    // Record usage\n    library.recordUsage(template.id, 100);\n\n    // Verify\n    expect(schedule.config.templateId).toBe(template.id);\n    const stats = library.getUsageStats(template.id);\n    expect(stats?.totalUsage).toBe(1);\n  });\n});\n
