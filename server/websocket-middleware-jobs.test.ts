import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { JobQueue, ScheduledJobManager, Job } from './jobs';\nimport { MiddlewareChain, rateLimit, validateRequest } from './middleware';\nimport { WebSocketRoomManager } from './websocket';\nimport { z } from 'zod';\n\n/**\n * Job Queue E2E Tests\n */\ndescribe('Job Queue E2E', () => {\n  let queue: JobQueue;\n\n  beforeEach(() => {\n    queue = new JobQueue(2);\n  });\n\n  afterEach(() => {\n    queue.stop();\n  });\n\n  it('should add job to queue', async () => {\n    const jobId = await queue.add({\n      name: 'test-job',\n      data: { message: 'hello' },\n    });\n\n    expect(jobId).toBeDefined();\n    const job = queue.getJob(jobId);\n    expect(job?.status).toBe('pending');\n  });\n\n  it('should process job successfully', async () => {\n    const handler = vi.fn(async () => {\n      // Simulate work\n      await new Promise((resolve) => setTimeout(resolve, 10));\n    });\n\n    queue.register('test-job', handler);\n\n    const jobId = await queue.add({\n      name: 'test-job',\n      data: { message: 'test' },\n    });\n\n    // Wait for processing\n    await new Promise((resolve) => {\n      queue.on('job:completed', (job) => {\n        if (job.id === jobId) resolve(null);\n      });\n      setTimeout(resolve, 1000);\n    });\n\n    const job = queue.getJob(jobId);\n    expect(job?.status).toBe('completed');\n    expect(handler).toHaveBeenCalled();\n  });\n\n  it('should retry failed job', async () => {\n    let attempts = 0;\n    const handler = vi.fn(async () => {\n      attempts++;\n      if (attempts < 2) {\n        throw new Error('Temporary failure');\n      }\n    });\n\n    queue.register('retry-job', handler);\n\n    const jobId = await queue.add({\n      name: 'retry-job',\n      data: {},\n      maxRetries: 2,\n      retryDelay: 10,\n    });\n\n    // Wait for retry\n    await new Promise((resolve) => {\n      let completed = false;\n      queue.on('job:completed', (job) => {\n        if (job.id === jobId) {\n          completed = true;\n          resolve(null);\n        }\n      });\n      setTimeout(() => {\n        if (!completed) resolve(null);\n      }, 2000);\n    });\n\n    expect(handler.mock.calls.length).toBeGreaterThanOrEqual(1);\n  });\n\n  it('should handle max retries', async () => {\n    const handler = vi.fn(async () => {\n      throw new Error('Always fails');\n    });\n\n    queue.register('fail-job', handler);\n\n    const jobId = await queue.add({\n      name: 'fail-job',\n      data: {},\n      maxRetries: 1,\n      retryDelay: 10,\n    });\n\n    // Wait for failure\n    await new Promise((resolve) => {\n      queue.on('job:failed', (job) => {\n        if (job.id === jobId) resolve(null);\n      });\n      setTimeout(resolve, 1000);\n    });\n\n    const job = queue.getJob(jobId);\n    expect(job?.status).toBe('failed');\n  });\n\n  it('should cancel job', async () => {\n    const jobId = await queue.add({\n      name: 'test-job',\n      data: {},\n    });\n\n    queue.cancelJob(jobId);\n\n    const job = queue.getJob(jobId);\n    expect(job?.status).toBe('cancelled');\n  });\n\n  it('should get queue stats', async () => {\n    await queue.add({ name: 'job1', data: {} });\n    await queue.add({ name: 'job2', data: {} });\n\n    const stats = queue.getStats();\n    expect(stats.total).toBe(2);\n    expect(stats.pending).toBe(2);\n  });\n\n  it('should clear completed jobs', async () => {\n    const handler = vi.fn(async () => {});\n    queue.register('test-job', handler);\n\n    const jobId = await queue.add({\n      name: 'test-job',\n      data: {},\n    });\n\n    // Wait for completion\n    await new Promise((resolve) => {\n      queue.on('job:completed', () => resolve(null));\n      setTimeout(resolve, 1000);\n    });\n\n    const cleared = queue.clearCompleted();\n    expect(cleared).toBeGreaterThan(0);\n  });\n});\n\n/**\n * Scheduled Job Manager E2E Tests\n */\ndescribe('Scheduled Job Manager E2E', () => {\n  let queue: JobQueue;\n  let scheduler: ScheduledJobManager;\n\n  beforeEach(() => {\n    queue = new JobQueue();\n    scheduler = new ScheduledJobManager(queue);\n  });\n\n  afterEach(() => {\n    scheduler.stopAll();\n    queue.stop();\n  });\n\n  it('should schedule recurring job', async () => {\n    const handler = vi.fn(async () => {});\n\n    const jobId = scheduler.scheduleRecurring('test', 100, handler);\n\n    expect(jobId).toBeDefined();\n\n    // Wait for execution\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(handler.mock.calls.length).toBeGreaterThan(0);\n  });\n\n  it('should schedule cron job', async () => {\n    const handler = vi.fn(async () => {});\n\n    const jobId = scheduler.scheduleCron('test', '* * * * *', handler);\n\n    expect(jobId).toBeDefined();\n    expect(scheduler.getAll()).toContain(jobId);\n  });\n\n  it('should cancel scheduled job', async () => {\n    const handler = vi.fn(async () => {});\n\n    const jobId = scheduler.scheduleRecurring('test', 100, handler);\n    scheduler.cancel(jobId);\n\n    expect(scheduler.getAll()).not.toContain(jobId);\n  });\n\n  it('should validate cron expression', () => {\n    expect(() => {\n      scheduler.scheduleCron('test', 'invalid', async () => {});\n    }).toThrow();\n  });\n});\n\n/**\n * Middleware E2E Tests\n */\ndescribe('Middleware E2E', () => {\n  it('should build middleware chain', () => {\n    const chain = new MiddlewareChain();\n    const middleware1 = vi.fn((req, res, next) => next());\n    const middleware2 = vi.fn((req, res, next) => next());\n\n    chain.add(middleware1).add(middleware2);\n\n    const built = chain.build();\n    expect(typeof built).toBe('function');\n  });\n\n  it('should execute middleware chain in order', () => {\n    const order: number[] = [];\n    const chain = new MiddlewareChain();\n\n    chain\n      .add((req, res, next) => {\n        order.push(1);\n        next();\n      })\n      .add((req, res, next) => {\n        order.push(2);\n        next();\n      });\n\n    const built = chain.build();\n    const req = {} as any;\n    const res = {} as any;\n    const next = () => order.push(3);\n\n    built(req, res, next);\n\n    expect(order).toEqual([1, 2, 3]);\n  });\n\n  it('should handle rate limiting', () => {\n    const middleware = rateLimit({\n      windowMs: 1000,\n      maxRequests: 2,\n    });\n\n    let callCount = 0;\n    const req = { ip: '127.0.0.1' } as any;\n    const res = {\n      status: vi.fn().mockReturnThis(),\n      json: vi.fn(),\n    } as any;\n    const next = vi.fn();\n\n    // First request\n    middleware(req, res, next);\n    expect(next).toHaveBeenCalled();\n\n    // Second request\n    middleware(req, res, next);\n    expect(next).toHaveBeenCalledTimes(2);\n\n    // Third request (should be rate limited)\n    middleware(req, res, next);\n    expect(res.status).toHaveBeenCalledWith(429);\n  });\n});\n\n/**\n * WebSocket Room Manager E2E Tests\n */\ndescribe('WebSocket Room Manager E2E', () => {\n  let roomManager: WebSocketRoomManager;\n  let mockWsServer: any;\n\n  beforeEach(() => {\n    mockWsServer = {\n      sendToUser: vi.fn(),\n    };\n    roomManager = new WebSocketRoomManager(mockWsServer);\n  });\n\n  it('should join room', () => {\n    roomManager.joinRoom('farm:1', 123);\n\n    const info = roomManager.getRoomInfo('farm:1');\n    expect(info?.members).toBe(1);\n  });\n\n  it('should leave room', () => {\n    roomManager.joinRoom('farm:1', 123);\n    roomManager.leaveRoom('farm:1', 123);\n\n    const info = roomManager.getRoomInfo('farm:1');\n    expect(info).toBeNull();\n  });\n\n  it('should broadcast to room', () => {\n    roomManager.joinRoom('farm:1', 123);\n    roomManager.joinRoom('farm:1', 456);\n\n    const message = {\n      type: 'update',\n      data: { test: true },\n      timestamp: Date.now(),\n    };\n\n    roomManager.broadcastToRoom('farm:1', message);\n\n    expect(mockWsServer.sendToUser).toHaveBeenCalledTimes(2);\n  });\n\n  it('should get all rooms', () => {\n    roomManager.joinRoom('farm:1', 123);\n    roomManager.joinRoom('farm:2', 456);\n\n    const rooms = roomManager.getAllRooms();\n    expect(rooms.length).toBe(2);\n  });\n\n  it('should register message handler', () => {\n    const handler = vi.fn();\n    roomManager.registerHandler('test', handler);\n\n    expect(handler).toBeDefined();\n  });\n});\n\n/**\n * Integration E2E Tests\n */\ndescribe('Integration E2E', () => {\n  it('should work together: jobs + scheduling', async () => {\n    const queue = new JobQueue();\n    const scheduler = new ScheduledJobManager(queue);\n\n    const jobHandler = vi.fn(async () => {});\n    queue.register('periodic', jobHandler);\n\n    // Schedule recurring job that adds to queue\n    scheduler.scheduleRecurring('add-jobs', 100, async () => {\n      await queue.add({\n        name: 'periodic',\n        data: {},\n      });\n    });\n\n    // Wait for execution\n    await new Promise((resolve) => setTimeout(resolve, 250));\n\n    scheduler.stopAll();\n    queue.stop();\n\n    expect(jobHandler.mock.calls.length).toBeGreaterThan(0);\n  });\n\n  it('should handle complex job workflow', async () => {\n    const queue = new JobQueue();\n    const results: string[] = [];\n\n    queue.register('step1', async (job) => {\n      results.push('step1');\n    });\n\n    queue.register('step2', async (job) => {\n      results.push('step2');\n    });\n\n    const job1 = await queue.add({ name: 'step1', data: {} });\n    const job2 = await queue.add({ name: 'step2', data: {} });\n\n    // Wait for processing\n    await new Promise((resolve) => {\n      let completed = 0;\n      queue.on('job:completed', () => {\n        completed++;\n        if (completed === 2) resolve(null);\n      });\n      setTimeout(resolve, 1000);\n    });\n\n    queue.stop();\n\n    expect(results.length).toBeGreaterThanOrEqual(2);\n  });\n});\n
