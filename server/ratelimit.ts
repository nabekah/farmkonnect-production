import { EventEmitter } from 'events';\n\nexport type RateLimitStrategy = 'fixed-window' | 'sliding-window' | 'token-bucket' | 'leaky-bucket';\n\nexport interface RateLimitConfig {\n  /**\n   * Rate limit strategy\n   */\n  strategy: RateLimitStrategy;\n  /**\n   * Requests per window\n   */\n  requestsPerWindow: number;\n  /**\n   * Window size in milliseconds\n   */\n  windowMs: number;\n  /**\n   * Key generator function\n   */\n  keyGenerator?: (context: any) => string;\n}\n\nexport interface QuotaConfig {\n  /**\n   * Daily quota\n   */\n  dailyQuota: number;\n  /**\n   * Monthly quota\n   */\n  monthlyQuota: number;\n  /**\n   * Reset time (hour of day)\n   */\n  resetHour?: number;\n}\n\nexport interface RateLimitStatus {\n  /**\n   * Is allowed\n   */\n  allowed: boolean;\n  /**\n   * Remaining requests\n   */\n  remaining: number;\n  /**\n   * Total limit\n   */\n  limit: number;\n  /**\n   * Reset time\n   */\n  resetAt: number;\n  /**\n   * Retry after (seconds)\n   */\n  retryAfter?: number;\n}\n\n/**\n * Rate Limiter with multiple strategies\n */\nexport class RateLimiter extends EventEmitter {\n  private config: RateLimitConfig;\n  private requests: Map<string, number[]> = new Map();\n  private tokens: Map<string, number> = new Map();\n\n  constructor(config: RateLimitConfig) {\n    super();\n    this.config = config;\n  }\n\n  /**\n   * Check rate limit\n   */\n  check(key: string): RateLimitStatus {\n    const now = Date.now();\n\n    switch (this.config.strategy) {\n      case 'fixed-window':\n        return this.checkFixedWindow(key, now);\n      case 'sliding-window':\n        return this.checkSlidingWindow(key, now);\n      case 'token-bucket':\n        return this.checkTokenBucket(key, now);\n      case 'leaky-bucket':\n        return this.checkLeakyBucket(key, now);\n      default:\n        return this.checkFixedWindow(key, now);\n    }\n  }\n\n  /**\n   * Fixed window strategy\n   */\n  private checkFixedWindow(key: string, now: number): RateLimitStatus {\n    const windowStart = Math.floor(now / this.config.windowMs) * this.config.windowMs;\n    const windowKey = `${key}:${windowStart}`;\n\n    let count = this.requests.get(windowKey) || 0;\n    const allowed = count < this.config.requestsPerWindow;\n\n    if (allowed) {\n      this.requests.set(windowKey, count + 1);\n      this.emit('ratelimit:allowed', { key, strategy: 'fixed-window' });\n    } else {\n      this.emit('ratelimit:blocked', { key, strategy: 'fixed-window' });\n    }\n\n    const resetAt = windowStart + this.config.windowMs;\n\n    return {\n      allowed,\n      remaining: Math.max(0, this.config.requestsPerWindow - count - 1),\n      limit: this.config.requestsPerWindow,\n      resetAt,\n      retryAfter: allowed ? undefined : Math.ceil((resetAt - now) / 1000),\n    };\n  }\n\n  /**\n   * Sliding window strategy\n   */\n  private checkSlidingWindow(key: string, now: number): RateLimitStatus {\n    if (!this.requests.has(key)) {\n      this.requests.set(key, []);\n    }\n\n    const windowStart = now - this.config.windowMs;\n    let requests = this.requests.get(key)!;\n    requests = requests.filter((time) => time > windowStart);\n\n    const allowed = requests.length < this.config.requestsPerWindow;\n\n    if (allowed) {\n      requests.push(now);\n      this.requests.set(key, requests);\n      this.emit('ratelimit:allowed', { key, strategy: 'sliding-window' });\n    } else {\n      this.emit('ratelimit:blocked', { key, strategy: 'sliding-window' });\n    }\n\n    const resetAt = requests.length > 0 ? requests[0] + this.config.windowMs : now + this.config.windowMs;\n\n    return {\n      allowed,\n      remaining: Math.max(0, this.config.requestsPerWindow - requests.length - 1),\n      limit: this.config.requestsPerWindow,\n      resetAt,\n      retryAfter: allowed ? undefined : Math.ceil((resetAt - now) / 1000),\n    };\n  }\n\n  /**\n   * Token bucket strategy\n   */\n  private checkTokenBucket(key: string, now: number): RateLimitStatus {\n    const refillRate = this.config.requestsPerWindow / (this.config.windowMs / 1000);\n    const lastRefill = this.tokens.get(`${key}:lastRefill`) || now;\n    let tokens = this.tokens.get(`${key}:tokens`) || this.config.requestsPerWindow;\n\n    const timePassed = (now - lastRefill) / 1000;\n    tokens = Math.min(this.config.requestsPerWindow, tokens + timePassed * refillRate);\n\n    const allowed = tokens >= 1;\n\n    if (allowed) {\n      tokens -= 1;\n      this.emit('ratelimit:allowed', { key, strategy: 'token-bucket' });\n    } else {\n      this.emit('ratelimit:blocked', { key, strategy: 'token-bucket' });\n    }\n\n    this.tokens.set(`${key}:tokens`, tokens);\n    this.tokens.set(`${key}:lastRefill`, now);\n\n    const resetAt = now + (1 / refillRate) * 1000;\n\n    return {\n      allowed,\n      remaining: Math.floor(tokens),\n      limit: this.config.requestsPerWindow,\n      resetAt,\n      retryAfter: allowed ? undefined : Math.ceil((1 / refillRate)),\n    };\n  }\n\n  /**\n   * Leaky bucket strategy\n   */\n  private checkLeakyBucket(key: string, now: number): RateLimitStatus {\n    const leakRate = this.config.requestsPerWindow / (this.config.windowMs / 1000);\n    const lastLeak = this.tokens.get(`${key}:lastLeak`) || now;\n    let bucket = this.tokens.get(`${key}:bucket`) || 0;\n\n    const timePassed = (now - lastLeak) / 1000;\n    bucket = Math.max(0, bucket - timePassed * leakRate);\n\n    const allowed = bucket < this.config.requestsPerWindow;\n\n    if (allowed) {\n      bucket += 1;\n      this.emit('ratelimit:allowed', { key, strategy: 'leaky-bucket' });\n    } else {\n      this.emit('ratelimit:blocked', { key, strategy: 'leaky-bucket' });\n    }\n\n    this.tokens.set(`${key}:bucket`, bucket);\n    this.tokens.set(`${key}:lastLeak`, now);\n\n    const resetAt = now + ((bucket - this.config.requestsPerWindow) / leakRate) * 1000;\n\n    return {\n      allowed,\n      remaining: Math.max(0, this.config.requestsPerWindow - Math.ceil(bucket)),\n      limit: this.config.requestsPerWindow,\n      resetAt,\n      retryAfter: allowed ? undefined : Math.ceil(((bucket - this.config.requestsPerWindow + 1) / leakRate)),\n    };\n  }\n\n  /**\n   * Reset limit for key\n   */\n  reset(key: string): void {\n    this.requests.delete(key);\n    this.tokens.delete(`${key}:tokens`);\n    this.tokens.delete(`${key}:lastRefill`);\n    this.tokens.delete(`${key}:bucket`);\n    this.tokens.delete(`${key}:lastLeak`);\n    this.emit('ratelimit:reset', { key });\n  }\n\n  /**\n   * Clear all limits\n   */\n  clear(): void {\n    this.requests.clear();\n    this.tokens.clear();\n    this.emit('ratelimit:cleared');\n  }\n}\n\n/**\n * Quota Manager\n */\nexport class QuotaManager extends EventEmitter {\n  private quotas: Map<string, { daily: number; monthly: number; lastReset: number }> = new Map();\n  private config: QuotaConfig;\n\n  constructor(config: QuotaConfig) {\n    super();\n    this.config = config;\n  }\n\n  /**\n   * Check quota\n   */\n  checkQuota(key: string, usage: number = 1): { allowed: boolean; remaining: { daily: number; monthly: number } } {\n    const now = Date.now();\n    let quota = this.quotas.get(key);\n\n    if (!quota) {\n      quota = {\n        daily: this.config.dailyQuota,\n        monthly: this.config.monthlyQuota,\n        lastReset: now,\n      };\n      this.quotas.set(key, quota);\n    }\n\n    // Check if daily quota should reset\n    const lastResetDate = new Date(quota.lastReset);\n    const nowDate = new Date(now);\n\n    if (lastResetDate.getDate() !== nowDate.getDate()) {\n      quota.daily = this.config.dailyQuota;\n    }\n\n    // Check if monthly quota should reset\n    if (lastResetDate.getMonth() !== nowDate.getMonth()) {\n      quota.monthly = this.config.monthlyQuota;\n    }\n\n    const allowed = quota.daily >= usage && quota.monthly >= usage;\n\n    if (allowed) {\n      quota.daily -= usage;\n      quota.monthly -= usage;\n      quota.lastReset = now;\n      this.emit('quota:allowed', { key, usage });\n    } else {\n      this.emit('quota:exceeded', { key, usage });\n    }\n\n    return {\n      allowed,\n      remaining: {\n        daily: Math.max(0, quota.daily),\n        monthly: Math.max(0, quota.monthly),\n      },\n    };\n  }\n\n  /**\n   * Get quota status\n   */\n  getStatus(key: string): { daily: number; monthly: number } {\n    const quota = this.quotas.get(key);\n    return {\n      daily: quota?.daily || this.config.dailyQuota,\n      monthly: quota?.monthly || this.config.monthlyQuota,\n    };\n  }\n\n  /**\n   * Reset quota\n   */\n  resetQuota(key: string): void {\n    const quota = this.quotas.get(key);\n    if (quota) {\n      quota.daily = this.config.dailyQuota;\n      quota.monthly = this.config.monthlyQuota;\n      quota.lastReset = Date.now();\n      this.emit('quota:reset', { key });\n    }\n  }\n\n  /**\n   * Get all quotas\n   */\n  getAllQuotas(): Record<string, any> {\n    const result: Record<string, any> = {};\n    for (const [key, quota] of this.quotas) {\n      result[key] = quota;\n    }\n    return result;\n  }\n}\n\n/**\n * Throttle Manager\n */\nexport class ThrottleManager extends EventEmitter {\n  private throttled: Map<string, { until: number; reason: string }> = new Map();\n  private throttleRules: Map<string, { threshold: number; duration: number }> = new Map();\n\n  /**\n   * Register throttle rule\n   */\n  registerRule(name: string, threshold: number, duration: number): void {\n    this.throttleRules.set(name, { threshold, duration });\n  }\n\n  /**\n   * Check if throttled\n   */\n  isThrottled(key: string): { throttled: boolean; until?: number; reason?: string } {\n    const throttle = this.throttled.get(key);\n\n    if (!throttle) {\n      return { throttled: false };\n    }\n\n    if (throttle.until < Date.now()) {\n      this.throttled.delete(key);\n      return { throttled: false };\n    }\n\n    return {\n      throttled: true,\n      until: throttle.until,\n      reason: throttle.reason,\n    };\n  }\n\n  /**\n   * Apply throttle\n   */\n  throttle(key: string, duration: number, reason: string = 'Rate limit exceeded'): void {\n    this.throttled.set(key, {\n      until: Date.now() + duration,\n      reason,\n    });\n    this.emit('throttle:applied', { key, duration, reason });\n  }\n\n  /**\n   * Remove throttle\n   */\n  removeThrottle(key: string): void {\n    this.throttled.delete(key);\n    this.emit('throttle:removed', { key });\n  }\n\n  /**\n   * Get throttle stats\n   */\n  getStats(): { throttledCount: number; rules: string[] } {\n    return {\n      throttledCount: this.throttled.size,\n      rules: Array.from(this.throttleRules.keys()),\n    };\n  }\n}\n
