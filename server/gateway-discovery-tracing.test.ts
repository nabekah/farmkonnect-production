import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { APIGateway, LoadBalancer, RequestRouter } from './gateway';\nimport { ServiceRegistry, ServiceResolver } from './discovery';\nimport { Tracer, DistributedLogger, MetricsExporter, TraceAnalyzer } from './tracing';\n\n/**\n * API Gateway Tests\n */\ndescribe('API Gateway', () => {\n  let gateway: APIGateway;\n\n  beforeEach(() => {\n    gateway = new APIGateway();\n  });\n\n  it('should register route', () => {\n    gateway.registerRoute({\n      path: '/api/users',\n      methods: ['GET', 'POST'],\n      target: 'http://users-service:3000',\n    });\n\n    const routes = gateway.getRoutes();\n    expect(routes.length).toBe(1);\n    expect(routes[0].path).toBe('/api/users');\n  });\n\n  it('should find matching route', () => {\n    gateway.registerRoute({\n      path: '/api/users/:id',\n      methods: ['GET'],\n      target: 'http://users-service:3000',\n    });\n\n    const route = gateway.findRoute('/api/users/123', 'GET');\n    expect(route).not.toBeNull();\n    expect(route?.target).toBe('http://users-service:3000');\n  });\n\n  it('should not find non-matching route', () => {\n    gateway.registerRoute({\n      path: '/api/users',\n      methods: ['GET'],\n      target: 'http://users-service:3000',\n    });\n\n    const route = gateway.findRoute('/api/posts', 'GET');\n    expect(route).toBeNull();\n  });\n\n  it('should rewrite URL', () => {\n    const route = {\n      path: '/api/*',\n      methods: ['GET'] as const,\n      target: 'http://backend:3000',\n      stripPrefix: true,\n    };\n\n    const rewritten = gateway.rewriteUrl('/api/users/123', route, 'http://backend:3000');\n    expect(rewritten).toContain('backend:3000');\n  });\n\n  it('should modify headers', () => {\n    const headers: Record<string, string> = {};\n    gateway.modifyHeaders(headers, {\n      add: { 'X-Custom': 'value' },\n      remove: ['Authorization'],\n    });\n\n    expect(headers['x-custom']).toBe('value');\n  });\n\n  it('should log request', () => {\n    gateway.logRequest('/api/users', 'GET', 200, 100);\n    const stats = gateway.getStats();\n\n    expect(stats.totalRequests).toBe(1);\n    expect(stats.averageResponseTime).toBe(100);\n  });\n\n  it('should get gateway stats', () => {\n    gateway.logRequest('/api/users', 'GET', 200, 100);\n    gateway.logRequest('/api/posts', 'POST', 201, 150);\n    gateway.logRequest('/api/error', 'GET', 500, 50);\n\n    const stats = gateway.getStats();\n    expect(stats.totalRequests).toBe(3);\n    expect(stats.errorRate).toBeGreaterThan(0);\n    expect(stats.requestsByMethod.GET).toBe(2);\n  });\n});\n\n/**\n * Load Balancer Tests\n */\ndescribe('Load Balancer', () => {\n  let lb: LoadBalancer;\n\n  beforeEach(() => {\n    lb = new LoadBalancer('round-robin');\n  });\n\n  it('should register instance', () => {\n    lb.registerInstance({\n      id: 'instance-1',\n      url: 'http://localhost:3001',\n      port: 3001,\n      connections: 0,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    const instances = lb.getInstances();\n    expect(instances.length).toBe(1);\n  });\n\n  it('should select instance with round-robin', () => {\n    lb.registerInstance({\n      id: 'instance-1',\n      url: 'http://localhost:3001',\n      port: 3001,\n      connections: 0,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    lb.registerInstance({\n      id: 'instance-2',\n      url: 'http://localhost:3002',\n      port: 3002,\n      connections: 0,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    const instance1 = lb.selectInstance();\n    const instance2 = lb.selectInstance();\n\n    expect(instance1?.id).toBe('instance-1');\n    expect(instance2?.id).toBe('instance-2');\n  });\n\n  it('should select instance with least-connections', () => {\n    const lbLc = new LoadBalancer('least-connections');\n\n    lbLc.registerInstance({\n      id: 'instance-1',\n      url: 'http://localhost:3001',\n      port: 3001,\n      connections: 5,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    lbLc.registerInstance({\n      id: 'instance-2',\n      url: 'http://localhost:3002',\n      port: 3002,\n      connections: 2,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    const instance = lbLc.selectInstance();\n    expect(instance?.id).toBe('instance-2');\n  });\n\n  it('should track connection count', () => {\n    lb.registerInstance({\n      id: 'instance-1',\n      url: 'http://localhost:3001',\n      port: 3001,\n      connections: 0,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    lb.incrementConnections('instance-1');\n    lb.incrementConnections('instance-1');\n\n    const instances = lb.getInstances();\n    expect(instances[0].connections).toBe(2);\n  });\n\n  it('should update health status', () => {\n    lb.registerInstance({\n      id: 'instance-1',\n      url: 'http://localhost:3001',\n      port: 3001,\n      connections: 0,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    lb.updateHealthStatus('instance-1', false);\n\n    const instances = lb.getInstances();\n    expect(instances[0].healthy).toBe(false);\n  });\n});\n\n/**\n * Service Registry Tests\n */\ndescribe('Service Registry', () => {\n  let registry: ServiceRegistry;\n\n  beforeEach(() => {\n    registry = new ServiceRegistry();\n  });\n\n  afterEach(() => {\n    registry.stop();\n  });\n\n  it('should register service', () => {\n    const instance = registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    expect(instance.name).toBe('users-service');\n    expect(instance.healthy).toBe(true);\n  });\n\n  it('should discover service', () => {\n    registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    const instances = registry.discoverService('users-service');\n    expect(instances.length).toBe(1);\n  });\n\n  it('should deregister service', () => {\n    registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    registry.deregisterService('users-service', 'service-1');\n\n    const instances = registry.discoverService('users-service');\n    expect(instances.length).toBe(0);\n  });\n\n  it('should update heartbeat', () => {\n    const instance = registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    const oldHeartbeat = instance.lastHeartbeat;\n    registry.updateHeartbeat('service-1');\n\n    const updated = registry.getServiceInstance('users-service', 'service-1');\n    expect(updated?.lastHeartbeat).toBeGreaterThan(oldHeartbeat);\n  });\n\n  it('should get service stats', () => {\n    registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    const stats = registry.getServiceStats('users-service');\n    expect(stats.totalInstances).toBe(1);\n    expect(stats.healthyInstances).toBe(1);\n  });\n});\n\n/**\n * Service Resolver Tests\n */\ndescribe('Service Resolver', () => {\n  let registry: ServiceRegistry;\n  let resolver: ServiceResolver;\n\n  beforeEach(() => {\n    registry = new ServiceRegistry();\n    resolver = new ServiceResolver(registry);\n  });\n\n  afterEach(() => {\n    registry.stop();\n  });\n\n  it('should resolve service', () => {\n    registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    const instances = resolver.resolveService('users-service');\n    expect(instances.length).toBe(1);\n  });\n\n  it('should cache resolved services', () => {\n    registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    resolver.resolveService('users-service');\n    const instances = resolver.resolveService('users-service');\n\n    expect(instances.length).toBe(1);\n  });\n\n  it('should invalidate cache', () => {\n    registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    resolver.resolveService('users-service');\n    resolver.invalidateCache('users-service');\n\n    const instances = resolver.resolveService('users-service');\n    expect(instances.length).toBe(1);\n  });\n});\n\n/**\n * Tracer Tests\n */\ndescribe('Tracer', () => {\n  let tracer: Tracer;\n\n  beforeEach(() => {\n    tracer = new Tracer();\n  });\n\n  it('should create trace context', () => {\n    const context = tracer.createTraceContext();\n    expect(context.traceId).toBeDefined();\n    expect(context.spanId).toBeDefined();\n  });\n\n  it('should start and end span', () => {\n    const context = tracer.createTraceContext();\n    const span = tracer.startSpan(context, 'test-span');\n\n    expect(span.name).toBe('test-span');\n    expect(span.status).toBe('UNSET');\n\n    tracer.endSpan(context.spanId, 'OK');\n    const trace = tracer.getTrace(context.traceId);\n\n    expect(trace?.spans[0].status).toBe('OK');\n  });\n\n  it('should add span attribute', () => {\n    const context = tracer.createTraceContext();\n    const span = tracer.startSpan(context, 'test-span');\n\n    tracer.addSpanAttribute(context.spanId, 'key', 'value');\n\n    expect(span.attributes.key).toBe('value');\n  });\n\n  it('should add span event', () => {\n    const context = tracer.createTraceContext();\n    const span = tracer.startSpan(context, 'test-span');\n\n    tracer.addSpanEvent(context.spanId, 'event', { data: 'test' });\n\n    expect(span.events.length).toBe(1);\n    expect(span.events[0].name).toBe('event');\n  });\n});\n\n/**\n * Distributed Logger Tests\n */\ndescribe('Distributed Logger', () => {\n  let logger: DistributedLogger;\n\n  beforeEach(() => {\n    logger = new DistributedLogger();\n  });\n\n  it('should log message', () => {\n    logger.log('trace-1', 'span-1', 'INFO', 'Test message');\n\n    const logs = logger.getTraceLogs('trace-1');\n    expect(logs.length).toBe(1);\n    expect(logs[0].message).toBe('Test message');\n  });\n\n  it('should get trace logs', () => {\n    logger.log('trace-1', 'span-1', 'INFO', 'Message 1');\n    logger.log('trace-1', 'span-2', 'INFO', 'Message 2');\n    logger.log('trace-2', 'span-3', 'INFO', 'Message 3');\n\n    const logs = logger.getTraceLogs('trace-1');\n    expect(logs.length).toBe(2);\n  });\n\n  it('should get span logs', () => {\n    logger.log('trace-1', 'span-1', 'INFO', 'Message 1');\n    logger.log('trace-1', 'span-1', 'INFO', 'Message 2');\n    logger.log('trace-1', 'span-2', 'INFO', 'Message 3');\n\n    const logs = logger.getSpanLogs('trace-1', 'span-1');\n    expect(logs.length).toBe(2);\n  });\n});\n\n/**\n * Metrics Exporter Tests\n */\ndescribe('Metrics Exporter', () => {\n  let exporter: MetricsExporter;\n\n  beforeEach(() => {\n    exporter = new MetricsExporter();\n  });\n\n  it('should record metric', () => {\n    exporter.recordMetric('latency', 100);\n    exporter.recordMetric('latency', 200);\n\n    const stats = exporter.getMetricStats('latency');\n    expect(stats?.count).toBe(2);\n    expect(stats?.min).toBe(100);\n    expect(stats?.max).toBe(200);\n  });\n\n  it('should calculate percentiles', () => {\n    for (let i = 1; i <= 100; i++) {\n      exporter.recordMetric('latency', i);\n    }\n\n    const stats = exporter.getMetricStats('latency');\n    expect(stats?.p50).toBeDefined();\n    expect(stats?.p95).toBeDefined();\n    expect(stats?.p99).toBeDefined();\n  });\n\n  it('should export metrics', () => {\n    exporter.recordMetric('latency', 100);\n    exporter.recordMetric('requests', 1000);\n\n    const metrics = exporter.exportMetrics();\n    expect(metrics.latency).toBeDefined();\n    expect(metrics.requests).toBeDefined();\n  });\n});\n\n/**\n * Trace Analyzer Tests\n */\ndescribe('Trace Analyzer', () => {\n  let tracer: Tracer;\n  let logger: DistributedLogger;\n  let analyzer: TraceAnalyzer;\n\n  beforeEach(() => {\n    tracer = new Tracer();\n    logger = new DistributedLogger();\n    analyzer = new TraceAnalyzer(tracer, logger);\n  });\n\n  it('should analyze trace', () => {\n    const context = tracer.createTraceContext();\n    tracer.startSpan(context, 'root');\n    tracer.endSpan(context.spanId, 'OK');\n\n    const analysis = analyzer.analyzeTrace(context.traceId);\n    expect(analysis).not.toBeNull();\n    expect(analysis?.spanCount).toBeGreaterThan(0);\n  });\n\n  it('should detect anomalies', () => {\n    const context = tracer.createTraceContext();\n    const span = tracer.startSpan(context, 'root');\n    tracer.endSpan(context.spanId, 'ERROR');\n\n    const anomalies = analyzer.detectAnomalies(context.traceId);\n    expect(anomalies.length).toBeGreaterThan(0);\n    expect(anomalies[0].type).toBe('errors');\n  });\n});\n\n/**\n * Integration Tests\n */\ndescribe('Integration Tests', () => {\n  it('should work with gateway and load balancer', () => {\n    const gateway = new APIGateway();\n    const lb = new LoadBalancer('round-robin');\n\n    gateway.registerRoute({\n      path: '/api/users',\n      methods: ['GET'],\n      target: 'http://users-service:3000',\n    });\n\n    lb.registerInstance({\n      id: 'instance-1',\n      url: 'http://localhost:3001',\n      port: 3001,\n      connections: 0,\n      healthy: true,\n      lastHealthCheck: Date.now(),\n    });\n\n    const route = gateway.findRoute('/api/users', 'GET');\n    const instance = lb.selectInstance();\n\n    expect(route).not.toBeNull();\n    expect(instance).not.toBeNull();\n  });\n\n  it('should work with service discovery and resolver', () => {\n    const registry = new ServiceRegistry();\n    const resolver = new ServiceResolver(registry);\n\n    registry.registerService({\n      id: 'service-1',\n      name: 'users-service',\n      host: 'localhost',\n      port: 3001,\n    });\n\n    const instances = resolver.resolveService('users-service');\n    expect(instances.length).toBe(1);\n\n    registry.stop();\n  });\n\n  it('should work with tracing and analysis', () => {\n    const tracer = new Tracer();\n    const logger = new DistributedLogger();\n    const analyzer = new TraceAnalyzer(tracer, logger);\n\n    const context = tracer.createTraceContext();\n    tracer.startSpan(context, 'root');\n    logger.log(context.traceId, context.spanId, 'INFO', 'Processing request');\n    tracer.endSpan(context.spanId, 'OK');\n\n    const analysis = analyzer.analyzeTrace(context.traceId);\n    expect(analysis).not.toBeNull();\n  });\n});\n
