import { EventEmitter } from 'events';\n\nexport type FilterOperator = 'equals' | 'not_equals' | 'contains' | 'gt' | 'lt' | 'gte' | 'lte' | 'between' | 'in' | 'nin';\n\nexport interface FilterCondition {\n  id: string;\n  field: string;\n  operator: FilterOperator;\n  value: any;\n  label?: string;\n}\n\nexport interface FilterGroup {\n  id: string;\n  name: string;\n  conditions: FilterCondition[];\n  logic: 'AND' | 'OR';\n  createdAt: number;\n  usageCount: number;\n}\n\nexport interface SavedFilterPreset {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  filters: FilterCondition[];\n  recipientCount: number;\n  createdAt: number;\n  updatedAt: number;\n  usageCount: number;\n}\n\nexport interface FilterHistory {\n  id: string;\n  filters: FilterCondition[];\n  recipientCount: number;\n  appliedAt: number;\n  appliedBy: string;\n}\n\nexport interface QuickFilter {\n  id: string;\n  name: string;\n  label: string;\n  icon: string;\n  color: string;\n  condition: FilterCondition;\n  recipientCount: number;\n  isActive: boolean;\n}\n\nexport interface FilterSuggestion {\n  id: string;\n  name: string;\n  description: string;\n  filters: FilterCondition[];\n  expectedRecipients: number;\n  confidence: number; // 0-100\n}\n\nclass AdvancedRecipientFiltering extends EventEmitter {\n  private filterGroups: Map<string, FilterGroup> = new Map();\n  private savedPresets: Map<string, SavedFilterPreset> = new Map();\n  private filterHistory: FilterHistory[] = [];\n  private quickFilters: Map<string, QuickFilter> = new Map();\n  private filterSuggestions: Map<string, FilterSuggestion> = new Map();\n\n  constructor() {\n    super();\n    this.initializeQuickFilters();\n    this.initializeFilterSuggestions();\n  }\n\n  /**\n   * Initialize quick filters\n   */\n  private initializeQuickFilters(): void {\n    const quickFilters: QuickFilter[] = [\n      {\n        id: 'qf-high-engagement',\n        name: 'High Engagement',\n        label: 'Highly engaged users',\n        icon: 'trending-up',\n        color: '#10b981',\n        condition: {\n          id: 'cond-1',\n          field: 'engagement_score',\n          operator: 'gte',\n          value: 70,\n        },\n        recipientCount: 0,\n        isActive: true,\n      },\n      {\n        id: 'qf-at-risk',\n        name: 'At Risk',\n        label: 'Users at risk of churning',\n        icon: 'alert-circle',\n        color: '#ef4444',\n        condition: {\n          id: 'cond-2',\n          field: 'churn_risk',\n          operator: 'gte',\n          value: 70,\n        },\n        recipientCount: 0,\n        isActive: true,\n      },\n      {\n        id: 'qf-inactive',\n        name: 'Inactive',\n        label: 'No activity in 30 days',\n        icon: 'pause-circle',\n        color: '#6b7280',\n        condition: {\n          id: 'cond-3',\n          field: 'days_since_activity',\n          operator: 'gte',\n          value: 30,\n        },\n        recipientCount: 0,\n        isActive: true,\n      },\n      {\n        id: 'qf-new-subscribers',\n        name: 'New Subscribers',\n        label: 'Joined in last 7 days',\n        icon: 'star',\n        color: '#3b82f6',\n        condition: {\n          id: 'cond-4',\n          field: 'days_since_signup',\n          operator: 'lte',\n          value: 7,\n        },\n        recipientCount: 0,\n        isActive: true,\n      },\n      {\n        id: 'qf-converters',\n        name: 'Converters',\n        label: 'Users who converted',\n        icon: 'check-circle',\n        color: '#8b5cf6',\n        condition: {\n          id: 'cond-5',\n          field: 'total_conversions',\n          operator: 'gt',\n          value: 0,\n        },\n        recipientCount: 0,\n        isActive: true,\n      },\n    ];\n\n    for (const qf of quickFilters) {\n      this.quickFilters.set(qf.id, qf);\n    }\n  }\n\n  /**\n   * Initialize filter suggestions\n   */\n  private initializeFilterSuggestions(): void {\n    const suggestions: FilterSuggestion[] = [\n      {\n        id: 'sug-1',\n        name: 'Re-engagement Campaign',\n        description: 'Target inactive users with re-engagement content',\n        filters: [\n          {\n            id: 'f1',\n            field: 'days_since_activity',\n            operator: 'gte',\n            value: 30,\n          },\n          {\n            id: 'f2',\n            field: 'engagement_score',\n            operator: 'lt',\n            value: 30,\n          },\n        ],\n        expectedRecipients: 5000,\n        confidence: 85,\n      },\n      {\n        id: 'sug-2',\n        name: 'VIP Segment',\n        description: 'High-value customers with strong engagement',\n        filters: [\n          {\n            id: 'f3',\n            field: 'engagement_score',\n            operator: 'gte',\n            value: 80,\n          },\n          {\n            id: 'f4',\n            field: 'total_conversions',\n            operator: 'gte',\n            value: 5,\n          },\n        ],\n        expectedRecipients: 1200,\n        confidence: 90,\n      },\n      {\n        id: 'sug-3',\n        name: 'Churn Prevention',\n        description: 'Users showing signs of disengagement',\n        filters: [\n          {\n            id: 'f5',\n            field: 'churn_risk',\n            operator: 'gte',\n            value: 60,\n          },\n          {\n            id: 'f6',\n            field: 'engagement_score',\n            operator: 'lt',\n            value: 50,\n          },\n        ],\n        expectedRecipients: 3500,\n        confidence: 88,\n      },\n    ];\n\n    for (const sug of suggestions) {\n      this.filterSuggestions.set(sug.id, sug);\n    }\n  }\n\n  /**\n   * Create filter group\n   */\n  createFilterGroup(name: string, conditions: FilterCondition[], logic: 'AND' | 'OR' = 'AND'): FilterGroup {\n    const group: FilterGroup = {\n      id: `fg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      conditions,\n      logic,\n      createdAt: Date.now(),\n      usageCount: 0,\n    };\n\n    this.filterGroups.set(group.id, group);\n    this.emit('filter_group:created', group);\n    return group;\n  }\n\n  /**\n   * Get filter group\n   */\n  getFilterGroup(groupId: string): FilterGroup | undefined {\n    return this.filterGroups.get(groupId);\n  }\n\n  /**\n   * Update filter group\n   */\n  updateFilterGroup(groupId: string, updates: Partial<FilterGroup>): boolean {\n    const group = this.filterGroups.get(groupId);\n    if (!group) return false;\n\n    Object.assign(group, updates);\n    this.emit('filter_group:updated', group);\n    return true;\n  }\n\n  /**\n   * Delete filter group\n   */\n  deleteFilterGroup(groupId: string): boolean {\n    const deleted = this.filterGroups.delete(groupId);\n    if (deleted) {\n      this.emit('filter_group:deleted', groupId);\n    }\n    return deleted;\n  }\n\n  /**\n   * Get all filter groups\n   */\n  getAllFilterGroups(): FilterGroup[] {\n    return Array.from(this.filterGroups.values());\n  }\n\n  /**\n   * Save filter preset\n   */\n  saveFilterPreset(\n    name: string,\n    description: string,\n    filters: FilterCondition[],\n    icon: string = 'filter'\n  ): SavedFilterPreset {\n    const preset: SavedFilterPreset = {\n      id: `fp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      description,\n      icon,\n      filters,\n      recipientCount: 0,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      usageCount: 0,\n    };\n\n    this.savedPresets.set(preset.id, preset);\n    this.emit('preset:saved', preset);\n    return preset;\n  }\n\n  /**\n   * Get saved preset\n   */\n  getSavedPreset(presetId: string): SavedFilterPreset | undefined {\n    return this.savedPresets.get(presetId);\n  }\n\n  /**\n   * Get all saved presets\n   */\n  getAllSavedPresets(): SavedFilterPreset[] {\n    return Array.from(this.savedPresets.values()).sort((a, b) => b.usageCount - a.usageCount);\n  }\n\n  /**\n   * Use preset\n   */\n  usePreset(presetId: string): SavedFilterPreset | null {\n    const preset = this.savedPresets.get(presetId);\n    if (!preset) return null;\n\n    preset.usageCount++;\n    preset.updatedAt = Date.now();\n\n    // Record in history\n    this.recordFilterHistory(preset.filters, 0, 'system');\n\n    this.emit('preset:used', preset);\n    return preset;\n  }\n\n  /**\n   * Delete preset\n   */\n  deletePreset(presetId: string): boolean {\n    const deleted = this.savedPresets.delete(presetId);\n    if (deleted) {\n      this.emit('preset:deleted', presetId);\n    }\n    return deleted;\n  }\n\n  /**\n   * Record filter history\n   */\n  recordFilterHistory(filters: FilterCondition[], recipientCount: number, appliedBy: string): FilterHistory {\n    const history: FilterHistory = {\n      id: `fh-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      filters,\n      recipientCount,\n      appliedAt: Date.now(),\n      appliedBy,\n    };\n\n    this.filterHistory.push(history);\n    this.emit('filter:applied', history);\n    return history;\n  }\n\n  /**\n   * Get filter history\n   */\n  getFilterHistory(limit: number = 20): FilterHistory[] {\n    return this.filterHistory.slice(-limit).reverse();\n  }\n\n  /**\n   * Get quick filters\n   */\n  getQuickFilters(): QuickFilter[] {\n    return Array.from(this.quickFilters.values());\n  }\n\n  /**\n   * Get quick filter\n   */\n  getQuickFilter(filterId: string): QuickFilter | undefined {\n    return this.quickFilters.get(filterId);\n  }\n\n  /**\n   * Apply quick filter\n   */\n  applyQuickFilter(filterId: string): QuickFilter | null {\n    const filter = this.quickFilters.get(filterId);\n    if (!filter) return null;\n\n    filter.isActive = true;\n    this.recordFilterHistory([filter.condition], filter.recipientCount, 'system');\n\n    this.emit('quick_filter:applied', filter);\n    return filter;\n  }\n\n  /**\n   * Get filter suggestions\n   */\n  getFilterSuggestions(): FilterSuggestion[] {\n    return Array.from(this.filterSuggestions.values()).sort((a, b) => b.confidence - a.confidence);\n  }\n\n  /**\n   * Get filter suggestion\n   */\n  getFilterSuggestion(suggestionId: string): FilterSuggestion | undefined {\n    return this.filterSuggestions.get(suggestionId);\n  }\n\n  /**\n   * Apply suggestion\n   */\n  applySuggestion(suggestionId: string): FilterSuggestion | null {\n    const suggestion = this.filterSuggestions.get(suggestionId);\n    if (!suggestion) return null;\n\n    this.recordFilterHistory(suggestion.filters, suggestion.expectedRecipients, 'system');\n    this.emit('suggestion:applied', suggestion);\n    return suggestion;\n  }\n\n  /**\n   * Combine filters\n   */\n  combineFilters(filters: FilterCondition[], logic: 'AND' | 'OR' = 'AND'): FilterCondition[] {\n    if (logic === 'AND') {\n      return filters.filter((f) => f.value !== null && f.value !== undefined);\n    } else {\n      return filters;\n    }\n  }\n\n  /**\n   * Get filter statistics\n   */\n  getFilterStatistics(): Record<string, any> {\n    const groups = Array.from(this.filterGroups.values());\n    const presets = Array.from(this.savedPresets.values());\n\n    const totalUsage = presets.reduce((sum, p) => sum + p.usageCount, 0);\n    const mostUsedPreset = presets.sort((a, b) => b.usageCount - a.usageCount)[0];\n\n    return {\n      totalFilterGroups: groups.length,\n      totalSavedPresets: presets.length,\n      totalFilterHistory: this.filterHistory.length,\n      totalQuickFilters: this.quickFilters.size,\n      totalFilterSuggestions: this.filterSuggestions.size,\n      totalPresetUsage: totalUsage,\n      mostUsedPreset: mostUsedPreset?.name || 'N/A',\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Cleanup if needed\n  }\n}\n\nexport default AdvancedRecipientFiltering;\n
