import { EventEmitter } from 'events';\n\nexport type NotificationChannel = 'email' | 'sms' | 'push' | 'in_app';\nexport type NotificationFrequency = 'immediate' | 'daily' | 'weekly' | 'never';\nexport type SeverityLevel = 'low' | 'medium' | 'high' | 'critical';\n\nexport interface NotificationPreference {\n  id: string;\n  userId: string;\n  farmId: string;\n  notificationType: string;\n  channels: NotificationChannel[];\n  frequency: NotificationFrequency;\n  minimumSeverity: SeverityLevel;\n  enabled: boolean;\n  quietHours: { start: number; end: number } | null; // 0-23 hours\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface UserNotificationSettings {\n  userId: string;\n  farmId: string;\n  preferences: NotificationPreference[];\n  defaultChannels: NotificationChannel[];\n  doNotDisturb: boolean;\n  doNotDisturbHours: { start: number; end: number } | null;\n  unsubscribeAll: boolean;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface NotificationTemplate {\n  id: string;\n  type: string;\n  title: string;\n  message: string;\n  severity: SeverityLevel;\n  channels: NotificationChannel[];\n  variables: string[];\n}\n\nexport interface NotificationLog {\n  id: string;\n  userId: string;\n  farmId: string;\n  type: string;\n  channels: NotificationChannel[];\n  status: 'sent' | 'failed' | 'pending' | 'bounced';\n  sentAt: number;\n  readAt?: number;\n  deliveryStatus: Record<NotificationChannel, 'sent' | 'failed' | 'pending'>;\n}\n\n/**\n * Notification Preferences System\n */\nexport class NotificationPreferencesManager extends EventEmitter {\n  private preferences: Map<string, NotificationPreference> = new Map();\n  private userSettings: Map<string, UserNotificationSettings> = new Map();\n  private templates: Map<string, NotificationTemplate> = new Map();\n  private logs: Map<string, NotificationLog> = new Map();\n\n  constructor() {\n    super();\n    this.initializeDefaultTemplates();\n  }\n\n  /**\n   * Initialize default templates\n   */\n  private initializeDefaultTemplates(): void {\n    const defaultTemplates: NotificationTemplate[] = [\n      {\n        id: 'template_alert_inventory',\n        type: 'inventory_low',\n        title: 'Low Inventory Alert',\n        message: 'Inventory for {{item}} is below reorder threshold',\n        severity: 'medium',\n        channels: ['email', 'push', 'in_app'],\n        variables: ['item', 'quantity', 'threshold'],\n      },\n      {\n        id: 'template_alert_weather',\n        type: 'weather_alert',\n        title: 'Weather Alert',\n        message: '{{condition}} expected in {{hours}} hours',\n        severity: 'high',\n        channels: ['push', 'sms', 'in_app'],\n        variables: ['condition', 'hours', 'impact'],\n      },\n      {\n        id: 'template_alert_task',\n        type: 'task_overdue',\n        title: 'Task Overdue',\n        message: 'Task \"{{taskName}}\" is {{daysOverdue}} days overdue',\n        severity: 'high',\n        channels: ['email', 'push', 'in_app'],\n        variables: ['taskName', 'daysOverdue'],\n      },\n      {\n        id: 'template_alert_financial',\n        type: 'budget_exceeded',\n        title: 'Budget Alert',\n        message: '{{category}} spending exceeded budget by {{amount}}',\n        severity: 'medium',\n        channels: ['email', 'in_app'],\n        variables: ['category', 'amount', 'percentage'],\n      },\n      {\n        id: 'template_alert_supplier',\n        type: 'supplier_performance',\n        title: 'Supplier Alert',\n        message: 'Supplier {{supplierName}} performance degraded',\n        severity: 'medium',\n        channels: ['email', 'in_app'],\n        variables: ['supplierName', 'metric', 'value'],\n      },\n    ];\n\n    defaultTemplates.forEach((template) => {\n      this.templates.set(template.id, template);\n    });\n  }\n\n  /**\n   * Create notification preference\n   */\n  createPreference(\n    userId: string,\n    farmId: string,\n    notificationType: string,\n    channels: NotificationChannel[],\n    frequency: NotificationFrequency,\n    minimumSeverity: SeverityLevel,\n    quietHours?: { start: number; end: number }\n  ): NotificationPreference {\n    const preferenceId = `pref_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const preference: NotificationPreference = {\n      id: preferenceId,\n      userId,\n      farmId,\n      notificationType,\n      channels,\n      frequency,\n      minimumSeverity,\n      enabled: true,\n      quietHours: quietHours || null,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.preferences.set(preferenceId, preference);\n    this.emit('preference:created', { preferenceId, userId, notificationType });\n    return preference;\n  }\n\n  /**\n   * Get user notification settings\n   */\n  getUserSettings(userId: string, farmId: string): UserNotificationSettings {\n    const settingsKey = `${userId}_${farmId}`;\n    let settings = this.userSettings.get(settingsKey);\n\n    if (!settings) {\n      settings = {\n        userId,\n        farmId,\n        preferences: [],\n        defaultChannels: ['email', 'push', 'in_app'],\n        doNotDisturb: false,\n        doNotDisturbHours: null,\n        unsubscribeAll: false,\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      };\n      this.userSettings.set(settingsKey, settings);\n    }\n\n    return settings;\n  }\n\n  /**\n   * Update user settings\n   */\n  updateUserSettings(\n    userId: string,\n    farmId: string,\n    updates: Partial<UserNotificationSettings>\n  ): UserNotificationSettings {\n    const settingsKey = `${userId}_${farmId}`;\n    let settings = this.userSettings.get(settingsKey);\n\n    if (!settings) {\n      settings = this.getUserSettings(userId, farmId);\n    }\n\n    settings = {\n      ...settings,\n      ...updates,\n      updatedAt: Date.now(),\n    };\n\n    this.userSettings.set(settingsKey, settings);\n    this.emit('settings:updated', { userId, farmId });\n    return settings;\n  }\n\n  /**\n   * Update preference\n   */\n  updatePreference(preferenceId: string, updates: Partial<NotificationPreference>): NotificationPreference | null {\n    const preference = this.preferences.get(preferenceId);\n    if (!preference) return null;\n\n    const updated = {\n      ...preference,\n      ...updates,\n      updatedAt: Date.now(),\n    };\n\n    this.preferences.set(preferenceId, updated);\n    this.emit('preference:updated', { preferenceId });\n    return updated;\n  }\n\n  /**\n   * Delete preference\n   */\n  deletePreference(preferenceId: string): boolean {\n    const deleted = this.preferences.delete(preferenceId);\n    if (deleted) {\n      this.emit('preference:deleted', { preferenceId });\n    }\n    return deleted;\n  }\n\n  /**\n   * Get preferences for user\n   */\n  getUserPreferences(userId: string, farmId: string): NotificationPreference[] {\n    return Array.from(this.preferences.values()).filter(\n      (p) => p.userId === userId && p.farmId === farmId && p.enabled\n    );\n  }\n\n  /**\n   * Check if notification should be sent\n   */\n  shouldSendNotification(\n    userId: string,\n    farmId: string,\n    notificationType: string,\n    severity: SeverityLevel\n  ): { should: boolean; channels: NotificationChannel[] } {\n    const settings = this.getUserSettings(userId, farmId);\n\n    // Check if all notifications are disabled\n    if (settings.unsubscribeAll) {\n      return { should: false, channels: [] };\n    }\n\n    // Check if in do not disturb mode\n    if (settings.doNotDisturb) {\n      const now = new Date();\n      const currentHour = now.getHours();\n      if (settings.doNotDisturbHours) {\n        const { start, end } = settings.doNotDisturbHours;\n        if (start < end && currentHour >= start && currentHour < end) {\n          return { should: false, channels: [] };\n        } else if (start > end && (currentHour >= start || currentHour < end)) {\n          return { should: false, channels: [] };\n        }\n      }\n    }\n\n    // Find matching preference\n    const preference = Array.from(this.preferences.values()).find(\n      (p) => p.userId === userId && p.farmId === farmId && p.notificationType === notificationType && p.enabled\n    );\n\n    if (!preference) {\n      return { should: true, channels: settings.defaultChannels };\n    }\n\n    // Check severity level\n    const severityLevels: SeverityLevel[] = ['low', 'medium', 'high', 'critical'];\n    const minIndex = severityLevels.indexOf(preference.minimumSeverity);\n    const actualIndex = severityLevels.indexOf(severity);\n\n    if (actualIndex < minIndex) {\n      return { should: false, channels: [] };\n    }\n\n    // Check quiet hours\n    if (preference.quietHours) {\n      const now = new Date();\n      const currentHour = now.getHours();\n      const { start, end } = preference.quietHours;\n      if (start < end && currentHour >= start && currentHour < end) {\n        return { should: false, channels: [] };\n      } else if (start > end && (currentHour >= start || currentHour < end)) {\n        return { should: false, channels: [] };\n      }\n    }\n\n    return { should: true, channels: preference.channels };\n  }\n\n  /**\n   * Log notification\n   */\n  logNotification(\n    userId: string,\n    farmId: string,\n    type: string,\n    channels: NotificationChannel[],\n    status: 'sent' | 'failed' | 'pending' = 'pending'\n  ): NotificationLog {\n    const logId = `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const deliveryStatus: Record<NotificationChannel, 'sent' | 'failed' | 'pending'> = {\n      email: 'pending',\n      sms: 'pending',\n      push: 'pending',\n      in_app: 'pending',\n    };\n\n    const log: NotificationLog = {\n      id: logId,\n      userId,\n      farmId,\n      type,\n      channels,\n      status,\n      sentAt: Date.now(),\n      deliveryStatus,\n    };\n\n    this.logs.set(logId, log);\n    this.emit('notification:logged', { logId, userId, type });\n    return log;\n  }\n\n  /**\n   * Get notification logs\n   */\n  getNotificationLogs(userId: string, farmId: string, limit: number = 50): NotificationLog[] {\n    return Array.from(this.logs.values())\n      .filter((l) => l.userId === userId && l.farmId === farmId)\n      .sort((a, b) => b.sentAt - a.sentAt)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get template\n   */\n  getTemplate(templateId: string): NotificationTemplate | null {\n    return this.templates.get(templateId) || null;\n  }\n\n  /**\n   * Get all templates\n   */\n  getAllTemplates(): NotificationTemplate[] {\n    return Array.from(this.templates.values());\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): {\n    totalPreferences: number;\n    totalUsers: number;\n    totalLogs: number;\n    totalTemplates: number;\n  } {\n    const uniqueUsers = new Set(\n      Array.from(this.preferences.values()).map((p) => `${p.userId}_${p.farmId}`)\n    ).size;\n\n    return {\n      totalPreferences: this.preferences.size,\n      totalUsers: uniqueUsers,\n      totalLogs: this.logs.size,\n      totalTemplates: this.templates.size,\n    };\n  }\n}\n
