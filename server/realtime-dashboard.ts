import { EventEmitter } from 'events';\n\nexport interface DashboardUpdate {\n  id: string;\n  widgetId: string;\n  data: any;\n  timestamp: number;\n  source: 'data-source' | 'webhook' | 'manual';\n  priority: 'low' | 'normal' | 'high' | 'critical';\n}\n\nexport interface DashboardSubscription {\n  id: string;\n  userId: string;\n  widgetIds: string[];\n  connected: boolean;\n  connectionTime?: number;\n  lastUpdate?: number;\n}\n\nexport interface RealtimeConfig {\n  updateInterval: number; // milliseconds\n  batchUpdates: boolean;\n  maxBatchSize: number;\n  compressionEnabled: boolean;\n  priorityQueue: boolean;\n}\n\nexport class RealtimeDashboardManager extends EventEmitter {\n  private subscriptions: Map<string, DashboardSubscription> = new Map();\n  private updateQueue: DashboardUpdate[] = [];\n  private batchTimer: NodeJS.Timeout | null = null;\n  private subscriptionCounter = 0;\n  private updateCounter = 0;\n  private config: RealtimeConfig;\n\n  constructor(config: Partial<RealtimeConfig> = {}) {\n    super();\n    this.config = {\n      updateInterval: config.updateInterval ?? 1000,\n      batchUpdates: config.batchUpdates ?? true,\n      maxBatchSize: config.maxBatchSize ?? 50,\n      compressionEnabled: config.compressionEnabled ?? false,\n      priorityQueue: config.priorityQueue ?? true,\n    };\n  }\n\n  /**\n   * Subscribe user to real-time dashboard updates\n   */\n  subscribe(userId: string, widgetIds: string[]): DashboardSubscription {\n    const subscriptionId = `sub-${++this.subscriptionCounter}`;\n    const subscription: DashboardSubscription = {\n      id: subscriptionId,\n      userId,\n      widgetIds,\n      connected: true,\n      connectionTime: Date.now(),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n    this.emit('subscription:created', subscription);\n\n    return subscription;\n  }\n\n  /**\n   * Unsubscribe user from real-time updates\n   */\n  unsubscribe(subscriptionId: string): boolean {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) return false;\n\n    this.subscriptions.delete(subscriptionId);\n    this.emit('subscription:removed', subscription);\n\n    return true;\n  }\n\n  /**\n   * Update widget subscription\n   */\n  updateSubscription(subscriptionId: string, widgetIds: string[]): DashboardSubscription | null {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) return null;\n\n    subscription.widgetIds = widgetIds;\n    subscription.lastUpdate = Date.now();\n\n    this.emit('subscription:updated', subscription);\n    return subscription;\n  }\n\n  /**\n   * Queue update for real-time delivery\n   */\n  queueUpdate(\n    widgetId: string,\n    data: any,\n    source: DashboardUpdate['source'] = 'data-source',\n    priority: DashboardUpdate['priority'] = 'normal'\n  ): DashboardUpdate {\n    const update: DashboardUpdate = {\n      id: `update-${++this.updateCounter}`,\n      widgetId,\n      data,\n      timestamp: Date.now(),\n      source,\n      priority,\n    };\n\n    if (this.config.priorityQueue) {\n      // Insert by priority\n      const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };\n      let inserted = false;\n\n      for (let i = 0; i < this.updateQueue.length; i++) {\n        if (priorityOrder[update.priority] < priorityOrder[this.updateQueue[i].priority]) {\n          this.updateQueue.splice(i, 0, update);\n          inserted = true;\n          break;\n        }\n      }\n\n      if (!inserted) {\n        this.updateQueue.push(update);\n      }\n    } else {\n      this.updateQueue.push(update);\n    }\n\n    this.emit('update:queued', update);\n\n    // Start batch timer if needed\n    if (this.config.batchUpdates && !this.batchTimer) {\n      this.startBatchTimer();\n    }\n\n    // Send immediately if not batching or queue is full\n    if (!this.config.batchUpdates || this.updateQueue.length >= this.config.maxBatchSize) {\n      this.flushUpdates();\n    }\n\n    return update;\n  }\n\n  /**\n   * Start batch timer\n   */\n  private startBatchTimer() {\n    this.batchTimer = setTimeout(() => {\n      this.flushUpdates();\n    }, this.config.updateInterval);\n  }\n\n  /**\n   * Flush queued updates to subscribers\n   */\n  flushUpdates() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    if (this.updateQueue.length === 0) return;\n\n    const updates = [...this.updateQueue];\n    this.updateQueue = [];\n\n    // Group updates by widget\n    const updatesByWidget = new Map<string, DashboardUpdate[]>();\n    for (const update of updates) {\n      if (!updatesByWidget.has(update.widgetId)) {\n        updatesByWidget.set(update.widgetId, []);\n      }\n      updatesByWidget.get(update.widgetId)!.push(update);\n    }\n\n    // Send to subscribers\n    for (const subscription of this.subscriptions.values()) {\n      if (!subscription.connected) continue;\n\n      const relevantUpdates = updates.filter((u) => subscription.widgetIds.includes(u.widgetId));\n\n      if (relevantUpdates.length > 0) {\n        this.sendUpdatesToSubscriber(subscription, relevantUpdates);\n      }\n    }\n\n    this.emit('updates:flushed', { count: updates.length });\n  }\n\n  /**\n   * Send updates to specific subscriber\n   */\n  private sendUpdatesToSubscriber(subscription: DashboardSubscription, updates: DashboardUpdate[]) {\n    const payload = {\n      subscriptionId: subscription.id,\n      updates,\n      timestamp: Date.now(),\n      count: updates.length,\n    };\n\n    // Compress if enabled\n    if (this.config.compressionEnabled) {\n      // In real implementation, use gzip or similar\n      payload['compressed'] = true;\n    }\n\n    subscription.lastUpdate = Date.now();\n    this.emit('updates:sent', payload);\n  }\n\n  /**\n   * Broadcast update to all subscribers of a widget\n   */\n  broadcastWidgetUpdate(widgetId: string, data: any) {\n    const affectedSubscriptions = Array.from(this.subscriptions.values()).filter((sub) =>\n      sub.widgetIds.includes(widgetId)\n    );\n\n    for (const subscription of affectedSubscriptions) {\n      const update: DashboardUpdate = {\n        id: `update-${++this.updateCounter}`,\n        widgetId,\n        data,\n        timestamp: Date.now(),\n        source: 'data-source',\n        priority: 'normal',\n      };\n\n      this.sendUpdatesToSubscriber(subscription, [update]);\n    }\n\n    this.emit('broadcast:sent', { widgetId, subscribers: affectedSubscriptions.length });\n  }\n\n  /**\n   * Get subscription by ID\n   */\n  getSubscription(subscriptionId: string): DashboardSubscription | undefined {\n    return this.subscriptions.get(subscriptionId);\n  }\n\n  /**\n   * Get all subscriptions\n   */\n  getAllSubscriptions(): DashboardSubscription[] {\n    return Array.from(this.subscriptions.values());\n  }\n\n  /**\n   * Get subscriptions by user\n   */\n  getSubscriptionsByUser(userId: string): DashboardSubscription[] {\n    return Array.from(this.subscriptions.values()).filter((sub) => sub.userId === userId);\n  }\n\n  /**\n   * Get subscriptions for widget\n   */\n  getSubscriptionsForWidget(widgetId: string): DashboardSubscription[] {\n    return Array.from(this.subscriptions.values()).filter((sub) =>\n      sub.widgetIds.includes(widgetId)\n    );\n  }\n\n  /**\n   * Mark subscription as disconnected\n   */\n  markDisconnected(subscriptionId: string): boolean {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) return false;\n\n    subscription.connected = false;\n    this.emit('subscription:disconnected', subscription);\n\n    return true;\n  }\n\n  /**\n   * Mark subscription as reconnected\n   */\n  markReconnected(subscriptionId: string): boolean {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) return false;\n\n    subscription.connected = true;\n    subscription.connectionTime = Date.now();\n    this.emit('subscription:reconnected', subscription);\n\n    return true;\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getQueueStats() {\n    const priorityCounts = {\n      critical: this.updateQueue.filter((u) => u.priority === 'critical').length,\n      high: this.updateQueue.filter((u) => u.priority === 'high').length,\n      normal: this.updateQueue.filter((u) => u.priority === 'normal').length,\n      low: this.updateQueue.filter((u) => u.priority === 'low').length,\n    };\n\n    return {\n      queueSize: this.updateQueue.length,\n      priorityCounts,\n      subscriptions: this.subscriptions.size,\n      connectedSubscriptions: Array.from(this.subscriptions.values()).filter((s) => s.connected).length,\n      config: this.config,\n    };\n  }\n\n  /**\n   * Get connection statistics\n   */\n  getConnectionStats() {\n    const subscriptions = Array.from(this.subscriptions.values());\n    const now = Date.now();\n\n    return {\n      totalSubscriptions: subscriptions.length,\n      connectedSubscriptions: subscriptions.filter((s) => s.connected).length,\n      disconnectedSubscriptions: subscriptions.filter((s) => !s.connected).length,\n      averageConnectionDuration: subscriptions\n        .filter((s) => s.connectionTime)\n        .reduce((sum, s) => sum + (now - (s.connectionTime || 0)), 0) / Math.max(subscriptions.length, 1),\n      lastUpdate: Math.max(...subscriptions.map((s) => s.lastUpdate || 0)),\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n    }\n    this.subscriptions.clear();\n    this.updateQueue = [];\n  }\n}\n
