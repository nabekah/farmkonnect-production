/**\n * Offline Support Manager\n * Handles service worker registration, caching, and sync\n */\n\nexport interface CacheEntry {\n  key: string;\n  value: any;\n  timestamp: number;\n  ttl?: number;\n}\n\nexport interface SyncRequest {\n  id: string;\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  url: string;\n  data?: any;\n  timestamp: number;\n  retries: number;\n  maxRetries: number;\n}\n\nexport class OfflineSupportManager {\n  private cacheName = 'farmkonnect-cache-v1';\n  private dbName = 'farmkonnect-offline';\n  private storeName = 'cache';\n  private syncStoreName = 'sync-queue';\n  private db: IDBDatabase | null = null;\n  private isOnline = navigator.onLine;\n  private syncQueue: Map<string, SyncRequest> = new Map();\n  private cacheStore: Map<string, CacheEntry> = new Map();\n\n  constructor() {\n    this.initializeDB();\n    this.setupEventListeners();\n    this.registerServiceWorker();\n  }\n\n  /**\n   * Initialize IndexedDB\n   */\n  private async initializeDB(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, { keyPath: 'key' });\n        }\n        if (!db.objectStoreNames.contains(this.syncStoreName)) {\n          db.createObjectStore(this.syncStoreName, { keyPath: 'id' });\n        }\n      };\n    });\n  }\n\n  /**\n   * Setup event listeners for online/offline events\n   */\n  private setupEventListeners(): void {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.processSyncQueue();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n    });\n  }\n\n  /**\n   * Register service worker\n   */\n  private async registerServiceWorker(): Promise<void> {\n    if ('serviceWorker' in navigator) {\n      try {\n        await navigator.serviceWorker.register('/sw.js');\n        console.log('Service worker registered');\n      } catch (error) {\n        console.error('Service worker registration failed:', error);\n      }\n    }\n  }\n\n  /**\n   * Cache data\n   */\n  async cacheData(key: string, value: any, ttl?: number): Promise<void> {\n    const entry: CacheEntry = {\n      key,\n      value,\n      timestamp: Date.now(),\n      ttl,\n    };\n\n    this.cacheStore.set(key, entry);\n\n    if (this.db) {\n      return new Promise((resolve, reject) => {\n        const transaction = this.db!.transaction([this.storeName], 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.put(entry);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n      });\n    }\n  }\n\n  /**\n   * Get cached data\n   */\n  async getCachedData(key: string): Promise<any | null> {\n    // Check memory cache first\n    const memoryEntry = this.cacheStore.get(key);\n    if (memoryEntry) {\n      if (memoryEntry.ttl && Date.now() - memoryEntry.timestamp > memoryEntry.ttl) {\n        this.cacheStore.delete(key);\n        return null;\n      }\n      return memoryEntry.value;\n    }\n\n    // Check IndexedDB\n    if (this.db) {\n      return new Promise((resolve, reject) => {\n        const transaction = this.db!.transaction([this.storeName], 'readonly');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.get(key);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => {\n          const entry = request.result as CacheEntry | undefined;\n          if (entry) {\n            if (entry.ttl && Date.now() - entry.timestamp > entry.ttl) {\n              store.delete(key);\n              resolve(null);\n            } else {\n              resolve(entry.value);\n            }\n          } else {\n            resolve(null);\n          }\n        };\n      });\n    }\n\n    return null;\n  }\n\n  /**\n   * Clear cache\n   */\n  async clearCache(): Promise<void> {\n    this.cacheStore.clear();\n\n    if (this.db) {\n      return new Promise((resolve, reject) => {\n        const transaction = this.db!.transaction([this.storeName], 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.clear();\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n      });\n    }\n  }\n\n  /**\n   * Queue sync request\n   */\n  async queueSyncRequest(\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    url: string,\n    data?: any\n  ): Promise<string> {\n    const id = `sync-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const request: SyncRequest = {\n      id,\n      method,\n      url,\n      data,\n      timestamp: Date.now(),\n      retries: 0,\n      maxRetries: 3,\n    };\n\n    this.syncQueue.set(id, request);\n\n    if (this.db) {\n      return new Promise((resolve, reject) => {\n        const transaction = this.db!.transaction([this.syncStoreName], 'readwrite');\n        const store = transaction.objectStore(this.syncStoreName);\n        const dbRequest = store.add(request);\n\n        dbRequest.onerror = () => reject(dbRequest.error);\n        dbRequest.onsuccess = () => resolve(id);\n      });\n    }\n\n    return id;\n  }\n\n  /**\n   * Process sync queue\n   */\n  async processSyncQueue(): Promise<void> {\n    if (!this.isOnline) return;\n\n    for (const [id, request] of this.syncQueue) {\n      try {\n        const response = await fetch(request.url, {\n          method: request.method,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: request.data ? JSON.stringify(request.data) : undefined,\n        });\n\n        if (response.ok) {\n          this.syncQueue.delete(id);\n          if (this.db) {\n            const transaction = this.db.transaction([this.syncStoreName], 'readwrite');\n            const store = transaction.objectStore(this.syncStoreName);\n            store.delete(id);\n          }\n        } else if (request.retries < request.maxRetries) {\n          request.retries++;\n        } else {\n          this.syncQueue.delete(id);\n        }\n      } catch (error) {\n        if (request.retries < request.maxRetries) {\n          request.retries++;\n        } else {\n          this.syncQueue.delete(id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get sync queue\n   */\n  getSyncQueue(): SyncRequest[] {\n    return Array.from(this.syncQueue.values());\n  }\n\n  /**\n   * Check if online\n   */\n  isOnlineMode(): boolean {\n    return this.isOnline;\n  }\n\n  /**\n   * Get offline status\n   */\n  getOfflineStatus(): {\n    isOnline: boolean;\n    cachedItems: number;\n    pendingSyncs: number;\n  } {\n    return {\n      isOnline: this.isOnline,\n      cachedItems: this.cacheStore.size,\n      pendingSyncs: this.syncQueue.size,\n    };\n  }\n}\n\n/**\n * Service Worker Code (to be saved as public/sw.js)\n */\nexport const serviceWorkerCode = `\nconst CACHE_NAME = 'farmkonnect-cache-v1';\nconst urlsToCache = [\n  '/',\n  '/index.html',\n  '/manifest.json',\n];\n\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME).then((cache) => {\n      return cache.addAll(urlsToCache);\n    })\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  if (event.request.method !== 'GET') {\n    return;\n  }\n\n  event.respondWith(\n    caches.match(event.request).then((response) => {\n      if (response) {\n        return response;\n      }\n\n      return fetch(event.request).then((response) => {\n        if (!response || response.status !== 200 || response.type !== 'basic') {\n          return response;\n        }\n\n        const responseToCache = response.clone();\n        caches.open(CACHE_NAME).then((cache) => {\n          cache.put(event.request, responseToCache);\n        });\n\n        return response;\n      }).catch(() => {\n        return caches.match('/index.html');\n      });\n    })\n  );\n});\n\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          if (cacheName !== CACHE_NAME) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n`;\n
